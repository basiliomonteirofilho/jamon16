<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Upload + ExtraÃ§Ã£o de Features para Treinamento</title>
  <script src="https://cdn.jsdelivr.net/npm/meyda@5.4.0/dist/meyda.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      background: #121212;
      color: #e0e0e0;
      padding: 20px;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    .upload-area {
      border: 2px dashed #444;
      border-radius: 12px;
      padding: 40px;
      text-align: center;
      margin: 20px 0;
      background: #1e1e1e;
      cursor: pointer;
    }
    .status {
      margin: 15px 0;
      padding: 10px;
      border-radius: 8px;
      background: #2a2a2a;
    }
    button {
      background: #5eead4;
      color: #121212;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>ðŸ“¤ Upload + ExtraÃ§Ã£o de Features (MFCC)</h2>
    <p>Carregue pares <code>.wav</code> + <code>.json</code> para extrair features com Web Audio API.</p>

    <div class="upload-area" id="dropZone">
      Arraste arquivos aqui ou clique para selecionar
      <input type="file" id="fileInput" multiple accept=".wav,.json" style="display: none;">
    </div>

    <div class="status" id="status">Aguardando arquivos...</div>

    <button id="btnProcess" disabled>ðŸ§  Extrair Features (MFCC)</button>
    <button id="btnExport" disabled>ðŸ’¾ Exportar Dataset</button>
  </div>

  <script>
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const statusEl = document.getElementById('status');
    const btnProcess = document.getElementById('btnProcess');
    const btnExport = document.getElementById('btnExport');

    let uploadedFiles = [];
    let dataset = []; // { id, metadata, mfcc: Float32Array[], duration }

    // === DRAG & DROP ===
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => {
      dropZone.addEventListener(e, preventDefaults, false);
    });
    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }
    dropZone.addEventListener('drop', e => {
      uploadedFiles = uploadedFiles.concat(Array.from(e.dataTransfer.files));
      renderStatus();
    });
    dropZone.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', e => {
      uploadedFiles = uploadedFiles.concat(Array.from(e.target.files));
      renderStatus();
    });

    function renderStatus() {
      const grouped = groupFiles(uploadedFiles);
      const valid = Object.values(grouped).filter(p => p.wav && p.json).length;
      statusEl.textContent = `Arquivos carregados: ${uploadedFiles.length}. Pares vÃ¡lidos: ${valid}.`;
      btnProcess.disabled = valid === 0;
    }

    function groupFiles(files) {
      const groups = {};
      files.forEach(f => {
        const base = f.name.replace(/\.(wav|json)$/, '');
        if (!groups[base]) groups[base] = {};
        if (f.name.endsWith('.wav')) groups[base].wav = f;
        else if (f.name.endsWith('.json')) groups[base].json = f;
      });
      return groups;
    }

    // === EXTRAÃ‡ÃƒO DE FEATURES ===
    async function processDataset() {
      const grouped = groupFiles(uploadedFiles);
      dataset = [];

      const audioCtx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 1, 44100);

      for (const [base, pair] of Object.entries(grouped)) {
        if (!pair.wav || !pair.json) continue;

        try {
          // LÃª JSON
          const jsonText = await readFileAsText(pair.json);
          const metadata = JSON.parse(jsonText);

          // LÃª Ã¡udio
          const arrayBuffer = await readFileAsArrayBuffer(pair.wav);
          const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

          // Extrai MFCCs (13 coeficientes, janela de 1024, hop = 512)
          const mfccs = extractMFCC(audioBuffer);

          dataset.push({
            id: base,
            metadata,
            mfcc: mfccs,
            duration: audioBuffer.duration
          });

          statusEl.textContent = `Processando: ${base}... (${dataset.length}/${Object.keys(grouped).length})`;
        } catch (err) {
          console.error('Erro ao processar:', base, err);
          alert(`Erro em ${base}: ${err.message}`);
          return;
        }
      }

      statusEl.textContent = `âœ… Dataset pronto! ${dataset.length} exemplos com MFCCs.`;
      btnExport.disabled = false;
    }

    function readFileAsText(file) {
      return new Promise((res, rej) => {
        const r = new FileReader();
        r.onload = () => res(r.result);
        r.onerror = rej;
        r.readAsText(file);
      });
    }

    function readFileAsArrayBuffer(file) {
      return new Promise((res, rej) => {
        const r = new FileReader();
        r.onload = () => res(r.result);
        r.onerror = rej;
        r.readAsArrayBuffer(file);
      });
    }

    function extractMFCC(buffer) {
      const channelData = buffer.getChannelData(0); // mono
      const sampleRate = buffer.sampleRate;
      const hopSize = 512;
      const frameCount = Math.floor((channelData.length - 1024) / hopSize) + 1;
      const mfccs = [];

      for (let i = 0; i < frameCount; i++) {
        const frame = channelData.slice(i * hopSize, i * hopSize + 1024);
        if (frame.length < 1024) break;

        // Meyda trabalha com Float32Array
        const features = Meyda.extract('mfcc', frame, {
          sampleRate,
          bufferSize: 1024,
          numberOfMFCCCoefficients: 13
        });

        mfccs.push(features);
      }

      return mfccs; // Array de Float32Array (13 dimensÃµes)
    }

    // === EXPORTAÃ‡ÃƒO ===
    function exportDataset() {
      // Simplifica: salva apenas metadados + estatÃ­sticas (MFCCs sÃ£o grandes!)
      const exportData = dataset.map(item => ({
        id: item.id,
        bpm: item.metadata.bpm,
        key: item.metadata.key,
        quality: item.metadata.quality,
        style: item.metadata.style,
        duration: item.duration,
        mfccFrames: item.mfcc.length,
        avgMfcc: Array.from(item.mfcc[0] || new Float32Array(13)) // exemplo: primeiro frame
      }));

      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'dataset-features.json';
      a.click();
      URL.revokeObjectURL(url);
    }

    // === EVENTOS ===
    btnProcess.addEventListener('click', processDataset);
    btnExport.addEventListener('click', exportDataset);
  </script>
</body>
</html>