<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jam On – Composição Manual</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      background: #121212;
      color: #e0e0e0;
      margin: 0;
      padding: 20px;
    }
    header {
      text-align: center;
      margin-bottom: 20px;
    }
    h1 {
      color: #5eead4;
      font-size: 1.8em;
      margin: 0;
    }
    .pill {
      display: inline-block;
      background: #333;
      color: #aaa;
      font-size: 0.75em;
      padding: 4px 10px;
      border-radius: 12px;
    }
    .card {
      max-width: 1200px;
      margin: 0 auto;
      background: #1e1e1e;
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      overflow: hidden;
      padding: 20px;
      text-align: left;
    }
    .section {
      margin: 25px 0;
      padding: 15px;
      border: 1px solid #333;
      border-radius: 10px;
      background: #222;
    }
    .section h3 {
      color: #5eead4;
      margin-top: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .add-btn {
      background: #4CAF50;
      color: white;
      font-size: 1.2em;
      padding: 6px 10px;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    .instrument-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin: 15px 0;
    }
    .instrument-block {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      min-width: 220px;
    }
    .bass-block { border-left: 4px solid #ffcc00; }
    .melody1-block { border-left: 4px solid #ff6b6b; }
    .melody2-block { border-left: 4px solid #4ecdc4; }
    .drum-block { border-left: 4px solid #8e44ad; }
    .harmony-block { border-left: 4px solid #9b59b6; }
    /* ===== ESTILO DO GRID DE COLUNAS ===== */
    .columns-grid {
      display: flex;
      gap: 2px;
      margin: 10px 0;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding: 5px 0;
      position: relative;
    }
    .column {
  display: flex;
  flex-direction: column;
  gap: 2px;
  align-items: center;
  /* --- NOVO: Fundo alternado a cada 4 colunas --- */
  background-color: transparent; /* Fundo padrão */
}
.column:nth-child(4n+1),
.column:nth-child(4n+2),
.column:nth-child(4n+3) {
  background-color: rgba(255, 255, 255, 0.03); /* Cinza muito claro */
}
.column:nth-child(4n) {
  background-color: rgba(255, 255, 255, 0.08); /* Cinza um pouco mais escuro, marca o final do compasso */
}
    .cell {
  width: 45px;
  height: 45px;
  background: #333;
  border: 1px solid #555;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.7em;
  cursor: pointer;
  color: #ccc;
  user-select: none;
  transition: background 0.2s;
  position: relative; /* Para posicionar o botão de delete e o rótulo */
}

/* Estilo do rótulo numérico (aparece a cada 4 colunas) */
.cell .column-number-label {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.1); /* Cinza claro com baixa opacidade */
  color: rgba(255, 255, 255, 0.6);
  font-size: 0.9em;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2;
  pointer-events: none; /* Torna o rótulo não clicável */
  border-radius: 4px;
}
    .cell:hover {
      background: #444;
    }
    .cell.x {
      background: #555;
      color: #888;
      font-weight: bold;
    }
    /* Botão de Excluir Célula Individual (e agora também Coluna) */
    .delete-cell-btn {
      position: absolute;
      top: -8px;
      right: -8px;
      background: #f44336;
      color: white;
      border: none;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      font-size: 0.6em;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      z-index: 10;
    }
    .delete-cell-btn:hover {
      background: #d32f2f;
    }
    /* ===== ESTILO DA BATERIA ===== */
    /* Container principal da bateria com layout em grid */
    .drum-wrapper {
  display: flex;
  align-items: flex-start;
  gap: 10px;
  width: 100%; /* Força o wrapper a respeitar a largura do pai */
  min-width: 0; /* Permite que o conteúdo interno seja cortado (crucial para overflow) */
}
    /* Coluna fixa para os rótulos das peças da bateria */
    .drum-labels {
      display: flex;
      flex-direction: column;
      gap: 2px;
      align-items: flex-start;
      justify-content: flex-start;
      padding-top: 5px; /* Ajuste fino para alinhar verticalmente */
    }
    /* Estilo do rótulo da peça da bateria */
    .drum-label-item {
      width: 120px;
      height: 45px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-right: none;
      border-radius: 4px 0 0 4px;
      display: flex;
      align-items: center;
      padding: 0 8px;
      text-align: left;
      font-size: 0.7em;
      color: #ccc;
      box-sizing: border-box;
    }
    /* Célula da bateria - agora sem o label interno */
    .drum-cell {
      width: 45px;
      height: 45px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7em;
      cursor: pointer;
      color: #ccc;
      transition: background 0.2s;
      position: relative;
    }
    .drum-cell.active {
      background: #5eead4;
      color: #121212;
    }
    .drum-cell:hover {
      background: #444;
    }
    .instrument-select, .chord-select {
      margin: 10px 0;
      padding: 8px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      color: white;
      width: 100%;
    }
    .bpm-control {
      text-align: center;
      margin: 15px 0;
    }
    .bpm-display {
      font-size: 1.5em;
      font-weight: bold;
      color: #5eead4;
      margin: 10px 0;
    }
    .bpm-slider {
      width: 80%;
      margin: 10px auto;
    }
    .btn-row {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
    }
    button {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      font-size: 1em;
      transition: opacity 0.2s;
    }
    button.primary {
      background: #5eead4;
      color: #121212;
    }
    button.danger {
      background: #f44336;
      color: white;
    }
    button:hover:not(:disabled) {
      opacity: 0.9;
    }
    .loading {
      text-align: center;
      padding: 20px;
      color: #5eead4;
    }
    .status-indicator {
      text-align: center;
      padding: 10px;
      margin: 10px 0;
      border-radius: 6px;
    }
    .status-ready {
      background: #2a4d2a;
      color: #8eff8e;
    }
    .status-loading {
      background: #4d462a;
      color: #ffe08e;
    }
    .status-error {
      background: #4d2a2a;
      color: #ff8e8e;
    }
    .instructions {
      font-size: 0.85em;
      color: #aaa;
      margin-top: 8px;
      text-align: center;
    }
    .countdown {
      font-size: 2em;
      color: #ffcc00;
      text-align: center;
      margin: 20px 0;
      font-weight: bold;
    }
    /* ===== ESTILO DO MODAL ===== */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    .modal {
      background: #2a2a2a;
      border: 2px solid #5eead4;
      border-radius: 12px;
      padding: 20px;
      max-width: 90%;
      max-height: 90%;
      overflow-y: auto;
      box-shadow: 0 0 30px rgba(94, 234, 212, 0.5);
    }
    .modal h2 {
      color: #5eead4;
      margin-top: 0;
      text-align: center;
    }
    .modal-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 8px;
      margin-top: 20px;
    }
    .modal-option {
      padding: 10px;
      background: #333;
      border: 1px solid #555;
      border-radius: 6px;
      text-align: center;
      cursor: pointer;
      transition: background 0.2s;
    }
    .modal-option:hover {
      background: #444;
    }
    .modal-option.x {
      background: #555;
      color: #888;
    }
    /* ===== ESTILO DA BARRA DE PROGRESSO ===== */
    .progress-container {
      width: 100%;
      background: #333;
      border-radius: 4px;
      margin: 10px 0;
      height: 10px;
    }
    .progress-bar {
      height: 100%;
      background: #5eead4;
      border-radius: 4px;
      width: 0%;
      transition: width 0.3s ease;
    }
    /* ===== MARCADOR DE SEMÍNIMA ===== */
    .semibreve-marker {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 1px;
      background: rgba(255, 255, 255, 0.3);
      z-index: 5;
      pointer-events: none;
    }
    .semibreve-marker::after {
      content: '|';
      position: absolute;
      top: -20px;
      left: -5px;
      color: rgba(255, 255, 255, 0.5);
      font-size: 14px;
      font-weight: bold;
    }
    /* ===== ESTILO DO MAPA DE EDIÇÃO ===== */
.edit-map-container {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #2a2a2a;
  border: 1px solid #444;
  border-radius: 8px;
  padding: 15px;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 4px 10px rgba(0,0,0,0.5);
  z-index: 1000;
  width: 200px;
}

.edit-map-title {
  color: #5eead4;
  font-size: 1.1em;
  margin: 0 0 15px 0;
  text-align: center;
}

.edit-map-item {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
  padding: 6px;
  border-radius: 4px;
  cursor: pointer;
  transition: background 0.2s;
}

.edit-map-item:hover {
  background: #3a3a3a;
}

.edit-map-item.active {
  background: #5eead4;
  color: #121212;
  font-weight: bold;
}

.edit-map-number {
  font-weight: bold;
  width: 25px;
  text-align: center;
  margin-right: 10px;
  color: #5eead4;
}

.edit-map-cells {
  display: flex;
  gap: 2px;
}

.edit-map-cell {
  width: 12px;
  height: 12px;
  border: 1px solid #555;
  border-radius: 2px;
  background: #333;
}

.edit-map-cell.filled {
  background: #5eead4;
}

.edit-map-cell.x {
  background: #555;
}
    @media (max-width: 768px) {
      .cell, .drum-cell { 
        width: 35px;
        height: 35px;
        font-size: 0.6em;
      }
      .drum-label-item { 
        width: 80px;
        font-size: 0.6em; 
        padding: 0 6px;
        height: 35px;
      }
      button { padding: 10px 15px; }
      .add-btn { width: 25px; height: 25px; font-size: 1em; }
      .instrument-block { min-width: 160px; }
      .delete-cell-btn {
        width: 14px;
        height: 14px;
        font-size: 0.5em;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Jam On – Composição Manual</h1>
    <div class="pill">Cada célula = semicolcheia (1/4 da semínima)</div>
  </header>
  <div class="card">
    <div id="statusIndicator" class="status-indicator status-loading">
      Carregando... Clique 8 vezes para preparar o som.
    </div>
    <div class="countdown" id="countdown"></div>
    <div class="section">
      <h3>🎛️ Controle de BPM</h3>
      <div class="bpm-control">
        <div class="bpm-display" id="bpmDisplay">100 BPM</div>
        <input type="range" id="bpmSlider" class="bpm-slider" min="60" max="180" value="100" step="1">
      </div>
    </div>
    <!-- ÚNICO BOTÃO "+" QUE ADICIONA COMPASSO EM TODOS OS INSTRUMENTOS -->
    <div style="text-align: center; margin: 20px 0;">
      <button id="addCompassoBtn" class="add-btn">+</button>
      <span style="color: #aaa; margin-left: 10px;">Adicionar compasso em todos os instrumentos</span>
    </div>
    <!-- HARMONIA (4 células por instrumento = 1 compasso) -->
    <div class="section">
      <h3>🎸 Harmonia 1</h3>
      <div id="harmonyContainer1" class="instrument-container"></div>
    </div>
    <div class="section">
      <h3>🎸 Harmonia 2</h3>
      <div id="harmonyContainer2" class="instrument-container"></div>
    </div>
    <div class="section">
      <h3>🎸 Harmonia 3</h3>
      <div id="harmonyContainer3" class="instrument-container"></div>
    </div>
    <!-- BAIXO (4 células = 1 compasso) -->
    <div class="section">
      <h3>🎸 Baixo</h3>
      <div id="bassContainer" class="instrument-container"></div>
    </div>
    <!-- MELODIA 1 (4 células = 1 compasso) -->
    <div class="section">
      <h3>🎹 Melodia 1</h3>
      <div id="melody1Container" class="instrument-container"></div>
    </div>
    <!-- MELODIA 2 (4 células = 1 compasso) -->
    <div class="section">
      <h3>🎷 Melodia 2</h3>
      <div id="melody2Container" class="instrument-container"></div>
    </div>
    <!-- BATERIA (4 células = 1 compasso) -->
    <div class="section">
      <h3>🥁 Bateria</h3>
      <div id="drumContainer" class="instrument-container"></div>
    </div>    
    <div class="btn-row">
      <button id="btnPlay" class="primary" disabled>▶ Play</button>
      <button id="btnStop" class="danger" disabled>⏹ Stop</button>
      <button id="btnSaveWAV" class="primary" disabled>💾 Salvar como WAV</button>
      <button id="btnDuplicate" class="primary">🔁 Duplicar Edição</button>
    </div>
    <div class="instructions">
      Clique em uma célula para escolher uma nota ou acorde.<br>
      Use "+" para adicionar uma coluna em todos os instrumentos.<br>
      <strong>Clique 8 vezes em qualquer célula para preparar os sons.</strong>
    </div>
  </div>
  <!-- MODAL (inicialmente oculto) -->
  <div id="selectionModal" class="modal-overlay" style="display: none;">
    <div class="modal">
      <h2 id="modalTitle">Selecione uma opção</h2>
      <div id="modalGrid" class="modal-grid">
        <!-- As opções serão inseridas aqui dinamicamente -->
      </div>
    </div>
  </div>
  <!-- CONTAINER DA BARRA DE PROGRESSO (inicialmente oculto) -->
  <div id="progressContainer" style="display: none; text-align: center; margin: 20px 0;">
    <div>Renderizando...</div>
    <div class="progress-container">
      <div id="progressBar" class="progress-bar"></div>
    </div>
    <div id="progressText">0%</div>
  </div>
 <script>
// ===== CONSTANTES =====
const AVAILABLE_CHORDS = [
  'X', // ← OPÇÃO EM BRANCO ADICIONADA
  // Acordes em A
  'A', 'A11', 'A13', 'A4', 'A45+', 'A5', 'A5+', 'A6', 'A7', 'A75+', 'A9', 'A95+', 'Adim', 
  'Am', 'Am5', 'Am5+', 'Am6', 'Am7', 'Am75+', 'Am9',
  // Acordes em AS (A#)
  'AS', 'AS11', 'AS13', 'AS4', 'AS45+', 'AS5', 'AS5+', 'AS6', 'AS7', 'AS75+', 'AS9', 'AS95+',
  'ASdim', 'ASm', 'ASm5', 'ASm5+', 'ASm6', 'ASm7', 'ASm75+', 'ASm9',
  // Acordes em B
  'B', 'B11', 'B13', 'B4', 'B45+', 'B5', 'B5+', 'B6', 'B7', 'B75+', 'B9', 'B95+', 'Bdim',
  'Bm', 'Bm5', 'Bm5+', 'Bm6', 'Bm7', 'Bm75+', 'Bm9',
  // Acordes em C
  'C', 'C11', 'C13', 'C4', 'C45+', 'C5', 'C5+', 'C6', 'C7', 'C75+', 'C9', 'C95+', 'Cdim',
  'Cm', 'Cm5', 'Cm5+', 'Cm6', 'Cm7', 'Cm75+', 'Cm9',
  // Acordes em CS (C#)
  'CS', 'CS11', 'CS13', 'CS4', 'CS45+', 'CS5', 'CS5+', 'CS6', 'CS7', 'CS75+', 'CS9', 'CS95+',
  'CSdim', 'CSm', 'CSm5', 'CSm5+', 'CSm6', 'CSm7', 'CSm75+', 'CSm9',
  // Acordes em D
  'D', 'D11', 'D13', 'D4', 'D45+', 'D5', 'D5+', 'D6', 'D7', 'D75+', 'D9', 'D95+', 'Ddim',
  'Dm', 'Dm5', 'Dm5+', 'Dm6', 'Dm7', 'Dm75+', 'Dm9',
  // Acordes em E
  'E', 'E11', 'E13', 'E4', 'E45+', 'E5', 'E5+', 'E6', 'E7', 'E75+', 'E9', 'E95+', 'Edim',
  'Em', 'Em5', 'Em5+', 'Em6', 'Em7', 'Em75+', 'Em9',
  // Acordes em DS (D#)
  'DS', 'DS11', 'DS13', 'DS4', 'DS45+', 'DS5', 'DS5+', 'DS6', 'DS7', 'DS75+', 'DS9', 'DS95+',
  'DSdim', 'DSm', 'DSm5', 'DSm5+', 'DSm6', 'DSm7', 'DSm75+', 'DSm9',
  // Acordes em F
  'F', 'F11', 'F13', 'F4', 'F45+', 'F5', 'F5+', 'F6', 'F7', 'F75+', 'F9', 'F95+', 'Fdim',
  'Fm', 'Fm5', 'Fm5+', 'Fm6', 'Fm7', 'Fm75+', 'Fm9',
  // Acordes em FS (F#)
  'FS', 'FS11', 'FS13', 'FS4', 'FS45+', 'FS5', 'FS5+', 'FS6', 'FS7', 'FS75+', 'FS9', 'FS95+',
  'FSdim', 'FSm', 'FSm5', 'FSm5+', 'FSm6', 'FSm7', 'FSm75+', 'FSm9',
  // Acordes em G
  'G', 'G11', 'G13', 'G4', 'G45+', 'G5', 'G5+', 'G6', 'G7', 'G75+', 'G9', 'G95+', 'Gdim',
  'Gm', 'Gm5', 'Gm5+', 'Gm6', 'Gm7', 'Gm75+', 'Gm9',
  // Acordes em GS (G#)
  'GS', 'GS11', 'GS13', 'GS4', 'GS45+', 'GS5', 'GS5+', 'GS6', 'GS7', 'GS75+', 'GS9', 'GS95+',
  'GSdim', 'GSm', 'GSm5', 'GSm5+', 'GSm6', 'GSm7', 'GSm75+', 'GSm9'
];
const NOTE_NAMES = [
  'X', // ← OPÇÃO EM BRANCO ADICIONADA
  '10CS.mp3', '11D.mp3', '12DS.mp3', '13E.mp3', '14F.mp3', '15FS.mp3', '16G.mp3', '17GS.mp3', 
  '18A.mp3', '19AS.mp3', '1E.mp3', '20B.mp3', '21C.mp3', '22CS.mp3', '23D.mp3', '24DS.mp3', 
  '25E.mp3', '26F.mp3', '27FS.mp3', '28G.mp3', '29GS.mp3', '2F.mp3', '30A.mp3', '31AS.mp3', 
  '32B.mp3', '33C.mp3', '34CS.mp3', '35D.mp3', '36DS.mp3', '37E.mp3', '38F.mp3', '39FS.mp3', 
  '3FS.mp3', '40G.mp3', '41GS.mp3', '42A.mp3', '43AS.mp3', '44B.mp3', '45C.mp3', '46CS.mp3', 
  '47D.mp3', '48DS.mp3', '49E.mp3', '4G.mp3', '5GS.mp3', '6A.mp3', '7AS.mp3', '8B.mp3', '9C.mp3'
];
// Ordena as notas pelo número antes do nome da nota (ex: '1E' vem antes de '10CS')
const ALL_NOTES = NOTE_NAMES
  .map(name => name.replace('.mp3', ''))
  .sort((a, b) => {
    if (a === 'X') return -1; // Mantém 'X' no início
    if (b === 'X') return 1;
    const numA = parseInt(a.match(/^\d+/)[0]);
    const numB = parseInt(b.match(/^\d+/)[0]);
    return numA - numB;
  });
const NOTE_FREQ = {
  'C': 261.63, 'CS': 277.18, 'D': 293.66, 'DS': 311.13, 'E': 329.63, 'F': 349.23,
  'FS': 369.99, 'G': 392.00, 'GS': 415.30, 'A': 440.00, 'AS': 466.16, 'B': 493.88
};
const MELODIC_INSTRUMENTS = {
  'acordeon': 'assets/AcordeonMelodia/',       // assets/AcordeonMelodia/nota.mp3
  'bass': 'assets/BaixoMelodia/',              // assets/BaixoMelodia/nota.mp3
  'strings': 'assets/Cordas/',                 // assets/Cordas/nota.mp3
  'piano': 'assets/PianoString/',              // assets/PianoString/nota.mp3
  'sax': 'assets/SaxMelodia/',                 // assets/SaxMelodia/nota.mp3
  'sinos': 'assets/SinosMelodia/',             // assets/SinosMelodia/nota.mp3 (adicionado)
  'acoustic-guitar': 'assets/ViolaoAcoMelodia/', // assets/ViolaoAcoMelodia/nota.mp3
  'nylon-guitar': 'assets/ViolaoNylonMelodia/',  // assets/ViolaoNylonMelodia/nota.mp3
  'distorted-guitar-melody': 'guitarraDistorcao/Melodia/' // guitarraDistorcao/Melodia/nota.mp3
};
// ===== CORREÇÃO AQUI: Caminhos dos Instrumentos Harmônicos =====
const HARMONIC_INSTRUMENTS = {
  'distorted-guitar': 'guitarraDistorcao/',    // guitarraDistorcao/Nota/acorde.mp3
  'clean-guitar': 'guitarraLimpa/',            // guitarraLimpa/Nota/acorde.mp3
  'piano-chord': 'assets/PianoStringChord/'    // assets/PianoStringChord/Nota/acorde.mp3
};
const DRUM_SAMPLES = [
  { key: 'ataque', label: 'Prato De Ataque', path: 'assets/ataque.mp3' },
  { key: 'bumbo', label: 'Bumbo', path: 'assets/bumbo.mp3' },
  { key: 'caixa', label: 'Caixa', path: 'assets/caixa.mp3' },
  { key: 'chimbal', label: 'Chimbal Fechado', path: 'assets/chimbal.mp3' },
  { key: 'chimbal-aberto', label: 'Chimbal Aberto', path: 'assets/chimbal-aberto.mp3' },
  { key: 'conducao', label: 'Condução', path: 'assets/conducao.mp3' },
  { key: 'conducao-centro', label: 'Condução Centro', path: 'assets/conducao-centro.mp3' },
  { key: 'surdo', label: 'Surdo', path: 'assets/surdo.mp3' },
  { key: 'tom-1', label: 'Tom 1', path: 'assets/tom-1.mp3' },
  { key: 'tom-2', label: 'Tom 2', path: 'assets/tom-2.mp3' }
];
// ===== ESTADO =====
const state = {
  running: false,
  paused: false,
  bpm: 100,
  stepIndex: 0,
  totalSteps: 4,
  buffers: {
    drums: {},
    melodic: {},
    harmonic: {}
  },
  loadedSamples: new Set(),
  activeInput: null,
  schedulerTimer: null,
  harmonyBlocks: [[], [], []], // Agora é um array de 3 arrays, um para cada container de harmonia
  bassBlocks: [],
  melody1Blocks: [],
  melody2Blocks: [],
  drumBlocks: [],
  lastNoteTime: 0,
  recordedChunks: [],
  audioCtx: null,
  isPlaying: false,
  isRendering: false,
  countdownActive: false,
  countdownValue: 4,
  currentlyPlaying: { 
    bass: null,
    melody1: null,
    melody2: null,
    harmony1: null,
    harmony2: null,
    harmony3: null
  },
  playbackPlan: null,
  // Estado do Modal
  modal: {
    targetCell: null,
    type: null, // 'harmony' ou 'melodic'
    instrumentKey: null
  }
};
// ===== ELEMENTOS =====
const ui = {
  statusIndicator: document.getElementById('statusIndicator'),
  countdown: document.getElementById('countdown'),
  bpmSlider: document.getElementById('bpmSlider'),
  bpmDisplay: document.getElementById('bpmDisplay'),
  btnPlay: document.getElementById('btnPlay'),
  btnStop: document.getElementById('btnStop'),
  btnSaveWAV: document.getElementById('btnSaveWAV'),
  addCompassoBtn: document.getElementById('addCompassoBtn'),
  harmonyContainer1: document.getElementById('harmonyContainer1'),
  harmonyContainer2: document.getElementById('harmonyContainer2'),
  harmonyContainer3: document.getElementById('harmonyContainer3'),
  bassContainer: document.getElementById('bassContainer'),
  melody1Container: document.getElementById('melody1Container'),
  melody2Container: document.getElementById('melody2Container'),
  drumContainer: document.getElementById('drumContainer'),
  selectionModal: document.getElementById('selectionModal'),
  modalTitle: document.getElementById('modalTitle'),
  modalGrid: document.getElementById('modalGrid'),
  progressContainer: document.getElementById('progressContainer'),
  progressBar: document.getElementById('progressBar'),
  progressText: document.getElementById('progressText')
};
// ===== INICIALIZAÇÃO =====
async function initializeApp() {
  updateStatus('Pronto para compor. Clique nas células para criar sua música.', 'ready');
  try {
    state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    state.masterGain = state.audioCtx.createGain();
    state.drumGain = state.audioCtx.createGain();
    state.bassGain = state.audioCtx.createGain();
    state.melodyGain = state.audioCtx.createGain();
    state.harmonicGain = state.audioCtx.createGain();
    state.masterGain.connect(state.audioCtx.destination);
    state.drumGain.connect(state.masterGain);
    state.bassGain.connect(state.masterGain);
    state.melodyGain.connect(state.masterGain);
    state.harmonicGain.connect(state.masterGain);
    state.masterGain.gain.value = 0.8;
    state.drumGain.gain.value = 1.0;
    state.bassGain.gain.value = 0.5;
    state.melodyGain.gain.value = 0.5;
    state.harmonicGain.gain.value = 0.5;
    setupEventListeners();
    // --- CORREÇÃO DEFINITIVA: Garante 3 blocos independentes ---
    // Limpa os arrays de estado antes de adicionar os blocos
    state.harmonyBlocks = [[], [], []];
    state.bassBlocks = [];
    state.melody1Blocks = [];
    state.melody2Blocks = [];
    state.drumBlocks = [];
    
    // Adiciona 1 bloco em cada container de harmonia
    addHarmonyBlock(0); // Harmonia 1
    addHarmonyBlock(1); // Harmonia 2
    addHarmonyBlock(2); // Harmonia 3
    
    // Adiciona 1 bloco de cada instrumento melódico e de bateria
    addBassBlock();
    addMelody1Block();
    addMelody2Block();
    addDrumBlock();
    ui.btnPlay.disabled = false;
    ui.btnSaveWAV.disabled = true;
    ui.btnStop.disabled = true;
    updateStatus('Componha sua música. Clique em Play para iniciar com contagem de 4 compassos.', 'ready');
    updateEditMap();
} catch (error) {
    console.error('Erro ao inicializar:', error);
    updateStatus('Erro ao inicializar: ' + error.message, 'error');
  }
}
function setupEventListeners() {
  updateBPMDisplay();
  ui.bpmSlider.addEventListener('input', handleBPMChange);
  ui.addCompassoBtn.addEventListener('click', addCompasso);
  ui.btnPlay.addEventListener('click', onPlay);
  ui.btnStop.addEventListener('click', onStop);
  ui.btnSaveWAV.addEventListener('click', () => renderAndDownloadWAV()); // Sem duração fixa
  document.getElementById('btnDuplicate').addEventListener('click', duplicateComposition);
  document.addEventListener('click', function(e) {
    if (e.target.classList.contains('cell') || e.target.classList.contains('drum-cell')) {
      if (e.target.classList.contains('cell')) {
        const instrument = e.target.parentElement.parentElement.querySelector('.instrument-select').value;
        const type = e.target.parentElement.dataset.type;
        const noteOrChord = e.target.textContent;
        if (type === 'harmony') {
          loadSample('harmonic', instrument, noteOrChord);
        } else {
          loadSample('melodic', instrument, noteOrChord);
        }
      } else if (e.target.classList.contains('drum-cell')) {
        const drumKey = e.target.dataset.instr;
        loadSample('drum', drumKey, '');
      }
    }
  });
  // Evento para fechar o modal ao clicar fora dele
  ui.selectionModal.addEventListener('click', function(e) {
    if (e.target === this) {
      closeModal();
    }
  });

  
}
function handleBPMChange() {
  state.bpm = parseInt(ui.bpmSlider.value);
  updateBPMDisplay();
}
function updateBPMDisplay() {
  ui.bpmDisplay.textContent = `${state.bpm} BPM`;
}
function updateStatus(message, type) {
  ui.statusIndicator.textContent = message;
  ui.statusIndicator.className = 'status-indicator status-' + type;
}
// ===== CARREGAMENTO SOB DEMANDA (CORRIGIDO) =====
async function loadSample(instrumentType, key, noteOrChord) {
  let filePath;
  let bufferKey;
  if (instrumentType === 'drum') {
    const sample = DRUM_SAMPLES.find(d => d.key === key);
    if (!sample) return;
    filePath = sample.path;
    bufferKey = key;
  } else if (instrumentType === 'melodic') {
    if (noteOrChord === 'X') return; // Ignora 'X'
    filePath = MELODIC_INSTRUMENTS[key] + noteOrChord + '.mp3';
    bufferKey = `melodic-${key}-${noteOrChord}`;
  } else if (instrumentType === 'harmonic') {
    if (noteOrChord === 'X') return; // Ignora 'X'
    let root;
    if (noteOrChord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(noteOrChord.slice(0, 2))) {
      root = noteOrChord.slice(0, 2);
    } else {
      root = noteOrChord[0];
    }
    // Monta o caminho: HARMONIC_INSTRUMENTS[key] + root + '/' + noteOrChord + '.mp3'
    filePath = HARMONIC_INSTRUMENTS[key] + root + '/' + noteOrChord + '.mp3';
    bufferKey = filePath; // Usa o caminho completo como chave
  }
  if (!filePath) return;
  if (state.loadedSamples.has(bufferKey)) return;
  try {
    const response = await fetch(filePath);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const arrayBuffer = await response.arrayBuffer();
    const buffer = await state.audioCtx.decodeAudioData(arrayBuffer);
    if (instrumentType === 'drum') {
      state.buffers.drums[bufferKey] = buffer;
    } else if (instrumentType === 'melodic') {
      state.buffers.melodic[bufferKey] = buffer;
    } else if (instrumentType === 'harmonic') {
      state.buffers.harmonic[bufferKey] = buffer;
    }
    state.loadedSamples.add(bufferKey);
    console.log(`✅ Carregado: ${filePath} → chave: ${bufferKey}`);
  } catch (err) {
    console.warn(`⚠️ Não encontrado: ${filePath}`);
  }
}
// ===== MODAL DE SELEÇÃO =====
function openModal(type, options, targetCell, instrumentKey) {
  state.modal.type = type;
  state.modal.targetCell = targetCell;
  state.modal.instrumentKey = instrumentKey;
  ui.modalTitle.textContent = type === 'harmony' ? 'Selecione um Acorde' : 'Selecione uma Nota';
  ui.modalGrid.innerHTML = '';
  // CORREÇÃO: Substitui "S" por "#" apenas na exibição
  options.forEach(option => {
    const div = document.createElement('div');
    div.className = 'modal-option';
    if (option === 'X') {
      div.classList.add('x');
    }
    // Exibe "#" em vez de "S" na interface, mas mantém o valor original
    let displayText = option;
    if (option !== 'X') {
      displayText = option.replace(/S/g, '#');
    }
    div.textContent = displayText;
    // Armazena o valor original como atributo
    div.dataset.originalValue = option;
    div.addEventListener('click', function() {
      const originalValue = this.dataset.originalValue;
      // --- CORREÇÃO AQUI ---
      // 1. Guarda uma referência ao botão de delete
      const deleteBtn = targetCell.querySelector('.delete-cell-btn');
      // 2. Remove o botão temporariamente
      if (deleteBtn) {
        targetCell.removeChild(deleteBtn);
      }
      // 3. Define o novo texto da célula (com # na interface)
      targetCell.textContent = displayText;
      // 4. Armazena o valor original
      targetCell.dataset.originalValue = originalValue;
      // 5. Reaplica a classe 'x' conforme necessário
      if (originalValue === 'X') {
        targetCell.classList.add('x');
      } else {
        targetCell.classList.remove('x');
      }
      // 6. Adiciona o botão de volta
      if (deleteBtn) {
        targetCell.appendChild(deleteBtn);
      }
      // Muta o som anterior
      const category = type === 'harmony' ? 'harmony' : targetCell.parentElement.parentElement.dataset.type.replace('Block', '').toLowerCase();
      if (state.currentlyPlaying[category] !== null) {
        state.currentlyPlaying[category] = null;
      }
      // Carrega a amostra (usa o valor original)
      if (type === 'harmony') {
        loadSample('harmonic', instrumentKey, originalValue);
      } else {
        loadSample('melodic', instrumentKey, originalValue);
      }
      closeModal();
    });
    ui.modalGrid.appendChild(div);
  });
  ui.selectionModal.style.display = 'flex';
}
function closeModal() {
  ui.selectionModal.style.display = 'none';
  state.modal = {
    targetCell: null,
    type: null,
    instrumentKey: null
  };
}

// Função modificada para aceitar um índice de container
function addHarmonyBlock(containerIndex) {
  const blockIndex = state.harmonyBlocks[containerIndex].length;
  const wrapper = document.createElement('div');
  wrapper.className = 'instrument-wrapper';
  wrapper.style.display = 'flex';
  wrapper.style.alignItems = 'flex-start';
  wrapper.dataset.blockIndex = blockIndex;
  wrapper.dataset.containerIndex = containerIndex; // Identifica qual container pertence
  
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.style.width = '120px';
  instrumentSelect.style.marginRight = '10px';
  instrumentSelect.innerHTML = `
    <option value="distorted-guitar">Guitarra Distorcida</option>
    <option value="clean-guitar">Guitarra Limpa</option>
    <option value="piano-chord">Piano</option>
  `;
  
  const block = document.createElement('div');
  block.className = 'instrument-block harmony-block';
  block.style.flex = '1';
  block.dataset.blockIndex = blockIndex;
  block.dataset.containerIndex = containerIndex;
  
  const grid = document.createElement('div');
  grid.className = 'columns-grid';
  grid.dataset.type = 'harmony';
  grid.dataset.blockIndex = blockIndex;
  grid.dataset.containerIndex = containerIndex;
  grid.style.position = 'relative';
  
  const harmonyBlock = {
    wrapper,
    instrumentSelect,
    grid,
    containerIndex
  };
  
  for (let i = 0; i < 4; i++) {
    createHarmonyColumn(grid, i, harmonyBlock);
  }
  
  block.appendChild(grid);
  wrapper.appendChild(instrumentSelect);
  wrapper.appendChild(block);
  
  
  // Adiciona ao container correto
  const containerId = `harmonyContainer${containerIndex + 1}`;
  document.getElementById(containerId).appendChild(wrapper);
  
  state.harmonyBlocks[containerIndex].push(harmonyBlock);
  return wrapper;
}
function createHarmonyColumn(parentGrid, columnIndex, harmonyBlock) {
  const column = document.createElement('div');
  column.className = 'column';
  column.dataset.columnIndex = columnIndex;
  const cell = document.createElement('div');
  cell.className = 'cell x';
  cell.textContent = 'X';

  // --- ADICIONA O RÓTULO NUMÉRICO A CADA 4 COLUNAS ---
  if ((columnIndex + 1) % 4 === 0 && columnIndex > 0) {
    const label = document.createElement('div');
    label.className = 'column-number-label';
    label.textContent = columnIndex + 1; // Exibe o número da coluna (1-indexed)
    cell.appendChild(label);
  }

  const deleteCellBtn = document.createElement('button');
  deleteCellBtn.className = 'delete-cell-btn';
  deleteCellBtn.textContent = '✖';
  deleteCellBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    if (confirm('Excluir toda a coluna vertical (inclusive bateria, harmonia e melodias)?')) {
      deleteColumn(columnIndex);
    } else {
      cell.textContent = 'X';
      cell.classList.add('x');
      cell.appendChild(deleteCellBtn);
    }
  });
  cell.appendChild(deleteCellBtn);
  column.appendChild(cell);
  parentGrid.appendChild(column);
  cell.addEventListener('click', function(e) {
    e.stopPropagation();
    const instrumentKey = harmonyBlock.instrumentSelect.value;
    openModal('harmony', AVAILABLE_CHORDS, this, instrumentKey);
  });
}

function addBassBlock() {
  const blockIndex = state.bassBlocks.length;
  const wrapper = document.createElement('div');
  wrapper.className = 'instrument-wrapper';
  wrapper.style.display = 'flex';
  wrapper.style.alignItems = 'flex-start';
  wrapper.dataset.blockIndex = blockIndex;
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.style.width = '120px';
  instrumentSelect.style.marginRight = '10px';
  instrumentSelect.innerHTML = `
    <option value="bass">Baixo</option>   
  `;
  const block = document.createElement('div');
  block.className = 'instrument-block bass-block';
  block.style.flex = '1';
  block.dataset.blockIndex = blockIndex;
  const grid = createMelodicGrid('bass', blockIndex, 4);
  // Adiciona marcadores de semínima
  
  block.appendChild(grid);
  wrapper.appendChild(instrumentSelect);
  wrapper.appendChild(block);
  ui.bassContainer.appendChild(wrapper);
  state.bassBlocks.push(wrapper);
  return wrapper;
}

function addMelody1Block() {
  const blockIndex = state.melody1Blocks.length;
  const wrapper = document.createElement('div');
  wrapper.className = 'instrument-wrapper';
  wrapper.style.display = 'flex';
  wrapper.style.alignItems = 'flex-start';
  wrapper.dataset.blockIndex = blockIndex;
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.style.width = '120px';
  instrumentSelect.style.marginRight = '10px';
  instrumentSelect.innerHTML = `
    <option value="piano">Piano</option>
  <option value="sax">Saxofone</option>
  <option value="acordeon">Acordeon</option>
  <option value="strings">Cordas</option>
  <option value="sinos">Sinos</option> <!-- Adicionado -->
  <option value="acoustic-guitar">Violão Aço</option>
  <option value="nylon-guitar">Violão Nylon</option>
  <option value="distorted-guitar-melody">Guitarra Distorcida (Melodia)
  </option>
  `;
  const block = document.createElement('div');
  block.className = 'instrument-block melody1-block';
  block.style.flex = '1';
  block.dataset.blockIndex = blockIndex;
  const grid = createMelodicGrid('melody1', blockIndex, 4);
  // Adiciona marcadores de semínima
  
  block.appendChild(grid);
  wrapper.appendChild(instrumentSelect);
  wrapper.appendChild(block);
  ui.melody1Container.appendChild(wrapper);
  state.melody1Blocks.push(wrapper);
  return wrapper;
}

function addMelody2Block() {
  const blockIndex = state.melody2Blocks.length;
  const wrapper = document.createElement('div');
  wrapper.className = 'instrument-wrapper';
  wrapper.style.display = 'flex';
  wrapper.style.alignItems = 'flex-start';
  wrapper.dataset.blockIndex = blockIndex;
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.style.width = '120px';
  instrumentSelect.style.marginRight = '10px';
  instrumentSelect.innerHTML = `
    <option value="piano">Piano</option>
  <option value="sax">Saxofone</option>
  <option value="acordeon">Acordeon</option>
  <option value="strings">Cordas</option>
  <option value="sinos">Sinos</option> <!-- Adicionado -->
  <option value="acoustic-guitar">Violão Aço</option>
  <option value="nylon-guitar">Violão Nylon</option>
  <option value="distorted-guitar-melody">Guitarra Distorcida (Melodia)
  </option>
  `;
  const block = document.createElement('div');
  block.className = 'instrument-block melody2-block';
  block.style.flex = '1';
  block.dataset.blockIndex = blockIndex;
  const grid = createMelodicGrid('melody2', blockIndex, 4);
  // Adiciona marcadores de semínima
  
  block.appendChild(grid);
  wrapper.appendChild(instrumentSelect);
  wrapper.appendChild(block);
  ui.melody2Container.appendChild(wrapper);
  state.melody2Blocks.push(wrapper);
  return wrapper;
}

function addDrumBlock() {
  const blockIndex = state.drumBlocks.length;
  const block = document.createElement('div');
  block.className = 'instrument-block drum-block';
  block.dataset.blockIndex = blockIndex;
  block.style.display = 'flex';
  block.style.alignItems = 'flex-start'; // Alinha ao topo
  // Cria o wrapper principal da bateria (labels + grid)
  const drumWrapper = document.createElement('div');
  drumWrapper.className = 'drum-wrapper';
  drumWrapper.style.position = 'relative';
  // Cria a coluna de rótulos (labels)
  const labelsColumn = document.createElement('div');
  labelsColumn.className = 'drum-labels';
  // Adiciona os rótulos
  DRUM_SAMPLES.forEach(drum => {
    const labelItem = document.createElement('div');
    labelItem.className = 'drum-label-item';
    labelItem.textContent = drum.label;
    labelsColumn.appendChild(labelItem);
  });
  // Cria a grade de colunas (sem os labels internos)
  const grid = document.createElement('div');
  grid.className = 'columns-grid';
  grid.dataset.type = 'drum';
  grid.dataset.blockIndex = blockIndex;
  // Para cada passo (coluna)
  for (let step = 0; step < 4; step++) {
    createDrumColumn(grid, step, blockIndex);
  }
 
  
  // Monta a estrutura
  drumWrapper.appendChild(labelsColumn);
  drumWrapper.appendChild(grid);
  block.appendChild(drumWrapper);
  ui.drumContainer.appendChild(block);
  state.drumBlocks.push(block);
  return block;
}

function createDrumColumn(parentGrid, stepIndex, blockIndex) {
  const column = document.createElement('div');
  column.className = 'column';
  column.dataset.columnIndex = stepIndex;
  column.style.display = 'flex';
  column.style.flexDirection = 'column';

  DRUM_SAMPLES.forEach((drum, drumIndex) => {
    const cell = document.createElement('div');
    cell.className = 'drum-cell';
    cell.dataset.step = stepIndex;
    cell.dataset.instr = drum.key;
    cell.dataset.block = blockIndex;
    cell.style.height = '45px';
    cell.style.fontSize = '0.7em';

    // --- ADICIONA O RÓTULO NUMÉRICO NA PRIMEIRA CÉLULA A CADA 4 COLUNAS ---
    if (drumIndex === 0 && (stepIndex + 1) % 4 === 0 && stepIndex > 0) {
      const label = document.createElement('div');
      label.className = 'column-number-label';
      label.textContent = stepIndex + 1; // Exibe o número da coluna (1-indexed)
      cell.appendChild(label);
    }

    cell.addEventListener('click', function() {
      this.classList.toggle('active');
      loadSample('drum', drum.key, '');
    });

    // >>>>> MODIFICAÇÃO: Botão de delete só na primeira célula (Prato de Ataque) <<<<<
    if (drumIndex === 0) { // Só adiciona o botão na primeira célula (ataque)
      const deleteCellBtn = document.createElement('button');
      deleteCellBtn.className = 'delete-cell-btn';
      deleteCellBtn.textContent = '✖';
      deleteCellBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        if (confirm('Excluir toda a coluna vertical (inclusive bateria, harmonia e melodias)?')) {
          deleteColumn(stepIndex);
        } else {
          // Não precisa fazer nada, pois o botão só existe na célula de ataque
          // e não afeta o estado 'active' das outras.
        }
      });
      cell.appendChild(deleteCellBtn);
    }

    column.appendChild(cell);
  });

  parentGrid.appendChild(column);

  // >>>>> CORREÇÃO: Força o reflow do grid após adicionar a coluna <<<<<
  parentGrid.style.display = 'none';
  parentGrid.offsetHeight; // Trigger reflow
  parentGrid.style.display = 'flex';
}

function createMelodicGrid(type, blockIndex, numColumns) {
  const grid = document.createElement('div');
  grid.className = 'columns-grid';
  grid.dataset.type = type;
  grid.dataset.blockIndex = blockIndex;
  for (let i = 0; i < numColumns; i++) {
    createMelodicColumn(grid, type, i);
  }
  return grid;
}

function createMelodicColumn(parentGrid, type, columnIndex) {
  const column = document.createElement('div');
  column.className = 'column';
  column.dataset.columnIndex = columnIndex;
  const cell = document.createElement('div');
  cell.className = 'cell x';
  cell.textContent = 'X';

  // --- ADICIONA O RÓTULO NUMÉRICO A CADA 4 COLUNAS ---
  if ((columnIndex + 1) % 4 === 0 && columnIndex > 0) {
    const label = document.createElement('div');
    label.className = 'column-number-label';
    label.textContent = columnIndex + 1; // Exibe o número da coluna (1-indexed)
    cell.appendChild(label);
  }

  cell.addEventListener('click', function(e) {
    e.stopPropagation();
    const instrumentKey = this.closest('.instrument-block').parentElement.querySelector('.instrument-select').value;
    openModal('melodic', ALL_NOTES, this, instrumentKey);
  });
  const deleteCellBtn = document.createElement('button');
  deleteCellBtn.className = 'delete-cell-btn';
  deleteCellBtn.textContent = '✖';
  deleteCellBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    if (confirm('Excluir toda a coluna vertical (inclusive bateria, harmonia e melodias)?')) {
      deleteColumn(columnIndex);
    } else {
      cell.textContent = 'X';
      cell.classList.add('x');
      cell.appendChild(deleteCellBtn);
    }
  });
  cell.appendChild(deleteCellBtn);
  column.appendChild(cell);
  parentGrid.appendChild(column);
}



// ===== FUNÇÃO PARA EXCLUIR COLUNA =====
function deleteColumn(columnIndex) {
  // Coleta todos os grids: bateria, harmonia e melodias
  const allGrids = [
    // Todos os containers de harmonia
    ...state.harmonyBlocks[0].map(hb => hb.grid),
    ...state.harmonyBlocks[1].map(hb => hb.grid),
    ...state.harmonyBlocks[2].map(hb => hb.grid),
    // Outros instrumentos
    ...state.bassBlocks.map(b => b.querySelector('.columns-grid')),
    ...state.melody1Blocks.map(m => m.querySelector('.columns-grid')),
    ...state.melody2Blocks.map(m => m.querySelector('.columns-grid')),
    ...state.drumBlocks.map(d => d.querySelector('.columns-grid'))
  ].filter(Boolean); // remove nulos
  
  // Remove a coluna correspondente em todos os grids
  allGrids.forEach(g => {
    const columns = g.querySelectorAll('.column');
    if (columns[columnIndex]) {
      g.removeChild(columns[columnIndex]);
    }
  });
  state.totalSteps -= 1;
updateEditMap();
}

function addCompasso() {
  const newColumnIndex = state.totalSteps;
  
  // Harmonia - para cada um dos 3 containers
  for (let containerIndex = 0; containerIndex < 3; containerIndex++) {
    state.harmonyBlocks[containerIndex].forEach(harmonyBlock => {
      const grid = harmonyBlock.grid;
      if (!grid) return;
      createHarmonyColumn(grid, newColumnIndex, harmonyBlock);
      
    });
  }
  
  // Baixo, Melodia 1, Melodia 2
  [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach(blocks => {
    blocks.forEach(wrapper => {
      const grid = wrapper.querySelector('.columns-grid');
      if (!grid) return;
      const type = grid.dataset.type;
      createMelodicColumn(grid, type, newColumnIndex);
      
    });
  });
  
  // BATERIA
  state.drumBlocks.forEach(block => {
    const grid = block.querySelector('.columns-grid');
    if (!grid) return;
    createDrumColumn(grid, newColumnIndex, block.dataset.blockIndex);
  });
  
  state.totalSteps += 1;
  updateStatus(`Compasso adicionado. Total: ${state.totalSteps} passos.`, 'ready');

  
updateEditMap();

}
function duplicateComposition() {
  if (state.totalSteps === 0) {
    alert('Nenhuma composição para duplicar.');
    return;
  }
  const originalTotalSteps = state.totalSteps;
  // Para cada coluna existente, cria uma cópia
  for (let i = 0; i < originalTotalSteps; i++) {
    const newColumnIndex = state.totalSteps; // Sempre adiciona no final
    // Harmonia 1, 2, 3
    for (let containerIndex = 0; containerIndex < 3; containerIndex++) {
      state.harmonyBlocks[containerIndex].forEach(harmonyBlock => {
        const grid = harmonyBlock.grid;
        if (!grid) return;
        // Encontra a célula original
        const originalColumn = grid.querySelector(`.column:nth-child(${i + 1})`);
        const originalCell = originalColumn.querySelector('.cell');
        const originalText = originalCell.textContent;
        const isX = originalCell.classList.contains('x');
        // Cria nova coluna
        createHarmonyColumn(grid, newColumnIndex, harmonyBlock);
        // Configura a nova célula com o conteúdo da original
        const newColumn = grid.querySelector(`.column:nth-child(${newColumnIndex + 1})`);
        const newCell = newColumn.querySelector('.cell');
        // Remove o botão temporariamente para manipular o texto
        const deleteBtn = newCell.querySelector('.delete-cell-btn');
        if (deleteBtn) newCell.removeChild(deleteBtn);
        newCell.textContent = originalText;
        if (isX) {
          newCell.classList.add('x');
        } else {
          newCell.classList.remove('x');
          // Armazena o valor original (com 'S') no dataset para uso posterior pelo sistema de playback
          newCell.dataset.originalValue = originalText.replace(/#/g, 'S');
        }
        // Adiciona o botão de volta
        if (deleteBtn) newCell.appendChild(deleteBtn);
      });
    }
    // Baixo, Melodia 1, Melodia 2
    [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach(blocks => {
      blocks.forEach(wrapper => {
        const grid = wrapper.querySelector('.columns-grid');
        if (!grid) return;
        const originalColumn = grid.querySelector(`.column:nth-child(${i + 1})`);
        const originalCell = originalColumn.querySelector('.cell');
        const originalText = originalCell.textContent;
        const isX = originalCell.classList.contains('x');
        createMelodicColumn(grid, grid.dataset.type, newColumnIndex);
        const newColumn = grid.querySelector(`.column:nth-child(${newColumnIndex + 1})`);
        const newCell = newColumn.querySelector('.cell');
        const deleteBtn = newCell.querySelector('.delete-cell-btn');
        if (deleteBtn) newCell.removeChild(deleteBtn);
        newCell.textContent = originalText;
        if (isX) {
          newCell.classList.add('x');
        } else {
          newCell.classList.remove('x');
          // Armazena o valor original (com 'S') no dataset
          newCell.dataset.originalValue = originalText.replace(/#/g, 'S');
        }
        if (deleteBtn) newCell.appendChild(deleteBtn);
      });
    });
    // BATERIA (este trecho está correto e pode permanecer)
    state.drumBlocks.forEach(block => {
      const drumWrapper = block.querySelector('.drum-wrapper');
      const grid = drumWrapper ? drumWrapper.querySelector('.columns-grid') : block.querySelector('.columns-grid');
      if (!grid) return;
      const originalColumn = grid.querySelector(`.column:nth-child(${i + 1})`);
      createDrumColumn(grid, newColumnIndex, block.dataset.blockIndex);
      const newColumn = grid.querySelector(`.column:nth-child(${newColumnIndex + 1})`);
      DRUM_SAMPLES.forEach((drum, drumIndex) => {
        const originalCell = originalColumn.querySelector(`.drum-cell[data-instr="${drum.key}"]`);
        const newCell = newColumn.querySelector(`.drum-cell[data-instr="${drum.key}"]`);
        if (originalCell.classList.contains('active')) {
          newCell.classList.add('active');
          // Carregar o sample da bateria aqui é aceitável porque é um evento simples e o sistema de playback da bateria é menos complexo.
          loadSample('drum', drum.key, '');
        } else {
          newCell.classList.remove('active');
        }
      });
    });
    state.totalSteps += 1;
  }
  updateStatus(`Composição duplicada. Total: ${state.totalSteps} passos.`, 'ready');
  updateEditMap();
}
function updateEditMap() {
  const mapContent = document.getElementById('editMapContent');
  mapContent.innerHTML = '';

  if (state.totalSteps === 0) return;

  const totalMeasures = Math.ceil(state.totalSteps / 4);

  for (let measureIndex = 0; measureIndex < totalMeasures; measureIndex++) {
    const item = document.createElement('div');
    item.className = 'edit-map-item';
    item.dataset.measureIndex = measureIndex;

    const numberSpan = document.createElement('span');
    numberSpan.className = 'edit-map-number';
    numberSpan.textContent = measureIndex + 1;

    const cellsContainer = document.createElement('div');
    cellsContainer.className = 'edit-map-cells';

    // Adiciona 4 células representando as 4 semicolcheias do compasso
    for (let i = 0; i < 4; i++) {
      const cellIndex = measureIndex * 4 + i;
      if (cellIndex >= state.totalSteps) break;

      const cellSpan = document.createElement('span');
      cellSpan.className = 'edit-map-cell';

      // Verifica se há conteúdo em pelo menos um instrumento nesta coluna
      let hasContent = false;

      // Verifica Harmonia 1, 2, 3
      for (let containerIndex = 0; containerIndex < 3; containerIndex++) {
        state.harmonyBlocks[containerIndex].forEach(hb => {
          const grid = hb.grid;
          const column = grid.querySelector(`.column:nth-child(${cellIndex + 1})`);
          if (column) {
            const cell = column.querySelector('.cell');
            if (cell && !cell.classList.contains('x')) {
              hasContent = true;
            }
          }
        });
      }

      // Verifica Baixo, Melodia 1, Melodia 2
      [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach(blocks => {
        blocks.forEach(wrapper => {
          const grid = wrapper.querySelector('.columns-grid');
          const column = grid.querySelector(`.column:nth-child(${cellIndex + 1})`);
          if (column) {
            const cell = column.querySelector('.cell');
            if (cell && !cell.classList.contains('x')) {
              hasContent = true;
            }
          }
        });
      });

      // Verifica Bateria
      state.drumBlocks.forEach(block => {
        const drumWrapper = block.querySelector('.drum-wrapper');
        const grid = drumWrapper ? drumWrapper.querySelector('.columns-grid') : block.querySelector('.columns-grid');
        if (grid) {
          const column = grid.querySelector(`.column:nth-child(${cellIndex + 1})`);
          if (column) {
            DRUM_SAMPLES.forEach(drum => {
              const drumCell = column.querySelector(`.drum-cell[data-instr="${drum.key}"]`);
              if (drumCell && drumCell.classList.contains('active')) {
                hasContent = true;
              }
            });
          }
        }
      });

      if (hasContent) {
        cellSpan.classList.add('filled');
      } else {
        cellSpan.classList.add('x');
      }

      cellsContainer.appendChild(cellSpan);
    }

    item.appendChild(numberSpan);
    item.appendChild(cellsContainer);
    mapContent.appendChild(item);

    // Adiciona evento de clique
    item.addEventListener('click', function() {
      const clickedMeasureIndex = parseInt(this.dataset.measureIndex);
      const targetColumnIndex = clickedMeasureIndex * 4;

      // Remove classe 'active' de todos os itens
      document.querySelectorAll('.edit-map-item').forEach(el => el.classList.remove('active'));
      // Adiciona classe 'active' ao item clicado
      this.classList.add('active');

      // Rola todos os grids até a coluna de destino
      const allGrids = [
        ...state.harmonyBlocks[0].map(hb => hb.grid),
        ...state.harmonyBlocks[1].map(hb => hb.grid),
        ...state.harmonyBlocks[2].map(hb => hb.grid),
        ...state.bassBlocks.map(b => b.querySelector('.columns-grid')),
        ...state.melody1Blocks.map(m => m.querySelector('.columns-grid')),
        ...state.melody2Blocks.map(m => m.querySelector('.columns-grid')),
        ...state.drumBlocks.map(d => {
          const dw = d.querySelector('.drum-wrapper');
          return dw ? dw.querySelector('.columns-grid') : d.querySelector('.columns-grid');
        })
      ].filter(Boolean);

      allGrids.forEach(grid => {
        const targetColumn = grid.querySelector(`.column:nth-child(${targetColumnIndex + 1})`);
        if (targetColumn) {
          // Usa scrollIntoView com suavidade
          targetColumn.scrollIntoView({
            behavior: 'smooth',
            block: 'nearest',
            inline: 'start'
          });
        }
      });
    });
  }
}
// ===== FUNÇÃO AUXILIAR: Obtém o valor da nota ou acorde da célula =====
function getCellNoteValue(cellElement) {
  // Usa o valor original armazenado no dataset, se disponível
  if (cellElement.dataset.originalValue) {
    return cellElement.dataset.originalValue;
  }
  // Lê o primeiro nó de texto da célula, ignorando o botão
  for (let node of cellElement.childNodes) {
    if (node.nodeType === Node.TEXT_NODE) {
      return node.textContent.trim();
    }
  }
  return 'X'; // valor padrão de fallback
}

// ===== PLAYBACK =====
function buildPlaybackPlan() {
  const plan = {
    harmony1: [],
    harmony2: [],
    harmony3: [],
    bass: [],
    melody1: [],
    melody2: [],
    drums: {}
  };
  
  // Inicializa os arrays de cada peça de bateria
  DRUM_SAMPLES.forEach(d => plan.drums[d.key] = []);
  
  // --- HARMONIA 1 ---
  state.harmonyBlocks[0].forEach(harmonyBlock => {
    const grid = harmonyBlock.grid;
    const instrument = harmonyBlock.instrumentSelect.value;
    const columns = grid.querySelectorAll('.column');
    columns.forEach(column => {
      const cell = column.querySelector('.cell');
      const chordValue = getCellNoteValue(cell);
      if (chordValue !== 'X') {
        plan.harmony1.push({ chord: chordValue, instrument });
      } else {
        plan.harmony1.push(null);
      }
    });
  });
  
  // --- HARMONIA 2 ---
  state.harmonyBlocks[1].forEach(harmonyBlock => {
    const grid = harmonyBlock.grid;
    const instrument = harmonyBlock.instrumentSelect.value;
    const columns = grid.querySelectorAll('.column');
    columns.forEach(column => {
      const cell = column.querySelector('.cell');
      const chordValue = getCellNoteValue(cell);
      if (chordValue !== 'X') {
        plan.harmony2.push({ chord: chordValue, instrument });
      } else {
        plan.harmony2.push(null);
      }
    });
  });
  
  // --- HARMONIA 3 ---
  state.harmonyBlocks[2].forEach(harmonyBlock => {
    const grid = harmonyBlock.grid;
    const instrument = harmonyBlock.instrumentSelect.value;
    const columns = grid.querySelectorAll('.column');
    columns.forEach(column => {
      const cell = column.querySelector('.cell');
      const chordValue = getCellNoteValue(cell);
      if (chordValue !== 'X') {
        plan.harmony3.push({ chord: chordValue, instrument });
      } else {
        plan.harmony3.push(null);
      }
    });
  });
  
  // Coleta todas as colunas dos instrumentos melódicos (Baixo, Melodia 1, Melodia 2)
  [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach((blocks, idx) => {
    const type = ['bass', 'melody1', 'melody2'][idx];
    blocks.forEach(wrapper => {
      const block = wrapper.querySelector('.instrument-block');
      const grid = block.querySelector('.columns-grid');
      const columns = grid.querySelectorAll('.column');
      // O seletor de instrumento está no wrapper pai
      const instrumentSelect = wrapper.querySelector('.instrument-select');
      const instrument = instrumentSelect ? instrumentSelect.value : 'piano';
      columns.forEach(column => {
        const cell = column.querySelector('.cell');
        const noteValue = getCellNoteValue(cell);
        if (noteValue === 'X') {
          plan[type].push(null);
        } else {
          plan[type].push({ note: noteValue, instrument: instrument });
        }
      });
    });
  });
  
  // Coleta as células da bateria
  state.drumBlocks.forEach(block => {
    // Navega até o .columns-grid dentro do .drum-wrapper, se existir
    const drumWrapper = block.querySelector('.drum-wrapper');
    const grid = drumWrapper ? drumWrapper.querySelector('.columns-grid') : block.querySelector('.columns-grid');
    if (!grid) return;
    const columns = grid.querySelectorAll('.column');
    columns.forEach((column, stepIndex) => {
      DRUM_SAMPLES.forEach(drum => {
        const cell = column.querySelector(`.drum-cell[data-instr="${drum.key}"]`);
        if (cell) {
          plan.drums[drum.key].push(cell.classList.contains('active'));
        }
      });
    });
  });
  
  // Armazena o plano de playback no estado global
  state.playbackPlan = plan;
  state.stepIndex = 0;
  state.lastNoteTime = 0;
  return plan;
}

function scheduleStep(time) {
  const idx = state.stepIndex;
  const plan = state.playbackPlan;
  if (!plan) return;
  
  // HARMONIA 1
  if (idx < plan.harmony1.length && plan.harmony1[idx]) {
    const item = plan.harmony1[idx];
    if (item && item.chord !== 'X') {
      if (state.currentlyPlaying.harmony1 !== null) {
        state.currentlyPlaying.harmony1 = null;
      }
      playChord(item.instrument, item.chord, time, state.harmonicGain, 1.0);
      state.currentlyPlaying.harmony1 = item.chord;
    }
  }
  
  // HARMONIA 2
  if (idx < plan.harmony2.length && plan.harmony2[idx]) {
    const item = plan.harmony2[idx];
    if (item && item.chord !== 'X') {
      if (state.currentlyPlaying.harmony2 !== null) {
        state.currentlyPlaying.harmony2 = null;
      }
      playChord(item.instrument, item.chord, time, state.harmonicGain, 1.0);
      state.currentlyPlaying.harmony2 = item.chord;
    }
  }
  
  // HARMONIA 3
  if (idx < plan.harmony3.length && plan.harmony3[idx]) {
    const item = plan.harmony3[idx];
    if (item && item.chord !== 'X') {
      if (state.currentlyPlaying.harmony3 !== null) {
        state.currentlyPlaying.harmony3 = null;
      }
      playChord(item.instrument, item.chord, time, state.harmonicGain, 1.0);
      state.currentlyPlaying.harmony3 = item.chord;
    }
  }
  
  // BAIXO
  if (idx < plan.bass.length && plan.bass[idx]) {
    const item = plan.bass[idx];
    if (item && item.note) {
      if (state.currentlyPlaying.bass !== null) {
        state.currentlyPlaying.bass = null;
      }
      playNote(item.instrument, item.note, time, state.bassGain, 0.7);
      state.currentlyPlaying.bass = item.note;
    }
  }
  
  // MELODIA 1
  if (idx < plan.melody1.length && plan.melody1[idx]) {
    const item = plan.melody1[idx];
    if (item && item.note) {
      if (state.currentlyPlaying.melody1 !== null) {
        state.currentlyPlaying.melody1 = null;
      }
      playNote(item.instrument, item.note, time, state.melodyGain, 0.6);
      state.currentlyPlaying.melody1 = item.note;
    }
  }
  
  // MELODIA 2
  if (idx < plan.melody2.length && plan.melody2[idx]) {
    const item = plan.melody2[idx];
    if (item && item.note) {
      if (state.currentlyPlaying.melody2 !== null) {
        state.currentlyPlaying.melody2 = null;
      }
      playNote(item.instrument, item.note, time, state.melodyGain, 0.6);
      state.currentlyPlaying.melody2 = item.note;
    }
  }
  
  // BATERIA: NÃO MUTA — PERMITE SOBREPOSIÇÃO NATURAL
  Object.keys(plan.drums).forEach(key => {
    if (idx < plan.drums[key].length && plan.drums[key][idx]) {
      playDrum(key, time, state.drumGain, 1.0); // ↑ Ganho aumentado
    }
  });
  
  state.stepIndex = (state.stepIndex + 1) % state.totalSteps;
}

function playNote(instrumentKey, note, time, gainNode, volume = 1.0) {
  if (!state.audioCtx) return;
  const bufferKey = `melodic-${instrumentKey}-${note}`;
  const buffer = state.buffers.melodic[bufferKey];
  if (!buffer) {
    console.warn(`Sample não encontrado: ${instrumentKey}/${note}`);
    return;
  }
  const source = state.audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(gainNode);
  source.start(time);
  source.stop(time + 0.5); // Semicolcheia = 0.5s
}

function playChord(instrumentKey, chord, time, gainNode, volume = 1.0) {
  if (!state.audioCtx) return;
  if (chord === 'X') return;
  let root;
  if (chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(chord.slice(0, 2))) {
    root = chord.slice(0, 2);
  } else {
    root = chord[0];
  }
  // CORREÇÃO FINAL: Monta o caminho exato do arquivo e usa como chave
  const filePath = HARMONIC_INSTRUMENTS[instrumentKey] + root + '/' + chord + '.mp3';
  const buffer = state.buffers.harmonic[filePath]; // ← BUSCA PELO CAMINHO COMPLETO
  if (!buffer) {
    console.warn(`Acorde não encontrado: ${filePath}`);
    return;
  }
  const source = state.audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(gainNode);
  source.start(time);
  source.stop(time + 1.0); // Semínima = 1.0s
}

function playDrum(drumKey, time, gainNode, volume = 1.0) {
  if (!state.audioCtx) return;
  const buffer = state.buffers.drums[drumKey];
  if (!buffer) {
    console.warn(`Sample de bateria não encontrado: ${drumKey}`);
    return;
  }
  const source = state.audioCtx.createBufferSource();
  source.buffer = buffer;
  const gain = state.audioCtx.createGain();
  gain.gain.setValueAtTime(volume, time);
  source.connect(gain);
  gain.connect(gainNode);
  source.start(time);
  // ❌ não corta em 0.2s, deixa o sample tocar até o fim
}

function startScheduler() {
  state.isPlaying = true;
  ui.btnPlay.textContent = '⏸ Pause';
  ui.btnStop.disabled = false;
  function tick() {
    if (!state.isPlaying) return;
    const now = state.audioCtx.currentTime;
    const stepDuration = 60 / state.bpm / 4; // semicolcheia
    const nextStep = state.lastNoteTime + stepDuration;
    if (now >= nextStep) {
      scheduleStep(nextStep);
      state.lastNoteTime = nextStep;
      updatePlaybackProgress(); // Atualiza o progresso visual
    }
    requestAnimationFrame(tick);
  }
  state.lastNoteTime = state.audioCtx.currentTime;
  tick();
}

// ===== FUNÇÃO PARA ATUALIZAR PROGRESSO VISUAL =====
function updatePlaybackProgress() {
  // Limpa destaque anterior
  document.querySelectorAll('.cell, .drum-cell').forEach(cell => {
    cell.style.boxShadow = 'none';
  });
  // Destaca a célula atual
  const currentStep = state.stepIndex;
  document.querySelectorAll(`.column:nth-child(${currentStep + 1}) .cell`).forEach(cell => {
    cell.style.boxShadow = '0 0 5px 2px #5eead4';
  });
  document.querySelectorAll(`.column:nth-child(${currentStep + 1}) .drum-cell`).forEach(cell => {
    cell.style.boxShadow = '0 0 5px 2px #5eead4';
  });
}

// ===== PLAY COM CONTAGEM REGRESSIVA DE 4 COMPASSOS =====
function onPlay() {
  if (!state.audioCtx) {
    updateStatus('Erro: Audio Context não inicializado', 'error');
    return;
  }
  if (state.isPlaying) {
    state.isPlaying = false;
    ui.btnPlay.textContent = '▶ Play';
    ui.btnStop.disabled = true;
    return;
  }
  try {
    if (state.audioCtx.state === 'suspended') {
      state.audioCtx.resume();
    }
    buildPlaybackPlan();
    const samplesToLoad = new Set();
    
    // Harmonia 1
    state.playbackPlan.harmony1.forEach(item => {
      if (item && item.chord !== 'X') {
        let root;
        if (item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))) {
          root = item.chord.slice(0, 2);
        } else {
          root = item.chord[0];
        }
        const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
        samplesToLoad.add(filePath);
      }
    });
    
    // Harmonia 2
    state.playbackPlan.harmony2.forEach(item => {
      if (item && item.chord !== 'X') {
        let root;
        if (item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))) {
          root = item.chord.slice(0, 2);
        } else {
          root = item.chord[0];
        }
        const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
        samplesToLoad.add(filePath);
      }
    });
    
    // Harmonia 3
    state.playbackPlan.harmony3.forEach(item => {
      if (item && item.chord !== 'X') {
        let root;
        if (item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))) {
          root = item.chord.slice(0, 2);
        } else {
          root = item.chord[0];
        }
        const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
        samplesToLoad.add(filePath);
      }
    });
    
    // Melódicas
    ['bass', 'melody1', 'melody2'].forEach(type => {
      state.playbackPlan[type].forEach(item => {
        if (item && item.note) {
          const bufferKey = `melodic-${item.instrument}-${item.note}`;
          samplesToLoad.add(bufferKey);
        }
      });
    });
    
    // Bateria — usa o key direto (ex: 'ataque'), sem prefixo
    Object.keys(state.playbackPlan.drums).forEach(key => {
      if (state.playbackPlan.drums[key].some(active => active)) {
        samplesToLoad.add(key);
      }
    });
    
    updateStatus('Carregando amostras... Por favor, aguarde.', 'loading');
    ui.btnSaveWAV.disabled = true;
    ui.countdown.style.display = 'block';
    const promises = Array.from(samplesToLoad).map(bufferKey => {
      if (bufferKey.includes('melodic-')) {
        const parts = bufferKey.split('-');
        const instrumentKey = parts[1];
        const noteOrChord = parts.slice(2).join('-');
        return loadSample('melodic', instrumentKey, noteOrChord);
      } else if (bufferKey.includes('guitarra') || bufferKey.includes('PianoStringChord')) {
        let instrumentKey = '';
        let chord = '';
        if (bufferKey.startsWith('guitarraDistorcao/')) {
          instrumentKey = 'distorted-guitar';
          chord = bufferKey.replace('guitarraDistorcao/', '').replace('.mp3', '').split('/').pop();
        } else if (bufferKey.startsWith('guitarraLimpa/')) {
          instrumentKey = 'clean-guitar';
          chord = bufferKey.replace('guitarraLimpa/', '').replace('.mp3', '').split('/').pop();
        } else if (bufferKey.startsWith('assets/PianoStringChord/')) {
          instrumentKey = 'piano-chord';
          chord = bufferKey.replace('assets/PianoStringChord/', '').replace('.mp3', '').split('/').pop();
        }
        if (instrumentKey && chord) {
          return loadSample('harmonic', instrumentKey, chord);
        } else {
          console.warn('Caminho de acorde inválido:', bufferKey);
          return Promise.resolve();
        }
      } else {
        return loadSample('drum', bufferKey, '');
      }
    });
    
     Promise.all(promises).then(() => {
      // >>>>> ADICIONE ESTA LINHA ABAIXO <<<<<
      ui.btnSaveWAV.disabled = false;
      startCountdown();
    }).catch(err => {
      console.error('Erro ao carregar amostras:', err);
      updateStatus('Erro ao carregar amostras. Verifique a conexão.', 'error');
    });
  } catch (error) {
    console.error('Erro ao iniciar reprodução:', error);
    updateStatus('Erro ao iniciar: ' + error.message, 'error');
  }
}

function startCountdown() {
  state.countdownActive = true;
  state.countdownValue = 4;
  ui.countdown.textContent = state.countdownValue;
  const sixteenthDur = 60 / state.bpm / 4;
  const beatDuration = sixteenthDur * 4;
  const interval = setInterval(() => {
    state.countdownValue--;
    ui.countdown.textContent = state.countdownValue;
    if (state.countdownValue <= 0) {
      clearInterval(interval);
      ui.countdown.style.display = 'none';
      state.countdownActive = false;
      startScheduler();
      updateStatus('Reproduzindo...', 'ready');
    }
  }, beatDuration * 1000);
}

function onStop() {
  state.isPlaying = false;
  state.stepIndex = 0;
  ui.btnPlay.textContent = '▶ Play';
  ui.countdown.style.display = 'none';
  ui.btnStop.disabled = true;
  updateStatus('Reprodução parada', 'ready');
}

// ===== GRAVAÇÃO WAV COM BARRA DE PROGRESSO =====
async function renderAndDownloadWAV() {
  if (!state.playbackPlan) {
    alert('Crie alguma música primeiro.');
    return;
  }
  updateStatus('Renderizando áudio...', 'loading');
  ui.btnSaveWAV.disabled = true;
  ui.btnSaveWAV.textContent = '⏳ Renderizando...';
  ui.progressContainer.style.display = 'block';
  try {
    const sampleRate = 44100;
    const sixteenthDur = 60 / state.bpm / 4;
    // --- CÁLCULO CORRIGIDO DA DURAÇÃO ---
    // O último evento significativo termina 1 segundo após o último passo (duração do acorde).
    const lastEventTime = (state.totalSteps - 1) * sixteenthDur + 1.0;
    // Adiciona 2 segundos de margem de segurança total.
    const safeDuration = lastEventTime + 2.0;
    const totalSamples = Math.ceil(safeDuration * sampleRate);
    // --- FIM DO CÁLCULO CORRIGIDO ---
    const offlineCtx = new OfflineAudioContext(2, totalSamples, sampleRate);
    const master = offlineCtx.createGain();
    const drumGain = offlineCtx.createGain();
    const bassGain = offlineCtx.createGain();
    const melodyGain = offlineCtx.createGain();
    const harmonicGain = offlineCtx.createGain();
    master.connect(offlineCtx.destination);
    drumGain.connect(master);
    bassGain.connect(master);
    melodyGain.connect(master);
    harmonicGain.connect(master);
    master.gain.value = 0.8;
    drumGain.gain.value = 1.0;
    bassGain.gain.value = 0.5;
    melodyGain.gain.value = 0.5;
    harmonicGain.gain.value = 0.5;
    const totalSteps = state.totalSteps;
    // Função para atualizar a barra de progresso
    const updateProgress = (currentStep) => {
      const percent = Math.round((currentStep / totalSteps) * 100);
      ui.progressBar.style.width = `${percent}%`;
      ui.progressText.textContent = `${percent}%`;
    };
    for (let step = 0; step < totalSteps; step++) {
      const time = step * sixteenthDur;
      if (step % 10 === 0) {
        updateProgress(step);
      }
      
      // Harmonia 1 (dura 1.0s)
      if (step < state.playbackPlan.harmony1.length && state.playbackPlan.harmony1[step]) {
        const item = state.playbackPlan.harmony1[step];
        if (item && item.chord !== 'X') {
          let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))
            ? item.chord.slice(0, 2)
            : item.chord[0];
          const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
          const buffer = state.buffers.harmonic[filePath];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(harmonicGain);
            source.start(time);
            source.stop(time + 1.0); // Para no final da semínima
          }
        }
      }
      
      // Harmonia 2 (dura 1.0s)
      if (step < state.playbackPlan.harmony2.length && state.playbackPlan.harmony2[step]) {
        const item = state.playbackPlan.harmony2[step];
        if (item && item.chord !== 'X') {
          let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))
            ? item.chord.slice(0, 2)
            : item.chord[0];
          const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
          const buffer = state.buffers.harmonic[filePath];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(harmonicGain);
            source.start(time);
            source.stop(time + 1.0); // Para no final da semínima
          }
        }
      }
      
      // Harmonia 3 (dura 1.0s)
      if (step < state.playbackPlan.harmony3.length && state.playbackPlan.harmony3[step]) {
        const item = state.playbackPlan.harmony3[step];
        if (item && item.chord !== 'X') {
          let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))
            ? item.chord.slice(0, 2)
            : item.chord[0];
          const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
          const buffer = state.buffers.harmonic[filePath];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(harmonicGain);
            source.start(time);
            source.stop(time + 1.0); // Para no final da semínima
          }
        }
      }
      
      // Baixo (dura 0.5s)
      if (step < state.playbackPlan.bass.length && state.playbackPlan.bass[step]) {
        const item = state.playbackPlan.bass[step];
        if (item && item.note) {
          const bufferKey = `melodic-${item.instrument}-${item.note}`;
          const buffer = state.buffers.melodic[bufferKey];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(bassGain);
            source.start(time);
            source.stop(time + 0.5); // Para no final da semicolcheia
          }
        }
      }
      
      // Melodia 1 & 2 (duram 0.5s)
      [[state.playbackPlan.melody1, melodyGain], [state.playbackPlan.melody2, melodyGain]].forEach(([melody, gain]) => {
        if (step < melody.length && melody[step]) {
          const item = melody[step];
          if (item && item.note) {
            const bufferKey = `melodic-${item.instrument}-${item.note}`;
            const buffer = state.buffers.melodic[bufferKey];
            if (buffer) {
              const source = offlineCtx.createBufferSource();
              source.buffer = buffer;
              source.connect(gain);
              source.start(time);
              source.stop(time + 0.5);
            }
          }
        }
      });
      
      // Bateria (não para, deixa tocar até o fim)
      Object.keys(state.playbackPlan.drums).forEach(key => {
        if (step < state.playbackPlan.drums[key].length && state.playbackPlan.drums[key][step]) {
          const buffer = state.buffers.drums[key];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(drumGain);
            source.start(time);
            // Não chamamos source.stop() para permitir o sample tocar naturalmente.
          }
        }
      });
    }
    updateProgress(totalSteps);
    const renderedBuffer = await offlineCtx.startRendering();
    const wavBlob = audioBufferToWav(renderedBuffer);
    const fileName = `jam-on-${new Date().toISOString().slice(0,10)}-${Math.floor(Math.random()*1000)}.wav`;
    downloadBlob(wavBlob, fileName);
    updateStatus('Renderização concluída!', 'ready');
  } catch (error) {
    console.error('Erro ao renderizar WAV:', error);
    updateStatus('Erro ao renderizar: ' + error.message, 'error');
  } finally {
    ui.btnSaveWAV.textContent = '💾 Salvar como WAV';
    ui.btnSaveWAV.disabled = false;
    ui.progressContainer.style.display = 'none';
  }
}

function audioBufferToWav(buffer) {
  const numOfChan = buffer.numberOfChannels;
  const length = buffer.length * numOfChan * 2 + 44;
  const arrayBuffer = new ArrayBuffer(length);
  const view = new DataView(arrayBuffer);
  const channels = [];
  let i, sample, offset = 0;
  function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }
  writeString(view, 0, 'RIFF');
  view.setUint32(4, length - 8, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numOfChan, true);
  view.setUint32(24, 44100, true);
  view.setUint32(28, 44100 * 2 * numOfChan, true);
  view.setUint16(32, 2 * numOfChan, true);
  view.setUint16(34, 16, true);
  writeString(view, 36, 'data');
  view.setUint32(40, length - 44, true);
  for (i = 0; i < buffer.numberOfChannels; i++) {
    channels.push(buffer.getChannelData(i));
  }
  offset = 44;
  for (i = 0; i < buffer.length; i++) {
    for (let channel = 0; channel < numOfChan; channel++) {
      sample = Math.max(-1, Math.min(1, channels[channel][i]));
      sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF);
      view.setInt16(offset, sample, true);
      offset += 2;
    }
  }
  return new Blob([view], { type: 'audio/wav' });
}

function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.style.display = 'none';
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 100);
}

// ===== INICIALIZAR =====
window.addEventListener('load', initializeApp);
</script>
<!-- MAPA DE EDIÇÃO -->
<div id="editMapContainer" class="edit-map-container">
  <div class="edit-map-title">Mapa de Edição</div>
  <div id="editMapContent">
    <!-- Os itens serão gerados dinamicamente aqui -->
  </div>
</div>
</body>
</html>
