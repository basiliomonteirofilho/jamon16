<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jam On ‚Äì Composi√ß√£o Manual</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      background: #121212;
      color: #e0e0e0;
      margin: 0;
      padding: 20px;
    }
    header {
      text-align: center;
      margin-bottom: 20px;
    }
    h1 {
      color: #5eead4;
      font-size: 1.8em;
      margin: 0;
    }
    .pill {
      display: inline-block;
      background: #333;
      color: #aaa;
      font-size: 0.75em;
      padding: 4px 10px;
      border-radius: 12px;
    }
    .card {
      max-width: 1200px;
      margin: 0 auto;
      background: #1e1e1e;
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      overflow: hidden;
      padding: 20px;
      text-align: left;
    }
    .section {
      margin: 25px 0;
      padding: 15px;
      border: 1px solid #333;
      border-radius: 10px;
      background: #222;
    }
    .section h3 {
      color: #5eead4;
      margin-top: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .add-btn {
      background: #4CAF50;
      color: white;
      font-size: 1.2em;
      padding: 6px 10px;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    .horizontal-container {
      display: flex;
      overflow-x: auto;
      padding: 10px 0;
      gap: 15px;
      margin: 15px 0;
      min-height: 200px;
    }
    .instrument-block {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      min-width: 220px;
      border-left: 4px solid #5eead4;
    }
    .bass-block { border-left-color: #ffcc00; }
    .melody1-block { border-left-color: #ff6b6b; }
    .melody2-block { border-left-color: #4ecdc4; }
    .drum-block { border-left-color: #8e44ad; }
    .harmony-block { border-left-color: #9b59b6; }
    .block-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .note-grid {
      display: flex;
      gap: 2px;
      margin: 10px 0;
    }
    .cell {
      width: 45px;
      height: 45px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7em;
      cursor: pointer;
      color: #ccc;
      user-select: none;
      transition: background 0.2s;
    }
    .cell:hover {
      background: #444;
    }
    .cell.x {
      background: #555;
      color: #888;
      font-weight: bold;
    }
    .drum-grid-horizontal {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin: 10px 0;
    }
    .drum-row-horizontal {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .drum-label-horizontal {
      width: 120px;
      padding: 5px;
      background: #2a2a2a;
      border: 1px solid #444;
      text-align: right;
      font-size: 0.8em;
      color: #ccc;
      border-radius: 4px;
    }
    .drum-cell-horizontal {
      width: 45px;
      height: 45px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7em;
      cursor: pointer;
      color: #ccc;
      transition: background 0.2s;
    }
    .drum-cell-horizontal.active {
      background: #5eead4;
      color: #121212;
    }
    .drum-cell-horizontal:hover {
      background: #444;
    }
    .instrument-select, .chord-select {
      margin: 10px 0;
      padding: 8px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      color: white;
      width: 100%;
    }
    .bpm-control {
      text-align: center;
      margin: 15px 0;
    }
    .bpm-display {
      font-size: 1.5em;
      font-weight: bold;
      color: #5eead4;
      margin: 10px 0;
    }
    .bpm-slider {
      width: 80%;
      margin: 10px auto;
    }
    .btn-row {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
    }
    button {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      font-size: 1em;
      transition: opacity 0.2s;
    }
    button.primary {
      background: #5eead4;
      color: #121212;
    }
    button.danger {
      background: #f44336;
      color: white;
    }
    button:hover:not(:disabled) {
      opacity: 0.9;
    }
    .loading {
      text-align: center;
      padding: 20px;
      color: #5eead4;
    }
    .status-indicator {
      text-align: center;
      padding: 10px;
      margin: 10px 0;
      border-radius: 6px;
    }
    .status-ready {
      background: #2a4d2a;
      color: #8eff8e;
    }
    .status-loading {
      background: #4d462a;
      color: #ffe08e;
    }
    .status-error {
      background: #4d2a2a;
      color: #ff8e8e;
    }
    .instructions {
      font-size: 0.85em;
      color: #aaa;
      margin-top: 8px;
      text-align: center;
    }
    @media (max-width: 768px) {
      .cell, .drum-cell-horizontal { 
        width: 35px;
        height: 35px;
        font-size: 0.6em;
      }
      .drum-label-horizontal { 
        width: 80px;
        font-size: 0.7em; 
        padding: 4px;
      }
      button { padding: 10px 15px; }
      .add-btn { width: 25px; height: 25px; font-size: 1em; }
      .instrument-block { min-width: 160px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Jam On ‚Äì Composi√ß√£o Manual</h1>
    <div class="pill">Cada c√©lula = semicolcheia (1/4 da sem√≠nima)</div>
  </header>
  <div class="card">
    <div id="statusIndicator" class="status-indicator status-loading">
      Inicializando aplica√ß√£o...
    </div>

    <div class="section">
      <h3>üéõÔ∏è Controle de BPM</h3>
      <div class="bpm-control">
        <div class="bpm-display" id="bpmDisplay">100 BPM</div>
        <input type="range" id="bpmSlider" class="bpm-slider" min="60" max="180" value="100" step="1">
      </div>
    </div>

    <div class="section">
      <h3>üé∏ Harmonia <span class="add-btn" id="addHarmonyBlock">+</span></h3>
      <div id="harmonyContainer" class="horizontal-container"></div>
    </div>

    <div class="section">
      <h3>üé∏ Baixo <span class="add-btn" id="addBassBlock">+</span></h3>
      <div id="bassContainer" class="horizontal-container"></div>
    </div>

    <div class="section">
      <h3>üéπ Melodia 1 <span class="add-btn" id="addMelody1Block">+</span></h3>
      <div id="melody1Container" class="horizontal-container"></div>
    </div>

    <div class="section">
      <h3>üé∑ Melodia 2 <span class="add-btn" id="addMelody2Block">+</span></h3>
      <div id="melody2Container" class="horizontal-container"></div>
    </div>

    <div class="section">
      <h3>ü•Å Bateria <span class="add-btn" id="addDrumBlock">+</span></h3>
      <div id="drumContainer" class="horizontal-container"></div>
    </div>

    <div class="btn-row">
      <button id="btnPlay" class="primary">‚ñ∂ Play</button>
      <button id="btnStop" class="danger">‚èπ Stop</button>
      <button id="btnSaveWAV" class="primary">üíæ Salvar como WAV</button>
    </div>
    <div class="instructions">
      Clique em uma c√©lula para escolher uma nota. Clique √† esquerda do centro para diminuir, √† direita para aumentar.<br>
      Duplo clique para pausa (X). Use "+" para adicionar blocos.
    </div>
  </div>

  <script>
    // ===== CONSTANTES =====
    const AVAILABLE_CHORDS = [
      'A', 'A11', 'A13', 'A4', 'A45+', 'A5', 'A5+', 'A6', 'A7', 'A75+', 'A9', 'A95+', 'Adim', 
      'Am', 'Am4', 'Am5', 'Am5+', 'Am6', 'Am7', 'Am75+', 'Am79', 'Am9',
      'AS', 'AS11', 'AS13', 'AS4', 'AS45+', 'AS5', 'AS5+', 'AS6', 'AS7', 'AS75+', 'AS9', 'AS95+',
      'ASdim', 'ASm', 'ASm4', 'ASm5', 'ASm5+', 'ASm6', 'ASm7', 'ASm75+', 'ASm79', 'ASm9',
      'B', 'B11', 'B13', 'B4', 'B45+', 'B5', 'B5+', 'B6', 'B7', 'B75+', 'B9', 'B95+', 'Bdim',
      'Bm', 'Bm4', 'Bm5', 'Bm5+', 'Bm6', 'Bm7', 'Bm75+', 'Bm79', 'Bm9',
      'C', 'C11', 'C13', 'C4', 'C45+', 'C5', 'C5+', 'C6', 'C7', 'C75+', 'C9', 'C95+', 'Cdim',
      'Cm', 'Cm4', 'Cm5', 'Cm5+', 'Cm6', 'Cm7', 'Cm75+', 'Cm79', 'Cm9',
      'CS', 'CS11', 'CS13', 'CS4', 'CS45+', 'CS5', 'CS5+', 'CS6', 'CS7', 'CS75+', 'CS9', 'CS95+',
      'CSdim', 'CSm', 'CSm4', 'CSm5', 'CSm5+', 'CSm6', 'CSm7', 'CSm75+', 'CSm79', 'CSm9',
      'D', 'D11', 'D13', 'D4', 'D45+', 'D5', 'D5+', 'D6', 'D7', 'D75+', 'D9', 'D95+', 'Ddim',
      'Dm', 'Dm4', 'Dm5', 'Dm5+', 'Dm6', 'Dm7', 'Dm75+', 'Dm79', 'Dm9',
      'E', 'E11', 'E13', 'E4', 'E45+', 'E5', 'E5+', 'E6', 'E7', 'E75+', 'E9', 'E95+', 'Edim',
      'Em', 'Em4', 'Em5', 'Em5+', 'Em6', 'Em7', 'Em75+', 'Em79', 'Em9',
      'DS', 'DS11', 'DS13', 'DS4', 'DS45+', 'DS5', 'DS5+', 'DS6', 'DS7', 'DS75+', 'DS9', 'DS95+',
      'DSdim', 'DSm', 'DSm4', 'DSm5', 'DSm5+', 'DSm6', 'DSm7', 'DSm75+', 'DSm79', 'DSm9',
      'F', 'F11', 'F13', 'F4', 'F45+', 'F5', 'F5+', 'F6', 'F7', 'F75+', 'F9', 'F95+', 'Fdim',
      'Fm', 'Fm4', 'Fm5', 'Fm5+', 'Fm6', 'Fm7', 'Fm75+', 'Fm79', 'Fm9',
      'FS', 'FS11', 'FS13', 'FS4', 'FS45+', 'FS5', 'FS5+', 'FS6', 'FS7', 'FS75+', 'FS9', 'FS95+',
      'FSdim', 'FSm', 'FSm4', 'FSm5', 'FSm5+', 'FSm6', 'FSm7', 'FSm75+', 'FSm79', 'FSm9',
      'G', 'G11', 'G13', 'G4', 'G45+', 'G5', 'G5+', 'G6', 'G7', 'G75+', 'G9', 'G95+', 'Gdim',
      'Gm', 'Gm4', 'Gm5', 'Gm5+', 'Gm6', 'Gm7', 'Gm75+', 'Gm79', 'Gm9',
      'GS', 'GS11', 'GS13', 'GS4', 'GS45+', 'GS5', 'GS5+', 'GS6', 'GS7', 'GS75+', 'GS9', 'GS95+',
      'GSdim', 'GSm', 'GSm4', 'GSm5', 'GSm5+', 'GSm6', 'GSm7', 'GSm75+', 'GSm79', 'GSm9'
    ];

    const NOTE_NAMES = [
      '10CS.mp3', '11D.mp3', '12DS.mp3', '13E.mp3', '14F.mp3', '15FS.mp3', '16G.mp3', '17GS.mp3', 
      '18A.mp3', '19AS.mp3', '1E.mp3', '20B.mp3', '21C.mp3', '22CS.mp3', '23D.mp3', '24DS.mp3', 
      '25E.mp3', '26F.mp3', '27FS.mp3', '28G.mp3', '29GS.mp3', '2F.mp3', '30A.mp3', '31AS.mp3', 
      '32B.mp3', '33C.mp3', '34CS.mp3', '35D.mp3', '36DS.mp3', '37E.mp3', '38F.mp3', '39FS.mp3', 
      '3FS.mp3', '40G.mp3', '41GS.mp3', '42A.mp3', '43AS.mp3', '44B.mp3', '45C.mp3', '46CS.mp3', 
      '47D.mp3', '48DS.mp3', '49E.mp3', '4G.mp3', '5GS.mp3', '6A.mp3', '7AS.mp3', '8B.mp3', '9C.mp3'
    ];

    const NOTE_IDS = NOTE_NAMES.map(name => name.replace('.mp3', ''));
    
    const NUM_TO_NOTE = {};
    const NOTE_TO_NUM = {};
    const NOTE_FREQ = {
      'C': 261.63, 'CS': 277.18, 'D': 293.66, 'DS': 311.13, 'E': 329.63, 'F': 349.23,
      'FS': 369.99, 'G': 392.00, 'GS': 415.30, 'A': 440.00, 'AS': 466.16, 'B': 493.88
    };

    NOTE_IDS.forEach(note => {
      const match = note.match(/^(\d+)([A-Z]+)$/);
      if (match) {
        const num = parseInt(match[1]);
        const noteName = match[2];
        NUM_TO_NOTE[num] = noteName;
        NOTE_TO_NUM[note] = num;
      }
    });

    const ALL_NOTES = Object.keys(NUM_TO_NOTE).map(n => parseInt(n)).sort((a, b) => a - b);
    const MIN_NOTE = Math.min(...ALL_NOTES);
    const MAX_NOTE = Math.max(...ALL_NOTES);

    const DRUM_SAMPLES = [
      { key: 'caixa', label: 'Caixa' },
      { key: 'bumbo', label: 'Bumbo' },
      { key: 'chimbal', label: 'Chimbal Fechado' },
      { key: 'chimbal-aberto', label: 'Chimbal Aberto' },
      { key: 'prato-ataque', label: 'Prato de Ataque' },
      { key: 'surdo', label: 'Surdo' },
      { key: 'tom-1', label: 'Tom 1' },
      { key: 'tom-2', label: 'Tom 2' }
    ];

    const MELODIC_INSTRUMENTS = {
      'acordeon': 'assets/AcordeonMelodia',
      'bass': 'assets/BaixoMelodia',
      'strings': 'assets/Cordas',
      'piano': 'assets/PianoString',
      'sax': 'assets/SaxMelodia',
      'acoustic-guitar': 'assets/ViolaoAcoMelodia',
      'nylon-guitar': 'assets/ViolaoNylonMelodia'
    };

    const HARMONIC_INSTRUMENTS = {
      'distorted-guitar': 'guitarraDistorcao',
      'clean-guitar': 'guitarraLimpa',
      'piano-chord': 'assets/PianoStringChord'
    };

    // ===== ESTADO =====
    const state = {
      running: false,
      paused: false,
      bpm: 100,
      stepIndex: 0,
      totalSteps: 4,
      buffers: {},
      activeInput: null,
      schedulerTimer: null,
      harmonyBlocks: [],
      bassBlocks: [],
      melody1Blocks: [],
      melody2Blocks: [],
      drumBlocks: [],
      lastNoteTime: 0,
      recordedChunks: [],
      audioCtx: null,
      isLoaded: false,
      isPlaying: false,
      offlineCtx: null
    };

    // ===== ELEMENTOS =====
    const ui = {
      statusIndicator: document.getElementById('statusIndicator'),
      bpmSlider: document.getElementById('bpmSlider'),
      bpmDisplay: document.getElementById('bpmDisplay'),
      btnPlay: document.getElementById('btnPlay'),
      btnStop: document.getElementById('btnStop'),
      btnSaveWAV: document.getElementById('btnSaveWAV'),
      addHarmonyBlock: document.getElementById('addHarmonyBlock'),
      addBassBlock: document.getElementById('addBassBlock'),
      addMelody1Block: document.getElementById('addMelody1Block'),
      addMelody2Block: document.getElementById('addMelody2Block'),
      addDrumBlock: document.getElementById('addDrumBlock'),
      harmonyContainer: document.getElementById('harmonyContainer'),
      bassContainer: document.getElementById('bassContainer'),
      melody1Container: document.getElementById('melody1Container'),
      melody2Container: document.getElementById('melody2Container'),
      drumContainer: document.getElementById('drumContainer')
    };

    // ===== INICIALIZA√á√ÉO =====
    async function initializeApp() {
      updateStatus('Carregando recursos de √°udio...', 'loading');
      try {
        state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        state.masterGain = state.audioCtx.createGain();
        state.drumGain = state.audioCtx.createGain();
        state.bassGain = state.audioCtx.createGain();
        state.melodyGain = state.audioCtx.createGain();
        state.harmonicGain = state.audioCtx.createGain();

        state.masterGain.connect(state.audioCtx.destination);
        state.drumGain.connect(state.masterGain);
        state.bassGain.connect(state.masterGain);
        state.melodyGain.connect(state.masterGain);
        state.harmonicGain.connect(state.masterGain);

        state.masterGain.gain.value = 0.8;
        state.drumGain.gain.value = 0.6;
        state.bassGain.gain.value = 0.5;
        state.melodyGain.gain.value = 0.5;
        state.harmonicGain.gain.value = 0.5;

        state.buffers = {
          drums: {},
          melodic: {},
          harmonic: {}
        };

        updateStatus('Preparando instrumentos...', 'loading');

        // Adiciona 4 blocos iniciais
        for (let i = 0; i < 4; i++) {
          addHarmonyBlock();
          addBassBlock();
          addMelody1Block();
          addMelody2Block();
          addDrumBlock();
        }

        setupEventListeners();
        updateStatus('Aplica√ß√£o pronta para uso!', 'ready');
        state.isLoaded = true;
        ui.btnPlay.disabled = false;
      } catch (error) {
        console.error('Erro ao inicializar:', error);
        updateStatus('Erro ao inicializar: ' + error.message, 'error');
      }
    }

    function setupEventListeners() {
      updateBPMDisplay();
      ui.bpmSlider.addEventListener('input', handleBPMChange);

      ui.addHarmonyBlock.addEventListener('click', addHarmonyBlock);
      ui.addBassBlock.addEventListener('click', addBassBlock);
      ui.addMelody1Block.addEventListener('click', addMelody1Block);
      ui.addMelody2Block.addEventListener('click', addMelody2Block);
      ui.addDrumBlock.addEventListener('click', addDrumBlock);

      ui.btnPlay.addEventListener('click', onPlay);
      ui.btnStop.addEventListener('click', onStop);
      ui.btnSaveWAV.addEventListener('click', () => renderAndDownloadWAV(16));
    }

    function handleBPMChange() {
      state.bpm = parseInt(ui.bpmSlider.value);
      updateBPMDisplay();
    }

    function updateBPMDisplay() {
      ui.bpmDisplay.textContent = `${state.bpm} BPM`;
    }

    function updateStatus(message, type) {
      ui.statusIndicator.textContent = message;
      ui.statusIndicator.className = 'status-indicator status-' + type;
    }

    // ===== BLOCOS DE INSTRUMENTOS =====
    function addHarmonyBlock() {
      const blockIndex = state.harmonyBlocks.length;
      const block = document.createElement('div');
      block.className = 'instrument-block harmony-block';
      block.dataset.blockIndex = blockIndex;

      const title = document.createElement('div');
      title.textContent = `Bloco ${blockIndex + 1}`;
      title.style.fontWeight = 'bold';
      title.style.color = '#9b59b6';
      title.style.marginBottom = '10px';
      block.appendChild(title);

      const instrumentSelect = document.createElement('select');
      instrumentSelect.className = 'instrument-select';
      instrumentSelect.innerHTML = `
        <option value="distorted-guitar">Guitarra Distorcida</option>
        <option value="clean-guitar">Guitarra Limpa</option>
        <option value="piano-chord">Piano</option>
      `;
      block.appendChild(instrumentSelect);

      const grid = document.createElement('div');
      grid.className = 'note-grid';
      grid.dataset.type = 'harmony';
      grid.dataset.blockIndex = blockIndex;

      for (let i = 0; i < 4; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.step = i;
        cell.textContent = 'C'; // Default chord
        cell.addEventListener('click', function(e) {
          const currentIndex = AVAILABLE_CHORDS.indexOf(this.textContent);
          const nextIndex = (currentIndex + 1) % AVAILABLE_CHORDS.length;
          this.textContent = AVAILABLE_CHORDS[nextIndex];
        });
        grid.appendChild(cell);
      }
      block.appendChild(grid);
      ui.harmonyContainer.appendChild(block);
      state.harmonyBlocks.push(block);
      return block;
    }

    function addBassBlock() {
      const blockIndex = state.bassBlocks.length;
      const block = document.createElement('div');
      block.className = 'instrument-block bass-block';
      block.dataset.blockIndex = blockIndex;

      const title = document.createElement('div');
      title.textContent = `Bloco ${blockIndex + 1}`;
      title.style.fontWeight = 'bold';
      title.style.color = '#ffcc00';
      title.style.marginBottom = '10px';
      block.appendChild(title);

      const instrumentSelect = document.createElement('select');
      instrumentSelect.className = 'instrument-select';
      instrumentSelect.innerHTML = `
        <option value="bass">Baixo</option>
        <option value="acoustic-guitar">Viol√£o A√ßo</option>
        <option value="nylon-guitar">Viol√£o Nylon</option>
        <option value="strings">Cordas</option>
      `;
      block.appendChild(instrumentSelect);

      const grid = createNoteGrid('bass', blockIndex);
      block.appendChild(grid);
      ui.bassContainer.appendChild(block);
      state.bassBlocks.push(block);
      return block;
    }

    function addMelody1Block() {
      const blockIndex = state.melody1Blocks.length;
      const block = document.createElement('div');
      block.className = 'instrument-block melody1-block';
      block.dataset.blockIndex = blockIndex;

      const title = document.createElement('div');
      title.textContent = `Bloco ${blockIndex + 1}`;
      title.style.fontWeight = 'bold';
      title.style.color = '#ff6b6b';
      title.style.marginBottom = '10px';
      block.appendChild(title);

      const instrumentSelect = document.createElement('select');
      instrumentSelect.className = 'instrument-select';
      instrumentSelect.innerHTML = `
        <option value="piano">Piano</option>
        <option value="sax">Saxofone</option>
        <option value="acordeon">Acordeon</option>
        <option value="strings">Cordas</option>
        <option value="acoustic-guitar">Viol√£o A√ßo</option>
        <option value="nylon-guitar">Viol√£o Nylon</option>
      `;
      block.appendChild(instrumentSelect);

      const grid = createNoteGrid('melody1', blockIndex);
      block.appendChild(grid);
      ui.melody1Container.appendChild(block);
      state.melody1Blocks.push(block);
      return block;
    }

    function addMelody2Block() {
      const blockIndex = state.melody2Blocks.length;
      const block = document.createElement('div');
      block.className = 'instrument-block melody2-block';
      block.dataset.blockIndex = blockIndex;

      const title = document.createElement('div');
      title.textContent = `Bloco ${blockIndex + 1}`;
      title.style.fontWeight = 'bold';
      title.style.color = '#4ecdc4';
      title.style.marginBottom = '10px';
      block.appendChild(title);

      const instrumentSelect = document.createElement('select');
      instrumentSelect.className = 'instrument-select';
      instrumentSelect.innerHTML = `
        <option value="sax">Saxofone</option>
        <option value="piano">Piano</option>
        <option value="acordeon">Acordeon</option>
        <option value="strings">Cordas</option>
        <option value="acoustic-guitar">Viol√£o A√ßo</option>
        <option value="nylon-guitar">Viol√£o Nylon</option>
      `;
      block.appendChild(instrumentSelect);

      const grid = createNoteGrid('melody2', blockIndex);
      block.appendChild(grid);
      ui.melody2Container.appendChild(block);
      state.melody2Blocks.push(block);
      return block;
    }

    function addDrumBlock() {
      const blockIndex = state.drumBlocks.length;
      const block = document.createElement('div');
      block.className = 'instrument-block drum-block';
      block.dataset.blockIndex = blockIndex;

      const title = document.createElement('div');
      title.textContent = `Bloco ${blockIndex + 1}`;
      title.style.fontWeight = 'bold';
      title.style.color = '#8e44ad';
      title.style.marginBottom = '10px';
      block.appendChild(title);

      const drumGrid = document.createElement('div');
      drumGrid.className = 'drum-grid-horizontal';

      DRUM_SAMPLES.forEach(drum => {
        const row = document.createElement('div');
        row.className = 'drum-row-horizontal';

        const label = document.createElement('div');
        label.className = 'drum-label-horizontal';
        label.textContent = drum.label;
        row.appendChild(label);

        for (let i = 0; i < 4; i++) {
          const cell = document.createElement('div');
          cell.className = 'drum-cell-horizontal';
          cell.dataset.step = i;
          cell.dataset.instr = drum.key;
          cell.dataset.block = blockIndex;
          cell.addEventListener('click', function() {
            this.classList.toggle('active');
          });
          row.appendChild(cell);
        }
        drumGrid.appendChild(row);
      });

      block.appendChild(drumGrid);
      ui.drumContainer.appendChild(block);
      state.drumBlocks.push(block);
      return block;
    }

    function createNoteGrid(type, blockIndex) {
      const grid = document.createElement('div');
      grid.className = 'note-grid';
      grid.dataset.type = type;
      grid.dataset.blockIndex = blockIndex;

      for (let i = 0; i < 4; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.step = i;
        cell.textContent = '1E'; // Default note

        cell.addEventListener('click', function(e) {
          const rect = this.getBoundingClientRect();
          const clickX = e.clientX - rect.left;
          const centerX = rect.width / 2;
          let currentText = this.textContent;
          let currentNum = 1;

          if (currentText === 'X') {
            currentNum = 1;
            this.classList.remove('x');
          } else {
            const match = currentText.match(/^(\d+)/);
            if (match) currentNum = parseInt(match[1]);
          }

          let currentIndex = ALL_NOTES.indexOf(currentNum);
          if (clickX < centerX) {
            currentIndex = (currentIndex - 1 + ALL_NOTES.length) % ALL_NOTES.length;
          } else {
            currentIndex = (currentIndex + 1) % ALL_NOTES.length;
          }
          const newNum = ALL_NOTES[currentIndex];
          const noteName = NUM_TO_NOTE[newNum] || '';
          this.textContent = newNum + noteName;
        });

        cell.addEventListener('dblclick', function() {
          if (this.textContent === 'X') {
            this.textContent = '1E';
            this.classList.remove('x');
          } else {
            this.textContent = 'X';
            this.classList.add('x');
          }
        });

        grid.appendChild(cell);
      }
      return grid;
    }

    // ===== PLAYBACK =====
    function buildPlaybackPlan() {
      const plan = {
        harmony: [],
        bass: [],
        melody1: [],
        melody2: [],
        drums: {}
      };

      DRUM_SAMPLES.forEach(d => plan.drums[d.key] = []);

      // Harmonia
      state.harmonyBlocks.forEach(block => {
        const grid = block.querySelector('.note-grid');
        const cells = grid.querySelectorAll('.cell');
        const instrument = block.querySelector('.instrument-select').value;
        cells.forEach(cell => {
          plan.harmony.push({
            chord: cell.textContent,
            instrument: instrument
          });
        });
      });

      // Baixo
      state.bassBlocks.forEach(block => {
        const grid = block.querySelector('.note-grid');
        const cells = grid.querySelectorAll('.cell');
        const instrument = block.querySelector('.instrument-select').value;
        cells.forEach(cell => {
          const val = cell.textContent;
          if (val === 'X') {
            plan.bass.push(null);
          } else {
            const match = val.match(/^(\d+)([A-Z]+)/);
            if (match) {
              const num = parseInt(match[1]);
              plan.bass.push({ note: num, instrument: instrument });
            } else {
              plan.bass.push(null);
            }
          }
        });
      });

      // Melodia 1
      state.melody1Blocks.forEach(block => {
        const grid = block.querySelector('.note-grid');
        const cells = grid.querySelectorAll('.cell');
        const instrument = block.querySelector('.instrument-select').value;
        cells.forEach(cell => {
          const val = cell.textContent;
          if (val === 'X') {
            plan.melody1.push(null);
          } else {
            const match = val.match(/^(\d+)([A-Z]+)/);
            if (match) {
              const num = parseInt(match[1]);
              plan.melody1.push({ note: num, instrument: instrument });
            } else {
              plan.melody1.push(null);
            }
          }
        });
      });

      // Melodia 2
      state.melody2Blocks.forEach(block => {
        const grid = block.querySelector('.note-grid');
        const cells = grid.querySelectorAll('.cell');
        const instrument = block.querySelector('.instrument-select').value;
        cells.forEach(cell => {
          const val = cell.textContent;
          if (val === 'X') {
            plan.melody2.push(null);
          } else {
            const match = val.match(/^(\d+)([A-Z]+)/);
            if (match) {
              const num = parseInt(match[1]);
              plan.melody2.push({ note: num, instrument: instrument });
            } else {
              plan.melody2.push(null);
            }
          }
        });
      });

      // Bateria
      state.drumBlocks.forEach(block => {
        DRUM_SAMPLES.forEach(drum => {
          const cells = block.querySelectorAll(`.drum-cell-horizontal[data-instr="${drum.key}"]`);
          cells.forEach(cell => {
            plan.drums[drum.key].push(cell.classList.contains('active'));
          });
        });
      });

      state.playbackPlan = plan;
      state.totalSteps = Math.max(
        plan.harmony.length || 0,
        plan.bass.length || 0,
        plan.melody1.length || 0,
        plan.melody2.length || 0,
        ...Object.values(plan.drums).map(arr => arr.length || 0)
      );
      state.stepIndex = 0;
      state.lastNoteTime = 0;
      return plan;
    }

    function getNoteFrequency(noteNum, noteName) {
      let baseFreq = NOTE_FREQ[noteName] || 440;
      // Ajuste de oitava: 1E = E3 (329.63 Hz), 18A = A4 (440Hz), 42A = A5 (880Hz)
      // Base: 18A = A4 ‚Üí 440Hz
      const octaveOffset = Math.floor((noteNum - 18) / 12); // cada 12 n√∫meros = 1 oitava
      return baseFreq * Math.pow(2, octaveOffset);
    }

    function playNote(instrumentKey, noteNum, time, gainNode, volume = 1.0) {
      if (!state.audioCtx) return;
      try {
        const noteName = NUM_TO_NOTE[noteNum];
        if (!noteName) return;

        const frequency = getNoteFrequency(noteNum, noteName);
        const oscillator = state.audioCtx.createOscillator();
        const gain = state.audioCtx.createGain();

        // Definir forma de onda por instrumento
        let waveType = 'square';
        if (instrumentKey === 'bass') waveType = 'sine';
        else if (instrumentKey === 'piano') waveType = 'triangle';
        else if (instrumentKey === 'sax') waveType = 'sawtooth';
        else if (instrumentKey === 'acordeon') waveType = 'square';

        oscillator.type = waveType;
        oscillator.frequency.value = frequency;

        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(volume, time + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);

        oscillator.connect(gain);
        gain.connect(gainNode);
        oscillator.start(time);
        oscillator.stop(time + 0.5);
      } catch (err) {
        console.warn('Erro ao tocar nota:', noteNum, instrumentKey, err);
      }
    }

    function playChord(chordData, time, gainNode, volume = 0.5) {
      if (!state.audioCtx) return;
      try {
        let root = chordData.chord.substring(0, 2);
        if (!['AS', 'CS', 'DS', 'FS', 'GS'].includes(root)) {
          root = chordData.chord.substring(0, 1);
        }
        const rootNote = root.toUpperCase();
        const baseFreq = NOTE_FREQ[rootNote] || 261.63;

        const oscillators = [];
        const gains = [];

        // Determinar tipo de acorde
        const isMinor = chordData.chord.includes('m') && !chordData.chord.includes('dim');
        const isDiminished = chordData.chord.includes('dim');
        const hasSeventh = chordData.chord.includes('7');
        const hasNinth = chordData.chord.includes('9');

        // Intervalos b√°sicos
        const intervals = [0]; // Root

        if (isDiminished) {
          intervals.push(3, 6); // R, m3, d5
        } else if (isMinor) {
          intervals.push(3, 7); // R, m3, P5
        } else {
          intervals.push(4, 7); // R, M3, P5
        }

        if (hasSeventh) {
          intervals.push(isMinor ? 10 : 11); // m7 ou M7
        }
        if (hasNinth) {
          intervals.push(14); // 9
        }

        intervals.forEach(interval => {
          const freq = baseFreq * Math.pow(2, interval / 12);
          const osc = state.audioCtx.createOscillator();
          const gain = state.audioCtx.createGain();

          osc.type = 'sine';
          osc.frequency.value = freq;

          gain.gain.setValueAtTime(0, time);
          gain.gain.linearRampToValueAtTime(volume / intervals.length, time + 0.01);
          gain.gain.exponentialRampToValueAtTime(0.001, time + 0.8);

          osc.connect(gain);
          gain.connect(gainNode);
          osc.start(time);
          osc.stop(time + 0.8);

          oscillators.push(osc);
          gains.push(gain);
        });

      } catch (err) {
        console.warn('Erro ao tocar acorde:', chordData.chord, err);
      }
    }

    function playDrum(drumKey, time, gainNode, volume = 0.8) {
      if (!state.audioCtx) return;
      try {
        const bufferSize = state.audioCtx.sampleRate * 0.1;
        const buffer = state.audioCtx.createBuffer(1, bufferSize, state.audioCtx.sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
          data[i] = Math.random() * 2 - 1;
        }

        const noise = state.audioCtx.createBufferSource();
        noise.buffer = buffer;

        const gain = state.audioCtx.createGain();
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(volume, time + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);

        noise.connect(gain);
        gain.connect(gainNode);

        // Filtros espec√≠ficos por tipo
        if (drumKey === 'bumbo') {
          const lowpass = state.audioCtx.createBiquadFilter();
          lowpass.type = 'lowpass';
          lowpass.frequency.value = 150;
          noise.connect(lowpass);
          lowpass.connect(gain);
        } else if (drumKey === 'caixa' || drumKey === 'prato-ataque') {
          const highpass = state.audioCtx.createBiquadFilter();
          highpass.type = 'highpass';
          highpass.frequency.value = 200;
          noise.connect(highpass);
          highpass.connect(gain);
        } else if (drumKey === 'chimbal' || drumKey === 'chimbal-aberto') {
          const bandpass = state.audioCtx.createBiquadFilter();
          bandpass.type = 'bandpass';
          bandpass.frequency.value = 800;
          bandpass.Q.value = 2;
          noise.connect(bandpass);
          bandpass.connect(gain);
        } else if (drumKey === 'surdo' || drumKey === 'tom-1' || drumKey === 'tom-2') {
          const lowpass = state.audioCtx.createBiquadFilter();
          lowpass.type = 'lowpass';
          lowpass.frequency.value = 100;
          noise.connect(lowpass);
          lowpass.connect(gain);
        } else {
          noise.connect(gain);
        }

        noise.start(time);
        noise.stop(time + 0.1);
      } catch (err) {
        console.warn('Erro ao tocar percuss√£o:', drumKey, err);
      }
    }

    function scheduleStep(time) {
      const idx = state.stepIndex;

      if (idx < state.playbackPlan.harmony.length) {
        const item = state.playbackPlan.harmony[idx];
        if (item && item.chord !== 'C' && item.chord !== 'X') {
          playChord(item, time, state.harmonicGain, 0.5);
        }
      }

      if (idx < state.playbackPlan.bass.length) {
        const item = state.playbackPlan.bass[idx];
        if (item) {
          playNote(item.instrument, item.note, time, state.bassGain, 0.7);
        }
      }

      if (idx < state.playbackPlan.melody1.length) {
        const item = state.playbackPlan.melody1[idx];
        if (item) {
          playNote(item.instrument, item.note, time, state.melodyGain, 0.6);
        }
      }

      if (idx < state.playbackPlan.melody2.length) {
        const item = state.playbackPlan.melody2[idx];
        if (item) {
          playNote(item.instrument, item.note, time, state.melodyGain, 0.6);
        }
      }

      Object.keys(state.playbackPlan.drums).forEach(key => {
        if (idx < state.playbackPlan.drums[key].length && state.playbackPlan.drums[key][idx]) {
          playDrum(key, time, state.drumGain, 0.8);
        }
      });

      state.stepIndex = (state.stepIndex + 1) % state.totalSteps;
    }

    function startScheduler() {
      state.isPlaying = true;
      ui.btnPlay.textContent = '‚è∏ Pause';

      function tick() {
        if (!state.isPlaying) return;

        const now = state.audioCtx.currentTime;
        const stepDuration = 60 / state.bpm / 4; // semicolcheia
        const nextStep = state.lastNoteTime + stepDuration;

        if (now >= nextStep) {
          scheduleStep(nextStep);
          state.lastNoteTime = nextStep;
        }

        requestAnimationFrame(tick);
      }

      state.lastNoteTime = state.audioCtx.currentTime;
      tick();
    }

    function onPlay() {
      if (!state.isLoaded) {
        alert('A aplica√ß√£o ainda est√° carregando. Aguarde um momento.');
        return;
      }

      if (!state.audioCtx) {
        updateStatus('Erro: Audio Context n√£o inicializado', 'error');
        return;
      }

      if (state.isPlaying) {
        state.isPlaying = false;
        ui.btnPlay.textContent = '‚ñ∂ Play';
        return;
      }

      try {
        if (state.audioCtx.state === 'suspended') {
          state.audioCtx.resume();
        }

        buildPlaybackPlan();
        startScheduler();
        updateStatus('Reproduzindo...', 'ready');
      } catch (error) {
        console.error('Erro ao iniciar reprodu√ß√£o:', error);
        updateStatus('Erro ao iniciar: ' + error.message, 'error');
      }
    }

    function onStop() {
      state.isPlaying = false;
      state.stepIndex = 0;
      ui.btnPlay.textContent = '‚ñ∂ Play';
      updateStatus('Reprodu√ß√£o parada', 'ready');
    }

    // ===== GRAVA√á√ÉO WAV =====
    async function renderAndDownloadWAV(durationInSeconds) {
      if (!state.isLoaded) {
        alert('A aplica√ß√£o ainda est√° carregando. Aguarde um momento.');
        return;
      }

      updateStatus('Renderizando √°udio...', 'loading');
      ui.btnSaveWAV.disabled = true;
      ui.btnSaveWAV.textContent = '‚è≥ Renderizando...';

      try {
        const sampleRate = 44100;
        const totalSamples = Math.ceil(durationInSeconds * sampleRate);
        const offlineCtx = new OfflineAudioContext(2, totalSamples, sampleRate);

        const master = offlineCtx.createGain();
        const drumGain = offlineCtx.createGain();
        const bassGain = offlineCtx.createGain();
        const melodyGain = offlineCtx.createGain();
        const harmonicGain = offlineCtx.createGain();

        master.connect(offlineCtx.destination);
        drumGain.connect(master);
        bassGain.connect(master);
        melodyGain.connect(master);
        harmonicGain.connect(master);

        master.gain.value = 0.8;
        drumGain.gain.value = 0.6;
        bassGain.gain.value = 0.5;
        melodyGain.gain.value = 0.5;
        harmonicGain.gain.value = 0.5;

        buildPlaybackPlan();
        const sixteenthDur = 60 / state.bpm / 4;
        const totalSteps = Math.min(state.totalSteps, Math.ceil(durationInSeconds / sixteenthDur));

        for (let step = 0; step < totalSteps; step++) {
          const time = step * sixteenthDur;

          // Harmonia
          if (step < state.playbackPlan.harmony.length) {
            const item = state.playbackPlan.harmony[step];
            if (item && item.chord !== 'C' && item.chord !== 'X') {
              const root = item.chord.substring(0, 2);
              const rootNote = !['AS','CS','DS','FS','GS'].includes(root) ? item.chord[0] : root;
              const baseFreq = NOTE_FREQ[rootNote.toUpperCase()] || 261.63;

              const isMinor = item.chord.includes('m') && !item.chord.includes('dim');
              const isDim = item.chord.includes('dim');
              const intervals = [0];

              if (isDim) intervals.push(3, 6);
              else if (isMinor) intervals.push(3, 7);
              else intervals.push(4, 7);

              intervals.forEach(interval => {
                const freq = baseFreq * Math.pow(2, interval / 12);
                const osc = offlineCtx.createOscillator();
                const gain = offlineCtx.createGain();
                osc.type = 'sine';
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(0.5, time + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.8);
                osc.connect(gain);
                gain.connect(harmonicGain);
                osc.start(time);
                osc.stop(time + 0.8);
              });
            }
          }

          // Baixo
          if (step < state.playbackPlan.bass.length) {
            const item = state.playbackPlan.bass[step];
            if (item) {
              const freq = getNoteFrequency(item.note, NUM_TO_NOTE[item.note]);
              const osc = offlineCtx.createOscillator();
              const gain = offlineCtx.createGain();
              osc.type = 'sine';
              osc.frequency.value = freq;
              gain.gain.setValueAtTime(0, time);
              gain.gain.linearRampToValueAtTime(0.7, time + 0.01);
              gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
              osc.connect(gain);
              gain.connect(bassGain);
              osc.start(time);
              osc.stop(time + 0.5);
            }
          }

          // Melodias
          [[state.playbackPlan.melody1, 'triangle'], [state.playbackPlan.melody2, 'sawtooth']].forEach(([melody, wave]) => {
            if (step < melody.length) {
              const item = melody[step];
              if (item) {
                const freq = getNoteFrequency(item.note, NUM_TO_NOTE[item.note]);
                const osc = offlineCtx.createOscillator();
                const gain = offlineCtx.createGain();
                osc.type = wave;
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(0.6, time + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
                osc.connect(gain);
                gain.connect(melodyGain);
                osc.start(time);
                osc.stop(time + 0.5);
              }
            }
          });

          // Percuss√£o
          Object.keys(state.playbackPlan.drums).forEach(key => {
            if (step < state.playbackPlan.drums[key].length && state.playbackPlan.drums[key][step]) {
              const bufferSize = offlineCtx.sampleRate * 0.1;
              const buffer = offlineCtx.createBuffer(1, bufferSize, offlineCtx.sampleRate);
              const data = buffer.getChannelData(0);

              for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
              }

              const noise = offlineCtx.createBufferSource();
              noise.buffer = buffer;

              const gain = offlineCtx.createGain();
              gain.gain.setValueAtTime(0, time);
              gain.gain.linearRampToValueAtTime(0.8, time + 0.01);
              gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);

              if (key === 'bumbo') {
                const lowpass = offlineCtx.createBiquadFilter();
                lowpass.type = 'lowpass';
                lowpass.frequency.value = 150;
                noise.connect(lowpass);
                lowpass.connect(gain);
              } else if (key === 'caixa' || key === 'prato-ataque') {
                const highpass = offlineCtx.createBiquadFilter();
                highpass.type = 'highpass';
                highpass.frequency.value = 200;
                noise.connect(highpass);
                highpass.connect(gain);
              } else if (key === 'chimbal' || key === 'chimbal-aberto') {
                const bandpass = offlineCtx.createBiquadFilter();
                bandpass.type = 'bandpass';
                bandpass.frequency.value = 800;
                bandpass.Q.value = 2;
                noise.connect(bandpass);
                bandpass.connect(gain);
              } else {
                noise.connect(gain);
              }

              noise.start(time);
              noise.stop(time + 0.1);
            }
          });
        }

        const renderedBuffer = await offlineCtx.startRendering();
        const wavBlob = audioBufferToWav(renderedBuffer);
        const fileName = `jam-on-${new Date().toISOString().slice(0,10)}-${Math.floor(Math.random()*1000)}.wav`;
        downloadBlob(wavBlob, fileName);
        updateStatus('Renderiza√ß√£o conclu√≠da!', 'ready');
      } catch (error) {
        console.error('Erro ao renderizar WAV:', error);
        updateStatus('Erro ao renderizar: ' + error.message, 'error');
      }

      ui.btnSaveWAV.textContent = 'üíæ Salvar como WAV';
      ui.btnSaveWAV.disabled = false;
    }

    function audioBufferToWav(buffer) {
      const numOfChan = buffer.numberOfChannels;
      const length = buffer.length * numOfChan * 2 + 44;
      const arrayBuffer = new ArrayBuffer(length);
      const view = new DataView(arrayBuffer);
      const channels = [];
      let i, sample, offset = 0;

      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }

      writeString(view, 0, 'RIFF');
      view.setUint32(4, length - 8, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numOfChan, true);
      view.setUint32(24, 44100, true);
      view.setUint32(28, 44100 * 2 * numOfChan, true);
      view.setUint16(32, 2 * numOfChan, true);
      view.setUint16(34, 16, true);
      writeString(view, 36, 'data');
      view.setUint32(40, length - 44, true);

      for (i = 0; i < buffer.numberOfChannels; i++) {
        channels.push(buffer.getChannelData(i));
      }

      offset = 44;
      for (i = 0; i < buffer.length; i++) {
        for (let channel = 0; channel < numOfChan; channel++) {
          sample = Math.max(-1, Math.min(1, channels[channel][i]));
          sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF);
          view.setInt16(offset, sample, true);
          offset += 2;
        }
      }

      return new Blob([view], { type: 'audio/wav' });
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    }

    // ===== INICIALIZAR =====
    window.addEventListener('load', initializeApp);
  </script>
</body>
</html>
