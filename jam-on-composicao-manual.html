<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jam On ‚Äì Composi√ß√£o Manual</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      background: #121212;
      color: #e0e0e0;
      margin: 0;
      padding: 20px;
    }
    header {
      text-align: center;
      margin-bottom: 20px;
    }
    h1 {
      color: #5eead4;
      font-size: 1.8em;
      margin: 0;
    }
    .pill {
      display: inline-block;
      background: #333;
      color: #aaa;
      font-size: 0.75em;
      padding: 4px 10px;
      border-radius: 12px;
    }
    .card {
      max-width: 1200px;
      margin: 0 auto;
      background: #1e1e1e;
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      overflow: hidden;
      padding: 20px;
      text-align: left;
    }
    .section {
      margin: 25px 0;
      padding: 15px;
      border: 1px solid #333;
      border-radius: 10px;
      background: #222;
    }
    .section h3 {
      color: #5eead4;
      margin-top: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .add-btn {
      background: #4CAF50;
      color: white;
      font-size: 1.2em;
      padding: 6px 10px;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    .instrument-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin: 15px 0;
    }
    .instrument-block {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      min-width: 220px;
    }
    .bass-block { border-left: 4px solid #ffcc00; }
    .melody1-block { border-left: 4px solid #ff6b6b; }
    .melody2-block { border-left: 4px solid #4ecdc4; }
    .drum-block { border-left: 4px solid #8e44ad; }
    .harmony-block { border-left: 4px solid #9b59b6; }
    /* ===== ESTILO DO GRID DE COLUNAS ===== */
    .columns-grid {
      display: flex;
      gap: 2px;
      margin: 10px 0;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding: 5px 0;
      position: relative;
    }
    .column {
      display: flex;
      flex-direction: column;
      gap: 2px;
      align-items: center;
    }
    .cell {
      width: 45px;
      height: 45px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7em;
      cursor: pointer;
      color: #ccc;
      user-select: none;
      transition: background 0.2s;
      position: relative; /* Para posicionar o bot√£o de delete */
    }
    .cell:hover {
      background: #444;
    }
    .cell.x {
      background: #555;
      color: #888;
      font-weight: bold;
    }
    /* Bot√£o de Excluir C√©lula Individual (e agora tamb√©m Coluna) */
    .delete-cell-btn {
      position: absolute;
      top: -8px;
      right: -8px;
      background: #f44336;
      color: white;
      border: none;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      font-size: 0.6em;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      z-index: 10;
    }
    .delete-cell-btn:hover {
      background: #d32f2f;
    }
    /* ===== ESTILO DA BATERIA ===== */
    /* Container principal da bateria com layout em grid */
    .drum-wrapper {
      display: flex;
      align-items: flex-start;
      gap: 10px;
    }
    /* Coluna fixa para os r√≥tulos das pe√ßas da bateria */
    .drum-labels {
      display: flex;
      flex-direction: column;
      gap: 2px;
      align-items: flex-start;
      justify-content: flex-start;
      padding-top: 5px; /* Ajuste fino para alinhar verticalmente */
    }
    /* Estilo do r√≥tulo da pe√ßa da bateria */
    .drum-label-item {
      width: 120px;
      height: 45px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-right: none;
      border-radius: 4px 0 0 4px;
      display: flex;
      align-items: center;
      padding: 0 8px;
      text-align: left;
      font-size: 0.7em;
      color: #ccc;
      box-sizing: border-box;
    }
    /* C√©lula da bateria - agora sem o label interno */
    .drum-cell {
      width: 45px;
      height: 45px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7em;
      cursor: pointer;
      color: #ccc;
      transition: background 0.2s;
      position: relative;
    }
    .drum-cell.active {
      background: #5eead4;
      color: #121212;
    }
    .drum-cell:hover {
      background: #444;
    }
    .instrument-select, .chord-select {
      margin: 10px 0;
      padding: 8px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      color: white;
      width: 100%;
    }
    .bpm-control {
      text-align: center;
      margin: 15px 0;
    }
    .bpm-display {
      font-size: 1.5em;
      font-weight: bold;
      color: #5eead4;
      margin: 10px 0;
    }
    .bpm-slider {
      width: 80%;
      margin: 10px auto;
    }
    .btn-row {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
    }
    button {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      font-size: 1em;
      transition: opacity 0.2s;
    }
    button.primary {
      background: #5eead4;
      color: #121212;
    }
    button.danger {
      background: #f44336;
      color: white;
    }
    button:hover:not(:disabled) {
      opacity: 0.9;
    }
    .loading {
      text-align: center;
      padding: 20px;
      color: #5eead4;
    }
    .status-indicator {
      text-align: center;
      padding: 10px;
      margin: 10px 0;
      border-radius: 6px;
    }
    .status-ready {
      background: #2a4d2a;
      color: #8eff8e;
    }
    .status-loading {
      background: #4d462a;
      color: #ffe08e;
    }
    .status-error {
      background: #4d2a2a;
      color: #ff8e8e;
    }
    .instructions {
      font-size: 0.85em;
      color: #aaa;
      margin-top: 8px;
      text-align: center;
    }
    .countdown {
      font-size: 2em;
      color: #ffcc00;
      text-align: center;
      margin: 20px 0;
      font-weight: bold;
    }
    /* ===== ESTILO DO MODAL ===== */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    .modal {
      background: #2a2a2a;
      border: 2px solid #5eead4;
      border-radius: 12px;
      padding: 20px;
      max-width: 90%;
      max-height: 90%;
      overflow-y: auto;
      box-shadow: 0 0 30px rgba(94, 234, 212, 0.5);
    }
    .modal h2 {
      color: #5eead4;
      margin-top: 0;
      text-align: center;
    }
    .modal-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 8px;
      margin-top: 20px;
    }
    .modal-option {
      padding: 10px;
      background: #333;
      border: 1px solid #555;
      border-radius: 6px;
      text-align: center;
      cursor: pointer;
      transition: background 0.2s;
    }
    .modal-option:hover {
      background: #444;
    }
    .modal-option.x {
      background: #555;
      color: #888;
    }
    /* ===== ESTILO DA BARRA DE PROGRESSO ===== */
    .progress-container {
      width: 100%;
      background: #333;
      border-radius: 4px;
      margin: 10px 0;
      height: 10px;
    }
    .progress-bar {
      height: 100%;
      background: #5eead4;
      border-radius: 4px;
      width: 0%;
      transition: width 0.3s ease;
    }
    /* ===== MARCADOR DE SEM√çNIMA ===== */
    .semibreve-marker {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 1px;
      background: rgba(255, 255, 255, 0.3);
      z-index: 5;
      pointer-events: none;
    }
    .semibreve-marker::after {
      content: '|';
      position: absolute;
      top: -20px;
      left: -5px;
      color: rgba(255, 255, 255, 0.5);
      font-size: 14px;
      font-weight: bold;
    }
    @media (max-width: 768px) {
      .cell, .drum-cell { 
        width: 35px;
        height: 35px;
        font-size: 0.6em;
      }
      .drum-label-item { 
        width: 80px;
        font-size: 0.6em; 
        padding: 0 6px;
        height: 35px;
      }
      button { padding: 10px 15px; }
      .add-btn { width: 25px; height: 25px; font-size: 1em; }
      .instrument-block { min-width: 160px; }
      .delete-cell-btn {
        width: 14px;
        height: 14px;
        font-size: 0.5em;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Jam On ‚Äì Composi√ß√£o Manual</h1>
    <div class="pill">Cada c√©lula = semicolcheia (1/4 da sem√≠nima)</div>
  </header>
  <div class="card">
    <div id="statusIndicator" class="status-indicator status-loading">
      Carregando... Clique 8 vezes para preparar o som.
    </div>
    <div class="countdown" id="countdown"></div>
    <div class="section">
      <h3>üéõÔ∏è Controle de BPM</h3>
      <div class="bpm-control">
        <div class="bpm-display" id="bpmDisplay">100 BPM</div>
        <input type="range" id="bpmSlider" class="bpm-slider" min="60" max="180" value="100" step="1">
      </div>
    </div>
    <!-- √öNICO BOT√ÉO "+" QUE ADICIONA COMPASSO EM TODOS OS INSTRUMENTOS -->
    <div style="text-align: center; margin: 20px 0;">
      <button id="addCompassoBtn" class="add-btn">+</button>
      <span style="color: #aaa; margin-left: 10px;">Adicionar compasso em todos os instrumentos</span>
    </div>
    <!-- HARMONIA (4 c√©lulas por instrumento = 1 compasso) -->
    <div class="section">
      <h3>üé∏ Harmonia</h3>
      <div id="harmonyContainer" class="instrument-container"></div>
    </div>
    <!-- BAIXO (4 c√©lulas = 1 compasso) -->
    <div class="section">
      <h3>üé∏ Baixo</h3>
      <div id="bassContainer" class="instrument-container"></div>
    </div>
    <!-- MELODIA 1 (4 c√©lulas = 1 compasso) -->
    <div class="section">
      <h3>üéπ Melodia 1</h3>
      <div id="melody1Container" class="instrument-container"></div>
    </div>
    <!-- MELODIA 2 (4 c√©lulas = 1 compasso) -->
    <div class="section">
      <h3>üé∑ Melodia 2</h3>
      <div id="melody2Container" class="instrument-container"></div>
    </div>
    <!-- BATERIA (4 c√©lulas = 1 compasso) -->
    <div class="section">
      <h3>ü•Å Bateria</h3>
      <div id="drumContainer" class="instrument-container"></div>
    </div>
    <div class="btn-row">
      <button id="btnPlay" class="primary" disabled>‚ñ∂ Play</button>
      <button id="btnStop" class="danger" disabled>‚èπ Stop</button>
      <button id="btnSaveWAV" class="primary" disabled>üíæ Salvar como WAV</button>
    </div>
    <div class="instructions">
      Clique em uma c√©lula para escolher uma nota ou acorde.<br>
      Use "+" para adicionar uma coluna em todos os instrumentos.<br>
      <strong>Clique 8 vezes em qualquer c√©lula para preparar os sons.</strong>
    </div>
  </div>
  <!-- MODAL (inicialmente oculto) -->
  <div id="selectionModal" class="modal-overlay" style="display: none;">
    <div class="modal">
      <h2 id="modalTitle">Selecione uma op√ß√£o</h2>
      <div id="modalGrid" class="modal-grid">
        <!-- As op√ß√µes ser√£o inseridas aqui dinamicamente -->
      </div>
    </div>
  </div>
  <!-- CONTAINER DA BARRA DE PROGRESSO (inicialmente oculto) -->
  <div id="progressContainer" style="display: none; text-align: center; margin: 20px 0;">
    <div>Renderizando...</div>
    <div class="progress-container">
      <div id="progressBar" class="progress-bar"></div>
    </div>
    <div id="progressText">0%</div>
  </div>
 <script>
// ===== CONSTANTES =====
const AVAILABLE_CHORDS = [
  'X', // ‚Üê OP√á√ÉO EM BRANCO ADICIONADA
  // Acordes em A
  'A', 'A11', 'A13', 'A4', 'A45+', 'A5', 'A5+', 'A6', 'A7', 'A75+', 'A9', 'A95+', 'Adim', 
  'Am', 'Am5', 'Am5+', 'Am6', 'Am7', 'Am75+', 'Am9',
  // Acordes em AS (A#)
  'AS', 'AS11', 'AS13', 'AS4', 'AS45+', 'AS5', 'AS5+', 'AS6', 'AS7', 'AS75+', 'AS9', 'AS95+',
  'ASdim', 'ASm', 'ASm5', 'ASm5+', 'ASm6', 'ASm7', 'ASm75+', 'ASm9',
  // Acordes em B
  'B', 'B11', 'B13', 'B4', 'B45+', 'B5', 'B5+', 'B6', 'B7', 'B75+', 'B9', 'B95+', 'Bdim',
  'Bm', 'Bm5', 'Bm5+', 'Bm6', 'Bm7', 'Bm75+', 'Bm9',
  // Acordes em C
  'C', 'C11', 'C13', 'C4', 'C45+', 'C5', 'C5+', 'C6', 'C7', 'C75+', 'C9', 'C95+', 'Cdim',
  'Cm', 'Cm5', 'Cm5+', 'Cm6', 'Cm7', 'Cm75+', 'Cm9',
  // Acordes em CS (C#)
  'CS', 'CS11', 'CS13', 'CS4', 'CS45+', 'CS5', 'CS5+', 'CS6', 'CS7', 'CS75+', 'CS9', 'CS95+',
  'CSdim', 'CSm', 'CSm5', 'CSm5+', 'CSm6', 'CSm7', 'CSm75+', 'CSm9',
  // Acordes em D
  'D', 'D11', 'D13', 'D4', 'D45+', 'D5', 'D5+', 'D6', 'D7', 'D75+', 'D9', 'D95+', 'Ddim',
  'Dm', 'Dm5', 'Dm5+', 'Dm6', 'Dm7', 'Dm75+', 'Dm9',
  // Acordes em E
  'E', 'E11', 'E13', 'E4', 'E45+', 'E5', 'E5+', 'E6', 'E7', 'E75+', 'E9', 'E95+', 'Edim',
  'Em', 'Em5', 'Em5+', 'Em6', 'Em7', 'Em75+', 'Em9',
  // Acordes em DS (D#)
  'DS', 'DS11', 'DS13', 'DS4', 'DS45+', 'DS5', 'DS5+', 'DS6', 'DS7', 'DS75+', 'DS9', 'DS95+',
  'DSdim', 'DSm', 'DSm5', 'DSm5+', 'DSm6', 'DSm7', 'DSm75+', 'DSm9',
  // Acordes em F
  'F', 'F11', 'F13', 'F4', 'F45+', 'F5', 'F5+', 'F6', 'F7', 'F75+', 'F9', 'F95+', 'Fdim',
  'Fm', 'Fm5', 'Fm5+', 'Fm6', 'Fm7', 'Fm75+', 'Fm9',
  // Acordes em FS (F#)
  'FS', 'FS11', 'FS13', 'FS4', 'FS45+', 'FS5', 'FS5+', 'FS6', 'FS7', 'FS75+', 'FS9', 'FS95+',
  'FSdim', 'FSm', 'FSm5', 'FSm5+', 'FSm6', 'FSm7', 'FSm75+', 'FSm9',
  // Acordes em G
  'G', 'G11', 'G13', 'G4', 'G45+', 'G5', 'G5+', 'G6', 'G7', 'G75+', 'G9', 'G95+', 'Gdim',
  'Gm', 'Gm5', 'Gm5+', 'Gm6', 'Gm7', 'Gm75+', 'Gm9',
  // Acordes em GS (G#)
  'GS', 'GS11', 'GS13', 'GS4', 'GS45+', 'GS5', 'GS5+', 'GS6', 'GS7', 'GS75+', 'GS9', 'GS95+',
  'GSdim', 'GSm', 'GSm5', 'GSm5+', 'GSm6', 'GSm7', 'GSm75+', 'GSm9'
];
const NOTE_NAMES = [
  'X', // ‚Üê OP√á√ÉO EM BRANCO ADICIONADA
  '10CS.mp3', '11D.mp3', '12DS.mp3', '13E.mp3', '14F.mp3', '15FS.mp3', '16G.mp3', '17GS.mp3', 
  '18A.mp3', '19AS.mp3', '1E.mp3', '20B.mp3', '21C.mp3', '22CS.mp3', '23D.mp3', '24DS.mp3', 
  '25E.mp3', '26F.mp3', '27FS.mp3', '28G.mp3', '29GS.mp3', '2F.mp3', '30A.mp3', '31AS.mp3', 
  '32B.mp3', '33C.mp3', '34CS.mp3', '35D.mp3', '36DS.mp3', '37E.mp3', '38F.mp3', '39FS.mp3', 
  '3FS.mp3', '40G.mp3', '41GS.mp3', '42A.mp3', '43AS.mp3', '44B.mp3', '45C.mp3', '46CS.mp3', 
  '47D.mp3', '48DS.mp3', '49E.mp3', '4G.mp3', '5GS.mp3', '6A.mp3', '7AS.mp3', '8B.mp3', '9C.mp3'
];
// Ordena as notas pelo n√∫mero antes do nome da nota (ex: '1E' vem antes de '10CS')
const ALL_NOTES = NOTE_NAMES
  .map(name => name.replace('.mp3', ''))
  .sort((a, b) => {
    if (a === 'X') return -1; // Mant√©m 'X' no in√≠cio
    if (b === 'X') return 1;
    const numA = parseInt(a.match(/^\d+/)[0]);
    const numB = parseInt(b.match(/^\d+/)[0]);
    return numA - numB;
  });
const NOTE_FREQ = {
  'C': 261.63, 'CS': 277.18, 'D': 293.66, 'DS': 311.13, 'E': 329.63, 'F': 349.23,
  'FS': 369.99, 'G': 392.00, 'GS': 415.30, 'A': 440.00, 'AS': 466.16, 'B': 493.88
};
const MELODIC_INSTRUMENTS = {
  'acordeon': 'assets/AcordeonMelodia/',       // assets/AcordeonMelodia/nota.mp3
  'bass': 'assets/BaixoMelodia/',              // assets/BaixoMelodia/nota.mp3
  'strings': 'assets/Cordas/',                 // assets/Cordas/nota.mp3
  'piano': 'assets/PianoString/',              // assets/PianoString/nota.mp3
  'sax': 'assets/SaxMelodia/',                 // assets/SaxMelodia/nota.mp3
  'sinos': 'assets/SinosMelodia/',             // assets/SinosMelodia/nota.mp3 (adicionado)
  'acoustic-guitar': 'assets/ViolaoAcoMelodia/', // assets/ViolaoAcoMelodia/nota.mp3
  'nylon-guitar': 'assets/ViolaoNylonMelodia/',  // assets/ViolaoNylonMelodia/nota.mp3
  'distorted-guitar-melody': 'guitarraDistorcao/Melodia/' // guitarraDistorcao/Melodia/nota.mp3
};

// ===== CORRE√á√ÉO AQUI: Caminhos dos Instrumentos Harm√¥nicos =====
const HARMONIC_INSTRUMENTS = {
  'distorted-guitar': 'guitarraDistorcao/',    // guitarraDistorcao/Nota/acorde.mp3
  'clean-guitar': 'guitarraLimpa/',            // guitarraLimpa/Nota/acorde.mp3
  'piano-chord': 'assets/PianoStringChord/'    // assets/PianoStringChord/Nota/acorde.mp3
};
const DRUM_SAMPLES = [
  { key: 'ataque', label: 'Prato De Ataque', path: 'assets/ataque.mp3' },
  { key: 'bumbo', label: 'Bumbo', path: 'assets/bumbo.mp3' },
  { key: 'caixa', label: 'Caixa', path: 'assets/caixa.mp3' },
  { key: 'chimbal', label: 'Chimbal Fechado', path: 'assets/chimbal.mp3' },
  { key: 'chimbal-aberto', label: 'Chimbal Aberto', path: 'assets/chimbal-aberto.mp3' },
  { key: 'conducao', label: 'Condu√ß√£o', path: 'assets/conducao.mp3' },
  { key: 'conducao-centro', label: 'Condu√ß√£o Centro', path: 'assets/conducao-centro.mp3' },
  { key: 'surdo', label: 'Surdo', path: 'assets/surdo.mp3' },
  { key: 'tom-1', label: 'Tom 1', path: 'assets/tom-1.mp3' },
  { key: 'tom-2', label: 'Tom 2', path: 'assets/tom-2.mp3' }
];
// ===== ESTADO =====
const state = {
  running: false,
  paused: false,
  bpm: 100,
  stepIndex: 0,
  totalSteps: 4,
  buffers: {
    drums: {},
    melodic: {},
    harmonic: {}
  },
  loadedSamples: new Set(),
  activeInput: null,
  schedulerTimer: null,
  harmonyBlocks: [],
  bassBlocks: [],
  melody1Blocks: [],
  melody2Blocks: [],
  drumBlocks: [],
  lastNoteTime: 0,
  recordedChunks: [],
  audioCtx: null,
  isPlaying: false,
  isRendering: false,
  countdownActive: false,
  countdownValue: 4,
  currentlyPlaying: { 
    bass: null,
    melody1: null,
    melody2: null,
    harmony: null
  },
  playbackPlan: null,
  // Estado do Modal
  modal: {
    targetCell: null,
    type: null, // 'harmony' ou 'melodic'
    instrumentKey: null
  }
};
// ===== ELEMENTOS =====
const ui = {
  statusIndicator: document.getElementById('statusIndicator'),
  countdown: document.getElementById('countdown'),
  bpmSlider: document.getElementById('bpmSlider'),
  bpmDisplay: document.getElementById('bpmDisplay'),
  btnPlay: document.getElementById('btnPlay'),
  btnStop: document.getElementById('btnStop'),
  btnSaveWAV: document.getElementById('btnSaveWAV'),
  addCompassoBtn: document.getElementById('addCompassoBtn'),
  harmonyContainer: document.getElementById('harmonyContainer'),
  bassContainer: document.getElementById('bassContainer'),
  melody1Container: document.getElementById('melody1Container'),
  melody2Container: document.getElementById('melody2Container'),
  drumContainer: document.getElementById('drumContainer'),
  selectionModal: document.getElementById('selectionModal'),
  modalTitle: document.getElementById('modalTitle'),
  modalGrid: document.getElementById('modalGrid'),
  progressContainer: document.getElementById('progressContainer'),
  progressBar: document.getElementById('progressBar'),
  progressText: document.getElementById('progressText')
};
// ===== INICIALIZA√á√ÉO =====
// ===== INICIALIZA√á√ÉO =====
async function initializeApp() {
  updateStatus('Pronto para compor. Clique nas c√©lulas para criar sua m√∫sica.', 'ready');
  try {
    state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    state.masterGain = state.audioCtx.createGain();
    state.drumGain = state.audioCtx.createGain();
    state.bassGain = state.audioCtx.createGain();
    state.melodyGain = state.audioCtx.createGain();
    state.harmonicGain = state.audioCtx.createGain();
    state.masterGain.connect(state.audioCtx.destination);
    state.drumGain.connect(state.masterGain);
    state.bassGain.connect(state.masterGain);
    state.melodyGain.connect(state.masterGain);
    state.harmonicGain.connect(state.masterGain);
    state.masterGain.gain.value = 0.8;
    state.drumGain.gain.value = 1.0;
    state.bassGain.gain.value = 0.5;
    state.melodyGain.gain.value = 0.5;
    state.harmonicGain.gain.value = 0.5;
    setupEventListeners();

    // --- CORRE√á√ÉO DEFINITIVA: Garante 3 blocos independentes ---
    // Limpa os arrays de estado antes de adicionar os blocos
    state.harmonyBlocks = [];
    state.bassBlocks = [];
    state.melody1Blocks = [];
    state.melody2Blocks = [];
    state.drumBlocks = [];

    // Adiciona 3 blocos de harmonia
    for (let i = 0; i < 3; i++) {
      addHarmonyBlock();
    }

    // Adiciona 1 bloco de cada instrumento mel√≥dico e de bateria
    addBassBlock();
    addMelody1Block();
    addMelody2Block();
    addDrumBlock();

    ui.btnPlay.disabled = false;
    ui.btnSaveWAV.disabled = true;
    ui.btnStop.disabled = true;
    updateStatus('Componha sua m√∫sica. Clique em Play para iniciar com contagem de 4 compassos.', 'ready');
  } catch (error) {
    console.error('Erro ao inicializar:', error);
    updateStatus('Erro ao inicializar: ' + error.message, 'error');
  }
}
function setupEventListeners() {
  updateBPMDisplay();
  ui.bpmSlider.addEventListener('input', handleBPMChange);
  ui.addCompassoBtn.addEventListener('click', addCompasso);
  ui.btnPlay.addEventListener('click', onPlay);
  ui.btnStop.addEventListener('click', onStop);
  ui.btnSaveWAV.addEventListener('click', () => renderAndDownloadWAV()); // Sem dura√ß√£o fixa
  document.addEventListener('click', function(e) {
    if (e.target.classList.contains('cell') || e.target.classList.contains('drum-cell')) {
      if (e.target.classList.contains('cell')) {
        const instrument = e.target.parentElement.parentElement.querySelector('.instrument-select').value;
        const type = e.target.parentElement.dataset.type;
        const noteOrChord = e.target.textContent;
        if (type === 'harmony') {
          loadSample('harmonic', instrument, noteOrChord);
        } else {
          loadSample('melodic', instrument, noteOrChord);
        }
      } else if (e.target.classList.contains('drum-cell')) {
        const drumKey = e.target.dataset.instr;
        loadSample('drum', drumKey, '');
      }
    }
  });
  // Evento para fechar o modal ao clicar fora dele
  ui.selectionModal.addEventListener('click', function(e) {
    if (e.target === this) {
      closeModal();
    }
  });
}
function handleBPMChange() {
  state.bpm = parseInt(ui.bpmSlider.value);
  updateBPMDisplay();
}
function updateBPMDisplay() {
  ui.bpmDisplay.textContent = `${state.bpm} BPM`;
}
function updateStatus(message, type) {
  ui.statusIndicator.textContent = message;
  ui.statusIndicator.className = 'status-indicator status-' + type;
}
// ===== CARREGAMENTO SOB DEMANDA (CORRIGIDO) =====
async function loadSample(instrumentType, key, noteOrChord) {
  let filePath;
  let bufferKey;
  if (instrumentType === 'drum') {
    const sample = DRUM_SAMPLES.find(d => d.key === key);
    if (!sample) return;
    filePath = sample.path;
    bufferKey = key;
  } else if (instrumentType === 'melodic') {
    if (noteOrChord === 'X') return; // Ignora 'X'
    filePath = MELODIC_INSTRUMENTS[key] + noteOrChord + '.mp3';
    bufferKey = `melodic-${key}-${noteOrChord}`;
  } else if (instrumentType === 'harmonic') {
    if (noteOrChord === 'X') return; // Ignora 'X'
    let root;
    if (noteOrChord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(noteOrChord.slice(0, 2))) {
      root = noteOrChord.slice(0, 2);
    } else {
      root = noteOrChord[0];
    }
    // Monta o caminho: HARMONIC_INSTRUMENTS[key] + root + '/' + noteOrChord + '.mp3'
    filePath = HARMONIC_INSTRUMENTS[key] + root + '/' + noteOrChord + '.mp3';
    bufferKey = filePath; // Usa o caminho completo como chave
  }
  if (!filePath) return;
  if (state.loadedSamples.has(bufferKey)) return;
  try {
    const response = await fetch(filePath);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const arrayBuffer = await response.arrayBuffer();
    const buffer = await state.audioCtx.decodeAudioData(arrayBuffer);
    if (instrumentType === 'drum') {
      state.buffers.drums[bufferKey] = buffer;
    } else if (instrumentType === 'melodic') {
      state.buffers.melodic[bufferKey] = buffer;
    } else if (instrumentType === 'harmonic') {
      state.buffers.harmonic[bufferKey] = buffer;
    }
    state.loadedSamples.add(bufferKey);
    console.log(`‚úÖ Carregado: ${filePath} ‚Üí chave: ${bufferKey}`);
  } catch (err) {
    console.warn(`‚ö†Ô∏è N√£o encontrado: ${filePath}`);
  }
}
// ===== MODAL DE SELE√á√ÉO =====
function openModal(type, options, targetCell, instrumentKey) {
  state.modal.type = type;
  state.modal.targetCell = targetCell;
  state.modal.instrumentKey = instrumentKey;
  ui.modalTitle.textContent = type === 'harmony' ? 'Selecione um Acorde' : 'Selecione uma Nota';
  ui.modalGrid.innerHTML = '';
  options.forEach(option => {
    const div = document.createElement('div');
    div.className = 'modal-option';
    if (option === 'X') {
      div.classList.add('x');
    }
    div.textContent = option;
    div.addEventListener('click', function() {
      // --- CORRE√á√ÉO AQUI ---
      // 1. Guarda uma refer√™ncia ao bot√£o de delete
      const deleteBtn = targetCell.querySelector('.delete-cell-btn');
      // 2. Remove o bot√£o temporariamente
      if (deleteBtn) {
        targetCell.removeChild(deleteBtn);
      }
      // 3. Define o novo texto da c√©lula
      targetCell.textContent = option;
      // 4. Reaplica a classe 'x' conforme necess√°rio
      if (option === 'X') {
        targetCell.classList.add('x');
      } else {
        targetCell.classList.remove('x');
      }
      // 5. Adiciona o bot√£o de volta
      if (deleteBtn) {
        targetCell.appendChild(deleteBtn);
      }
      // Muta o som anterior
      const category = type === 'harmony' ? 'harmony' : targetCell.parentElement.parentElement.dataset.type.replace('Block', '').toLowerCase();
      if (state.currentlyPlaying[category] !== null) {
        state.currentlyPlaying[category] = null;
      }
      // Carrega a amostra
      if (type === 'harmony') {
        loadSample('harmonic', instrumentKey, option);
      } else {
        loadSample('melodic', instrumentKey, option);
      }
      closeModal();
    });
    ui.modalGrid.appendChild(div);
  });
  ui.selectionModal.style.display = 'flex';
}
function closeModal() {
  ui.selectionModal.style.display = 'none';
  state.modal = {
    targetCell: null,
    type: null,
    instrumentKey: null
  };
}
function addHarmonyBlock() {
  const blockIndex = state.harmonyBlocks.length;
  const wrapper = document.createElement('div');
  wrapper.className = 'instrument-wrapper';
  wrapper.style.display = 'flex';
  wrapper.style.alignItems = 'flex-start';
  wrapper.dataset.blockIndex = blockIndex;

  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.style.width = '120px';
  instrumentSelect.style.marginRight = '10px';
  instrumentSelect.innerHTML = `
    <option value="distorted-guitar">Guitarra Distorcida</option>
    <option value="clean-guitar">Guitarra Limpa</option>
    <option value="piano-chord">Piano</option>
  `;

  const block = document.createElement('div');
  block.className = 'instrument-block harmony-block';
  block.style.flex = '1';
  block.dataset.blockIndex = blockIndex;

  const grid = document.createElement('div');
  grid.className = 'columns-grid';
  grid.dataset.type = 'harmony';
  grid.dataset.blockIndex = blockIndex;
  grid.style.position = 'relative';

  const harmonyBlock = {
    wrapper,
    instrumentSelect,
    grid
  };

  // üîë passa o harmonyBlock inteiro
  for (let i = 0; i < 4; i++) {
    createHarmonyColumn(grid, i, harmonyBlock);
  }

  block.appendChild(grid);
  wrapper.appendChild(instrumentSelect);
  wrapper.appendChild(block);

  addSemibreveMarkers(grid);

  ui.harmonyContainer.appendChild(wrapper);
  state.harmonyBlocks.push(harmonyBlock);
  return wrapper;
}
function createHarmonyColumn(parentGrid, columnIndex, harmonyBlock) {
  const column = document.createElement('div');
  column.className = 'column';
  column.dataset.columnIndex = columnIndex;

  const cell = document.createElement('div');
  cell.className = 'cell x';
  cell.textContent = 'X';

  const deleteCellBtn = document.createElement('button');
  deleteCellBtn.className = 'delete-cell-btn';
  deleteCellBtn.textContent = '‚úñ';
  deleteCellBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    if (confirm('Excluir toda a coluna vertical (inclusive bateria, harmonia e melodias)?')) {
      deleteColumn(columnIndex);
    } else {
      cell.textContent = 'X';
      cell.classList.add('x');
      cell.appendChild(deleteCellBtn);
    }
  });

  cell.appendChild(deleteCellBtn);
  column.appendChild(cell);
  parentGrid.appendChild(column);

  cell.addEventListener('click', function(e) {
    e.stopPropagation();
    const instrumentKey = harmonyBlock.instrumentSelect.value;
    openModal('harmony', AVAILABLE_CHORDS, this, instrumentKey);
  });
}



function addBassBlock() {
  const blockIndex = state.bassBlocks.length;
  const wrapper = document.createElement('div');
  wrapper.className = 'instrument-wrapper';
  wrapper.style.display = 'flex';
  wrapper.style.alignItems = 'flex-start';
  wrapper.dataset.blockIndex = blockIndex;
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.style.width = '120px';
  instrumentSelect.style.marginRight = '10px';
  instrumentSelect.innerHTML = `
    <option value="bass">Baixo</option>   
  `;
  const block = document.createElement('div');
  block.className = 'instrument-block bass-block';
  block.style.flex = '1';
  block.dataset.blockIndex = blockIndex;
  const grid = createMelodicGrid('bass', blockIndex, 4);
  // Adiciona marcadores de sem√≠nima
  addSemibreveMarkers(grid);
  block.appendChild(grid);
  wrapper.appendChild(instrumentSelect);
  wrapper.appendChild(block);
  ui.bassContainer.appendChild(wrapper);
  state.bassBlocks.push(wrapper);
  return wrapper;
}
function addMelody1Block() {
  const blockIndex = state.melody1Blocks.length;
  const wrapper = document.createElement('div');
  wrapper.className = 'instrument-wrapper';
  wrapper.style.display = 'flex';
  wrapper.style.alignItems = 'flex-start';
  wrapper.dataset.blockIndex = blockIndex;
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.style.width = '120px';
  instrumentSelect.style.marginRight = '10px';
  instrumentSelect.innerHTML = `
    <option value="piano">Piano</option>
  <option value="sax">Saxofone</option>
  <option value="acordeon">Acordeon</option>
  <option value="strings">Cordas</option>
  <option value="sinos">Sinos</option> <!-- Adicionado -->
  <option value="acoustic-guitar">Viol√£o A√ßo</option>
  <option value="nylon-guitar">Viol√£o Nylon</option>
  <option value="distorted-guitar-melody">Guitarra Distorcida (Melodia)
  </option>
  `;
  const block = document.createElement('div');
  block.className = 'instrument-block melody1-block';
  block.style.flex = '1';
  block.dataset.blockIndex = blockIndex;
  const grid = createMelodicGrid('melody1', blockIndex, 4);
  // Adiciona marcadores de sem√≠nima
  addSemibreveMarkers(grid);
  block.appendChild(grid);
  wrapper.appendChild(instrumentSelect);
  wrapper.appendChild(block);
  ui.melody1Container.appendChild(wrapper);
  state.melody1Blocks.push(wrapper);
  return wrapper;
}
function addMelody2Block() {
  const blockIndex = state.melody2Blocks.length;
  const wrapper = document.createElement('div');
  wrapper.className = 'instrument-wrapper';
  wrapper.style.display = 'flex';
  wrapper.style.alignItems = 'flex-start';
  wrapper.dataset.blockIndex = blockIndex;
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.style.width = '120px';
  instrumentSelect.style.marginRight = '10px';
  instrumentSelect.innerHTML = `
    <option value="piano">Piano</option>
  <option value="sax">Saxofone</option>
  <option value="acordeon">Acordeon</option>
  <option value="strings">Cordas</option>
  <option value="sinos">Sinos</option> <!-- Adicionado -->
  <option value="acoustic-guitar">Viol√£o A√ßo</option>
  <option value="nylon-guitar">Viol√£o Nylon</option>
  <option value="distorted-guitar-melody">Guitarra Distorcida (Melodia)
  </option>
  `;
  const block = document.createElement('div');
  block.className = 'instrument-block melody2-block';
  block.style.flex = '1';
  block.dataset.blockIndex = blockIndex;
  const grid = createMelodicGrid('melody2', blockIndex, 4);
  // Adiciona marcadores de sem√≠nima
  addSemibreveMarkers(grid);
  block.appendChild(grid);
  wrapper.appendChild(instrumentSelect);
  wrapper.appendChild(block);
  ui.melody2Container.appendChild(wrapper);
  state.melody2Blocks.push(wrapper);
  return wrapper;
}
function addDrumBlock() {
  const blockIndex = state.drumBlocks.length;
  const block = document.createElement('div');
  block.className = 'instrument-block drum-block';
  block.dataset.blockIndex = blockIndex;
  block.style.display = 'flex';
  block.style.alignItems = 'flex-start'; // Alinha ao topo
  // Cria o wrapper principal da bateria (labels + grid)
  const drumWrapper = document.createElement('div');
  drumWrapper.className = 'drum-wrapper';
  drumWrapper.style.position = 'relative';
  // Cria a coluna de r√≥tulos (labels)
  const labelsColumn = document.createElement('div');
  labelsColumn.className = 'drum-labels';
  // Adiciona os r√≥tulos
  DRUM_SAMPLES.forEach(drum => {
    const labelItem = document.createElement('div');
    labelItem.className = 'drum-label-item';
    labelItem.textContent = drum.label;
    labelsColumn.appendChild(labelItem);
  });
  // Cria a grade de colunas (sem os labels internos)
  const grid = document.createElement('div');
  grid.className = 'columns-grid';
  grid.dataset.type = 'drum';
  grid.dataset.blockIndex = blockIndex;
  // Para cada passo (coluna)
  for (let step = 0; step < 4; step++) {
    createDrumColumn(grid, step, blockIndex);
  }
  // Adiciona marcadores de sem√≠nima
  addSemibreveMarkers(grid);
  // Monta a estrutura
  drumWrapper.appendChild(labelsColumn);
  drumWrapper.appendChild(grid);
  block.appendChild(drumWrapper);
  ui.drumContainer.appendChild(block);
  state.drumBlocks.push(block);
  return block;
}
function createDrumColumn(parentGrid, stepIndex, blockIndex) {
  const column = document.createElement('div');
  column.className = 'column';
  column.dataset.columnIndex = stepIndex;
  column.style.display = 'flex';
  column.style.flexDirection = 'column';

  DRUM_SAMPLES.forEach((drum) => {
    const cell = document.createElement('div');
    cell.className = 'drum-cell';
    cell.dataset.step = stepIndex;
    cell.dataset.instr = drum.key;
    cell.dataset.block = blockIndex;
    cell.style.height = '45px';
    cell.style.fontSize = '0.7em';

    cell.addEventListener('click', function() {
      this.classList.toggle('active');
      loadSample('drum', drum.key, '');
    });

    const deleteCellBtn = document.createElement('button');
    deleteCellBtn.className = 'delete-cell-btn';
    deleteCellBtn.textContent = '‚úñ';
    deleteCellBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      if (confirm('Excluir toda a coluna vertical (inclusive bateria, harmonia e melodias)?')) {
        deleteColumn(stepIndex);
      } else {
        cell.classList.remove('active');
      }
    });

    cell.appendChild(deleteCellBtn);
    column.appendChild(cell);
  });

  parentGrid.appendChild(column);
}

function createMelodicGrid(type, blockIndex, numColumns) {
  const grid = document.createElement('div');
  grid.className = 'columns-grid';
  grid.dataset.type = type;
  grid.dataset.blockIndex = blockIndex;
  for (let i = 0; i < numColumns; i++) {
    createMelodicColumn(grid, type, i);
  }
  return grid;
}
function createMelodicColumn(parentGrid, type, columnIndex) {
  const column = document.createElement('div');
  column.className = 'column';
  column.dataset.columnIndex = columnIndex;

  const cell = document.createElement('div');
  cell.className = 'cell x';
  cell.textContent = 'X';

  cell.addEventListener('click', function(e) {
    e.stopPropagation();
    const instrumentKey = this.closest('.instrument-block').parentElement.querySelector('.instrument-select').value;
    openModal('melodic', ALL_NOTES, this, instrumentKey);
  });

  const deleteCellBtn = document.createElement('button');
  deleteCellBtn.className = 'delete-cell-btn';
  deleteCellBtn.textContent = '‚úñ';
  deleteCellBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    if (confirm('Excluir toda a coluna vertical (inclusive bateria, harmonia e melodias)?')) {
      deleteColumn(columnIndex);
    } else {
      cell.textContent = 'X';
      cell.classList.add('x');
      cell.appendChild(deleteCellBtn);
    }
  });

  cell.appendChild(deleteCellBtn);
  column.appendChild(cell);
  parentGrid.appendChild(column);
}

// ===== FUN√á√ÉO PARA ADICIONAR MARCADORES DE SEM√çNIMA =====
function addSemibreveMarkers(grid) {
  // Limpa marcadores existentes primeiro
  const existingMarkers = grid.querySelectorAll('.semibreve-marker');
  existingMarkers.forEach(marker => marker.remove());
  
  // Adiciona um marcador a cada 4 colunas
  const columns = grid.querySelectorAll('.column');
  for (let i = 4; i < columns.length; i += 4) {
    const marker = document.createElement('div');
    marker.className = 'semibreve-marker';
    const column = columns[i];
    const columnRect = column.getBoundingClientRect();
    const gridRect = grid.getBoundingClientRect();
    const leftPosition = columnRect.left - gridRect.left;
    marker.style.left = `${leftPosition}px`;
    grid.appendChild(marker);
  }
}
// ===== FUN√á√ÉO PARA EXCLUIR COLUNA =====
function deleteColumn(columnIndex) {
  // Coleta todos os grids: bateria, harmonia e melodias
  const allGrids = [
    ...state.harmonyBlocks.map(hb => hb.grid),
    ...state.bassBlocks.map(b => b.querySelector('.columns-grid')),
    ...state.melody1Blocks.map(m => m.querySelector('.columns-grid')),
    ...state.melody2Blocks.map(m => m.querySelector('.columns-grid')),
    ...state.drumBlocks.map(d => d.querySelector('.columns-grid'))
  ].filter(Boolean); // remove nulos

  // Remove a coluna correspondente em todos os grids
  allGrids.forEach(g => {
    const columns = g.querySelectorAll('.column');
    if (columns[columnIndex]) {
      g.removeChild(columns[columnIndex]);
    }
  });
}


function addCompasso() {
  const newColumnIndex = state.totalSteps;

  // Harmonia
  state.harmonyBlocks.forEach(harmonyBlock => {
    const grid = harmonyBlock.wrapper.querySelector('.columns-grid');
    if (!grid) return;
    createHarmonyColumn(grid, newColumnIndex, harmonyBlock); // ‚Üê Passa harmonyBlock
    // Chama addSemibreveMarkers AP√ìS adicionar a coluna
    addSemibreveMarkers(grid);
  });

  // Baixo, Melodia 1, Melodia 2
  [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach(blocks => {
    blocks.forEach(wrapper => {
      const grid = wrapper.querySelector('.columns-grid');
      if (!grid) return;
      const type = grid.dataset.type;
      createMelodicColumn(grid, type, newColumnIndex);
      addSemibreveMarkers(grid);
    });
  });

  // BATERIA
  state.drumBlocks.forEach(block => {
    const grid = block.querySelector('.columns-grid');
    if (!grid) return;
    createDrumColumn(grid, newColumnIndex, block.dataset.blockIndex);
    addSemibreveMarkers(grid);
  });

  state.totalSteps += 1;
  updateStatus(`Compasso adicionado. Total: ${state.totalSteps} passos.`, 'ready');
}
// ===== FUN√á√ÉO AUXILIAR: Obt√©m o valor da nota ou acorde da c√©lula =====
function getCellNoteValue(cellElement) {
  // L√™ o primeiro n√≥ de texto da c√©lula, ignorando o bot√£o
  for (let node of cellElement.childNodes) {
    if (node.nodeType === Node.TEXT_NODE) {
      return node.textContent.trim();
    }
  }
  return 'X'; // valor padr√£o de fallback
}

// ===== PLAYBACK =====
function buildPlaybackPlan() {
  const plan = {
    harmony: [],
    bass: [],
    melody1: [],
    melody2: [],
    drums: {}
  };

  // Inicializa os arrays de cada pe√ßa de bateria
  DRUM_SAMPLES.forEach(d => plan.drums[d.key] = []);

  // --- CORRE√á√ÉO DEFINITIVA: Coleta todas as colunas da Harmonia ---
state.harmonyBlocks.forEach(harmonyBlock => {
  const grid = harmonyBlock.grid;
  const instrument = harmonyBlock.instrumentSelect.value;
  const columns = grid.querySelectorAll('.column');
  columns.forEach(column => {
    const cell = column.querySelector('.cell');
    const chordValue = getCellNoteValue(cell);
    if (chordValue !== 'X') {
      plan.harmony.push({ chord: chordValue, instrument });
    } else {
      plan.harmony.push(null);
    }
  });
});


  // Coleta todas as colunas dos instrumentos mel√≥dicos (Baixo, Melodia 1, Melodia 2)
  [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach((blocks, idx) => {
    const type = ['bass', 'melody1', 'melody2'][idx];
    blocks.forEach(wrapper => {
      const block = wrapper.querySelector('.instrument-block');
      const grid = block.querySelector('.columns-grid');
      const columns = grid.querySelectorAll('.column');
      // O seletor de instrumento est√° no wrapper pai
      const instrumentSelect = wrapper.querySelector('.instrument-select');
      const instrument = instrumentSelect ? instrumentSelect.value : 'piano';
      columns.forEach(column => {
        const cell = column.querySelector('.cell');
        const noteValue = getCellNoteValue(cell);
        if (noteValue === 'X') {
          plan[type].push(null);
        } else {
          plan[type].push({ note: noteValue, instrument: instrument });
        }
      });
    });
  });

  // Coleta as c√©lulas da bateria
  state.drumBlocks.forEach(block => {
    // Navega at√© o .columns-grid dentro do .drum-wrapper, se existir
    const drumWrapper = block.querySelector('.drum-wrapper');
    const grid = drumWrapper ? drumWrapper.querySelector('.columns-grid') : block.querySelector('.columns-grid');
    if (!grid) return;

    const columns = grid.querySelectorAll('.column');
    columns.forEach((column, stepIndex) => {
      DRUM_SAMPLES.forEach(drum => {
        const cell = column.querySelector(`.drum-cell[data-instr="${drum.key}"]`);
        if (cell) {
          plan.drums[drum.key].push(cell.classList.contains('active'));
        }
      });
    });
  });

  // Armazena o plano de playback no estado global
  state.playbackPlan = plan;
  state.stepIndex = 0;
  state.lastNoteTime = 0;
  return plan;
}
function scheduleStep(time) {
  const idx = state.stepIndex;
  const plan = state.playbackPlan;
  if (!plan) return;
  // HARMONIA: MUTE ANTERIOR E TOCA NOVO
  if (idx < plan.harmony.length && plan.harmony[idx]) {
    const item = plan.harmony[idx];
    if (item && item.chord !== 'X') {
      if (state.currentlyPlaying.harmony !== null) {
        state.currentlyPlaying.harmony = null;
      }
      playChord(item.instrument, item.chord, time, state.harmonicGain, 1.0); // ‚Üê DURA√á√ÉO DE 1.0s (sem√≠nima)
      state.currentlyPlaying.harmony = item.chord;
    }
  }
  // BAIXO
  if (idx < plan.bass.length && plan.bass[idx]) {
    const item = plan.bass[idx];
    if (item && item.note) {
      if (state.currentlyPlaying.bass !== null) {
        state.currentlyPlaying.bass = null;
      }
      playNote(item.instrument, item.note, time, state.bassGain, 0.7);
      state.currentlyPlaying.bass = item.note;
    }
  }
  // MELODIA 1
  if (idx < plan.melody1.length && plan.melody1[idx]) {
    const item = plan.melody1[idx];
    if (item && item.note) {
      if (state.currentlyPlaying.melody1 !== null) {
        state.currentlyPlaying.melody1 = null;
      }
      playNote(item.instrument, item.note, time, state.melodyGain, 0.6);
      state.currentlyPlaying.melody1 = item.note;
    }
  }
  // MELODIA 2
  if (idx < plan.melody2.length && plan.melody2[idx]) {
    const item = plan.melody2[idx];
    if (item && item.note) {
      if (state.currentlyPlaying.melody2 !== null) {
        state.currentlyPlaying.melody2 = null;
      }
      playNote(item.instrument, item.note, time, state.melodyGain, 0.6);
      state.currentlyPlaying.melody2 = item.note;
    }
  }
  // BATERIA: N√ÉO MUTA ‚Äî PERMITE SOBREPOSI√á√ÉO NATURAL
  Object.keys(plan.drums).forEach(key => {
    if (idx < plan.drums[key].length && plan.drums[key][idx]) {
      playDrum(key, time, state.drumGain, 1.0); // ‚Üë Ganho aumentado
    }
  });
  state.stepIndex = (state.stepIndex + 1) % state.totalSteps;
}
function playNote(instrumentKey, note, time, gainNode, volume = 1.0) {
  if (!state.audioCtx) return;
  const bufferKey = `melodic-${instrumentKey}-${note}`;
  const buffer = state.buffers.melodic[bufferKey];
  if (!buffer) {
    console.warn(`Sample n√£o encontrado: ${instrumentKey}/${note}`);
    return;
  }
  const source = state.audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(gainNode);
  source.start(time);
  source.stop(time + 0.5); // Semicolcheia = 0.5s
}
function playChord(instrumentKey, chord, time, gainNode, volume = 1.0) {
  if (!state.audioCtx) return;
  if (chord === 'X') return;
  let root;
  if (chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(chord.slice(0, 2))) {
    root = chord.slice(0, 2);
  } else {
    root = chord[0];
  }
  // CORRE√á√ÉO FINAL: Monta o caminho exato do arquivo e usa como chave
  const filePath = HARMONIC_INSTRUMENTS[instrumentKey] + root + '/' + chord + '.mp3';
  const buffer = state.buffers.harmonic[filePath]; // ‚Üê BUSCA PELO CAMINHO COMPLETO
  if (!buffer) {
    console.warn(`Acorde n√£o encontrado: ${filePath}`);
    return;
  }
  const source = state.audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(gainNode);
  source.start(time);
  source.stop(time + 1.0); // Sem√≠nima = 1.0s
}
function playDrum(drumKey, time, gainNode, volume = 1.0) {
  if (!state.audioCtx) return;
  const buffer = state.buffers.drums[drumKey];
  if (!buffer) {
    console.warn(`Sample de bateria n√£o encontrado: ${drumKey}`);
    return;
  }
  const source = state.audioCtx.createBufferSource();
  source.buffer = buffer;
  const gain = state.audioCtx.createGain();
  gain.gain.setValueAtTime(volume, time);
  source.connect(gain);
  gain.connect(gainNode);
  source.start(time);
  // ‚ùå n√£o corta em 0.2s, deixa o sample tocar at√© o fim
}
function startScheduler() {
  state.isPlaying = true;
  ui.btnPlay.textContent = '‚è∏ Pause';
  ui.btnStop.disabled = false;
  function tick() {
    if (!state.isPlaying) return;
    const now = state.audioCtx.currentTime;
    const stepDuration = 60 / state.bpm / 4; // semicolcheia
    const nextStep = state.lastNoteTime + stepDuration;
    if (now >= nextStep) {
      scheduleStep(nextStep);
      state.lastNoteTime = nextStep;
    }
    requestAnimationFrame(tick);
  }
  state.lastNoteTime = state.audioCtx.currentTime;
  tick();
}
// ===== PLAY COM CONTAGEM REGRESSIVA DE 4 COMPASSOS =====
function onPlay() {
  if (!state.audioCtx) {
    updateStatus('Erro: Audio Context n√£o inicializado', 'error');
    return;
  }
  if (state.isPlaying) {
    state.isPlaying = false;
    ui.btnPlay.textContent = '‚ñ∂ Play';
    ui.btnStop.disabled = true;
    return;
  }
  try {
    if (state.audioCtx.state === 'suspended') {
      state.audioCtx.resume();
    }
    buildPlaybackPlan();
    const samplesToLoad = new Set();
    // Harmonia
    state.playbackPlan.harmony.forEach(item => {
      if (item && item.chord !== 'X') {
        let root;
        if (item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))) {
          root = item.chord.slice(0, 2);
        } else {
          root = item.chord[0];
        }
        const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
        samplesToLoad.add(filePath);
      }
    });
    // Mel√≥dicas
    ['bass', 'melody1', 'melody2'].forEach(type => {
      state.playbackPlan[type].forEach(item => {
        if (item && item.note) {
          const bufferKey = `melodic-${item.instrument}-${item.note}`;
          samplesToLoad.add(bufferKey);
        }
      });
    });
    // Bateria ‚Äî usa o key direto (ex: 'ataque'), sem prefixo
    Object.keys(state.playbackPlan.drums).forEach(key => {
      if (state.playbackPlan.drums[key].some(active => active)) {
        samplesToLoad.add(key);
      }
    });
    updateStatus('Carregando amostras... Por favor, aguarde.', 'loading');
    ui.btnSaveWAV.disabled = true;
    ui.countdown.style.display = 'block';
    const promises = Array.from(samplesToLoad).map(bufferKey => {
      if (bufferKey.includes('melodic-')) {
        const parts = bufferKey.split('-');
        const instrumentKey = parts[1];
        const noteOrChord = parts.slice(2).join('-');
        return loadSample('melodic', instrumentKey, noteOrChord);
      } else if (bufferKey.includes('guitarra') || bufferKey.includes('PianoStringChord')) {
        let instrumentKey = '';
        let chord = '';
        if (bufferKey.startsWith('guitarraDistorcao/')) {
          instrumentKey = 'distorted-guitar';
          chord = bufferKey.replace('guitarraDistorcao/', '').replace('.mp3', '').split('/').pop();
        } else if (bufferKey.startsWith('guitarraLimpa/')) {
          instrumentKey = 'clean-guitar';
          chord = bufferKey.replace('guitarraLimpa/', '').replace('.mp3', '').split('/').pop();
        } else if (bufferKey.startsWith('assets/PianoStringChord/')) {
          instrumentKey = 'piano-chord';
          chord = bufferKey.replace('assets/PianoStringChord/', '').replace('.mp3', '').split('/').pop();
        }
        if (instrumentKey && chord) {
          return loadSample('harmonic', instrumentKey, chord);
        } else {
          console.warn('Caminho de acorde inv√°lido:', bufferKey);
          return Promise.resolve();
        }
      } else {
        return loadSample('drum', bufferKey, '');
      }
    });
    Promise.all(promises).then(() => {
      startCountdown();
    }).catch(err => {
      console.error('Erro ao carregar amostras:', err);
      updateStatus('Erro ao carregar amostras. Verifique a conex√£o.', 'error');
    });
  } catch (error) {
    console.error('Erro ao iniciar reprodu√ß√£o:', error);
    updateStatus('Erro ao iniciar: ' + error.message, 'error');
  }
}
function startCountdown() {
  state.countdownActive = true;
  state.countdownValue = 4;
  ui.countdown.textContent = state.countdownValue;
  const sixteenthDur = 60 / state.bpm / 4;
  const beatDuration = sixteenthDur * 4;
  const interval = setInterval(() => {
    state.countdownValue--;
    ui.countdown.textContent = state.countdownValue;
    if (state.countdownValue <= 0) {
      clearInterval(interval);
      ui.countdown.style.display = 'none';
      state.countdownActive = false;
      startScheduler();
      updateStatus('Reproduzindo...', 'ready');
    }
  }, beatDuration * 1000);
}
function onStop() {
  state.isPlaying = false;
  state.stepIndex = 0;
  ui.btnPlay.textContent = '‚ñ∂ Play';
  ui.countdown.style.display = 'none';
  ui.btnStop.disabled = true;
  updateStatus('Reprodu√ß√£o parada', 'ready');
}
// ===== GRAVA√á√ÉO WAV COM BARRA DE PROGRESSO =====
async function renderAndDownloadWAV() {
  if (!state.playbackPlan) {
    alert('Crie alguma m√∫sica primeiro.');
    return;
  }
  updateStatus('Renderizando √°udio...', 'loading');
  ui.btnSaveWAV.disabled = true;
  ui.btnSaveWAV.textContent = '‚è≥ Renderizando...';
  ui.progressContainer.style.display = 'block';
  try {
    const sampleRate = 44100;
    const sixteenthDur = 60 / state.bpm / 4;
    // --- C√ÅLCULO CORRIGIDO DA DURA√á√ÉO ---
    // O √∫ltimo evento significativo termina 1 segundo ap√≥s o √∫ltimo passo (dura√ß√£o do acorde).
    const lastEventTime = (state.totalSteps - 1) * sixteenthDur + 1.0;
    // Adiciona 2 segundos de margem de seguran√ßa total.
    const safeDuration = lastEventTime + 2.0;
    const totalSamples = Math.ceil(safeDuration * sampleRate);
    // --- FIM DO C√ÅLCULO CORRIGIDO ---
    const offlineCtx = new OfflineAudioContext(2, totalSamples, sampleRate);
    const master = offlineCtx.createGain();
    const drumGain = offlineCtx.createGain();
    const bassGain = offlineCtx.createGain();
    const melodyGain = offlineCtx.createGain();
    const harmonicGain = offlineCtx.createGain();
    master.connect(offlineCtx.destination);
    drumGain.connect(master);
    bassGain.connect(master);
    melodyGain.connect(master);
    harmonicGain.connect(master);
    master.gain.value = 0.8;
    drumGain.gain.value = 1.0;
    bassGain.gain.value = 0.5;
    melodyGain.gain.value = 0.5;
    harmonicGain.gain.value = 0.5;
    const totalSteps = state.totalSteps;
    // Fun√ß√£o para atualizar a barra de progresso
    const updateProgress = (currentStep) => {
      const percent = Math.round((currentStep / totalSteps) * 100);
      ui.progressBar.style.width = `${percent}%`;
      ui.progressText.textContent = `${percent}%`;
    };
    for (let step = 0; step < totalSteps; step++) {
      const time = step * sixteenthDur;
      if (step % 10 === 0) {
        updateProgress(step);
      }
      // Harmonia (dura 1.0s)
      if (step < state.playbackPlan.harmony.length && state.playbackPlan.harmony[step]) {
        const item = state.playbackPlan.harmony[step];
        if (item && item.chord !== 'X') {
          let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))
            ? item.chord.slice(0, 2)
            : item.chord[0];
          const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
          const buffer = state.buffers.harmonic[filePath];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(harmonicGain);
            source.start(time);
            source.stop(time + 1.0); // Para no final da sem√≠nima
          }
        }
      }
      // Baixo (dura 0.5s)
      if (step < state.playbackPlan.bass.length && state.playbackPlan.bass[step]) {
        const item = state.playbackPlan.bass[step];
        if (item && item.note) {
          const bufferKey = `melodic-${item.instrument}-${item.note}`;
          const buffer = state.buffers.melodic[bufferKey];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(bassGain);
            source.start(time);
            source.stop(time + 0.5); // Para no final da semicolcheia
          }
        }
      }
      // Melodia 1 & 2 (duram 0.5s)
      [[state.playbackPlan.melody1, melodyGain], [state.playbackPlan.melody2, melodyGain]].forEach(([melody, gain]) => {
        if (step < melody.length && melody[step]) {
          const item = melody[step];
          if (item && item.note) {
            const bufferKey = `melodic-${item.instrument}-${item.note}`;
            const buffer = state.buffers.melodic[bufferKey];
            if (buffer) {
              const source = offlineCtx.createBufferSource();
              source.buffer = buffer;
              source.connect(gain);
              source.start(time);
              source.stop(time + 0.5);
            }
          }
        }
      });
      // Bateria (n√£o para, deixa tocar at√© o fim)
      Object.keys(state.playbackPlan.drums).forEach(key => {
        if (step < state.playbackPlan.drums[key].length && state.playbackPlan.drums[key][step]) {
          const buffer = state.buffers.drums[key];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(drumGain);
            source.start(time);
            // N√£o chamamos source.stop() para permitir o sample tocar naturalmente.
          }
        }
      });
    }
    updateProgress(totalSteps);
    const renderedBuffer = await offlineCtx.startRendering();
    const wavBlob = audioBufferToWav(renderedBuffer);
    const fileName = `jam-on-${new Date().toISOString().slice(0,10)}-${Math.floor(Math.random()*1000)}.wav`;
    downloadBlob(wavBlob, fileName);
    updateStatus('Renderiza√ß√£o conclu√≠da!', 'ready');
  } catch (error) {
    console.error('Erro ao renderizar WAV:', error);
    updateStatus('Erro ao renderizar: ' + error.message, 'error');
  } finally {
    ui.btnSaveWAV.textContent = 'üíæ Salvar como WAV';
    ui.btnSaveWAV.disabled = false;
    ui.progressContainer.style.display = 'none';
  }
}
function audioBufferToWav(buffer) {
  const numOfChan = buffer.numberOfChannels;
  const length = buffer.length * numOfChan * 2 + 44;
  const arrayBuffer = new ArrayBuffer(length);
  const view = new DataView(arrayBuffer);
  const channels = [];
  let i, sample, offset = 0;
  function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }
  writeString(view, 0, 'RIFF');
  view.setUint32(4, length - 8, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numOfChan, true);
  view.setUint32(24, 44100, true);
  view.setUint32(28, 44100 * 2 * numOfChan, true);
  view.setUint16(32, 2 * numOfChan, true);
  view.setUint16(34, 16, true);
  writeString(view, 36, 'data');
  view.setUint32(40, length - 44, true);
  for (i = 0; i < buffer.numberOfChannels; i++) {
    channels.push(buffer.getChannelData(i));
  }
  offset = 44;
  for (i = 0; i < buffer.length; i++) {
    for (let channel = 0; channel < numOfChan; channel++) {
      sample = Math.max(-1, Math.min(1, channels[channel][i]));
      sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF);
      view.setInt16(offset, sample, true);
      offset += 2;
    }
  }
  return new Blob([view], { type: 'audio/wav' });
}
function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.style.display = 'none';
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 100);
}
// ===== INICIALIZAR =====
window.addEventListener('load', initializeApp);
</script>
</body>
</html>
