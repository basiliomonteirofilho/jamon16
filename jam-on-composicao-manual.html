<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Jam On – Composição Manual</title>
  <style>
    /* ===== ESTILO GERAL ===== */
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      background: #121212;
      color: #e0e0e0;
      margin: 0;
      padding: 10px;
      overflow-x: hidden;
    }

    /* ===== ORIENTAÇÃO ===== */
    #orientationOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #121212;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 99999;
      color: #5eead4;
      text-align: center;
      padding: 20px;
    }

    #orientationOverlay h2 {
      font-size: 1.5em;
      margin-bottom: 15px;
    }

    #orientationOverlay p {
      font-size: 1.1em;
      max-width: 300px;
    }

    @media (orientation: portrait) {
      #orientationOverlay {
        display: flex;
      }
      body {
        overflow: hidden;
      }
    }

    @media (orientation: landscape) {
      #orientationOverlay {
        display: none;
      }
    }

    /* ===== RESTANTE DO SEU CSS (SEM ALTERAÇÕES MAIORES) ===== */
    .columns-grid {
      display: flex;
      gap: 2px;
      margin: 10px 0;
      flex-wrap: nowrap;
      padding: 5px 0;
      position: relative;
      overflow-x: auto;
      scroll-behavior: auto;
      -webkit-overflow-scrolling: touch;
    }
    .column {
      flex: 0 0 auto;
    }
    header {
      text-align: center;
      margin-bottom: 15px;
    }
    h1 {
      color: #5eead4;
      font-size: 1.6em;
      margin: 0;
    }
    .pill {
      display: inline-block;
      background: #333;
      color: #aaa;
      font-size: 0.7em;
      padding: 4px 8px;
      border-radius: 12px;
    }
    .card {
      max-width: 1200px;
      margin: 0 auto;
      background: #1e1e1e;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      overflow: hidden;
      padding: 15px;
      text-align: left;
    }
    .section {
      margin: 15px 0;
      padding: 12px;
      border: 1px solid #333;
      border-radius: 8px;
      background: #222;
    }
    .section h3 {
      color: #5eead4;
      margin-top: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 1.2em;
    }
    .add-btn {
      background: #4CAF50;
      color: white;
      font-size: 1.1em;
      padding: 5px 9px;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    .instrument-container {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin: 10px 0;
    }
    .instrument-block {
      background: #2a2a2a;
      padding: 12px;
      border-radius: 8px;
      min-width: 200px;
      position: relative;
    }
    .bass-block { border-left: 4px solid #ffcc00; }
    .melody1-block { border-left: 4px solid #ff6b6b; }
    .melody2-block { border-left: 4px solid #4ecdc4; }
    .drum-block { border-left: 4px solid #8e44ad; }
    .harmony-block { border-left: 4px solid #9b59b6; }

    .cell {
      width: 40px;
      height: 40px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.65em;
      cursor: pointer;
      color: #ccc;
      user-select: none;
      transition: background 0.2s;
      position: relative;
    }
    .cell:hover {
      background: #444;
    }
    .cell.x {
      background: #555;
      color: #888;
      font-weight: bold;
    }

    .delete-cell-btn {
      position: absolute;
      top: -7px;
      right: -7px;
      background: #f44336;
      color: white;
      border: none;
      border-radius: 50%;
      width: 14px;
      height: 14px;
      font-size: 0.55em;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      z-index: 10;
    }
    .delete-cell-btn:hover {
      background: #d32f2f;
    }

    .drum-wrapper {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      width: 100%;
      min-width: 0;
    }
    .drum-labels {
      display: flex;
      flex-direction: column;
      gap: 2px;
      align-items: flex-start;
      justify-content: flex-start;
      padding-top: 5px;
      width: 75px;
      flex-shrink: 0;
    }
    .drum-label-item {
      width: 100%;
      height: 40px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-right: none;
      border-radius: 4px 0 0 4px;
      display: flex;
      align-items: center;
      padding: 0 6px;
      text-align: left;
      font-size: 0.65em;
      color: #ccc;
      box-sizing: border-box;
    }
    .drum-cell {
      width: 40px;
      height: 40px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.65em;
      cursor: pointer;
      color: #ccc;
      transition: background 0.2s;
      position: relative;
    }
    .drum-cell.active {
      background: #5eead4;
      color: #121212;
    }
    .drum-cell:hover {
      background: #444;
    }

    .instrument-select, .chord-select {
      margin: 8px 0;
      padding: 6px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      color: white;
      width: 100%;
      font-size: 0.9em;
    }

    .bpm-control {
      text-align: center;
      margin: 12px 0;
    }
    .bpm-display {
      font-size: 1.3em;
      font-weight: bold;
      color: #5eead4;
      margin: 8px 0;
    }
    .bpm-slider {
      width: 85%;
      margin: 8px auto;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin: 15px 0;
    }
    button {
      padding: 10px 16px;
      border: none;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      font-size: 0.95em;
      transition: opacity 0.2s;
      white-space: nowrap;
    }
    button.primary {
      background: #5eead4;
      color: #121212;
    }
    button.danger {
      background: #f44336;
      color: white;
    }
    button:hover:not(:disabled) {
      opacity: 0.9;
    }

    .loading, .status-indicator, .instructions, .countdown {
      text-align: center;
    }
    .status-indicator {
      padding: 8px;
      margin: 8px 0;
      border-radius: 6px;
    }
    .status-ready { background: #2a4d2a; color: #8eff8e; }
    .status-loading { background: #4d462a; color: #ffe08e; }
    .status-error { background: #4d2a2a; color: #ff8e8e; }

    .instructions {
      font-size: 0.8em;
      color: #aaa;
      margin-top: 6px;
    }
    .countdown {
      font-size: 1.8em;
      color: #ffcc00;
      margin: 15px 0;
      font-weight: bold;
    }

    /* ===== MODAL ===== */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    .modal {
      background: #2a2a2a;
      border: 2px solid #5eead4;
      border-radius: 12px;
      padding: 18px;
      max-width: 90%;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 0 30px rgba(94, 234, 212, 0.5);
    }
    .modal h2 {
      color: #5eead4;
      margin-top: 0;
      text-align: center;
      font-size: 1.3em;
    }
    .modal-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(55px, 1fr));
      gap: 6px;
      margin-top: 15px;
    }
    .modal-option {
      padding: 8px;
      background: #333;
      border: 1px solid #555;
      border-radius: 6px;
      text-align: center;
      cursor: pointer;
      transition: background 0.2s;
      font-size: 0.85em;
    }
    .modal-option:hover {
      background: #444;
    }
    .modal-option.x {
      background: #555;
      color: #888;
    }

    /* ===== PROGRESSO ===== */
    .progress-container {
      width: 90%;
      background: #333;
      border-radius: 4px;
      margin: 10px auto;
      height: 8px;
    }
    .progress-bar {
      height: 100%;
      background: #5eead4;
      border-radius: 4px;
      width: 0%;
      transition: width 0.3s ease;
    }

    /* ===== MEDIDAS ===== */
    .measure-divider {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: rgba(94, 234, 212, 0.6);
      z-index: 10;
      pointer-events: none;
    }

    /* ===== VOLUME ===== */
    .volume-control {
      margin-top: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }
    .volume-label {
      font-size: 0.75em;
      color: #aaa;
    }
    .volume-slider {
      width: 70px;
      height: 5px;
    }
    .drum-volume-slider {
      height: 4px;
    }

    /* ===== MAPA DE EDIÇÃO ===== */
    .edit-map-container {
      position: fixed;
      top: 15px;
      right: 15px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 12px;
      max-height: 75vh;
      overflow-y: auto;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5);
      z-index: 1000;
      width: 160px;
      font-size: 0.85em;
    }
    .edit-map-title {
      color: #5eead4;
      font-size: 1em;
      margin: 0 0 10px 0;
      text-align: center;
    }
    .edit-map-item {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
      padding: 5px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .edit-map-item:hover {
      background: #3a3a3a;
    }
    .edit-map-item.active {
      background: #5eead4;
      color: #121212;
      font-weight: bold;
    }
    .edit-map-number {
      font-weight: bold;
      width: 20px;
      text-align: center;
      margin-right: 8px;
      color: #5eead4;
    }
    .edit-map-cells {
      display: flex;
      gap: 1px;
    }
    .edit-map-cell {
      width: 10px;
      height: 10px;
      border: 1px solid #555;
      border-radius: 2px;
      background: #333;
    }
    .edit-map-cell.filled {
      background: #5eead4;
    }
    .edit-map-cell.x {
      background: #555;
    }

    /* ===== AJUSTES FINAIS PARA PAISAGEM EM CELULAR ===== */
    @media (max-height: 500px) and (orientation: landscape) {
      .card {
        padding: 10px;
      }
      .section {
        padding: 8px;
        margin: 10px 0;
      }
      .instrument-block {
        padding: 8px;
      }
      .btn-row button {
        padding: 8px 12px;
        font-size: 0.85em;
      }
    }
  </style>
</head>
<body>
  <!-- OVERLAY DE ORIENTAÇÃO -->
  <div id="orientationOverlay">
    <h2>📱 Modo Paisagem Requerido</h2>
    <p>Por favor, gire seu celular para usar o Jam On em modo horizontal.</p>
  </div>

  <header>
    <h1>Jam On – Composição Manual</h1>
    <div class="pill">Cada célula = colcheia (1/8 da semínima)</div>
  </header>
  <div class="card">
    <div id="statusIndicator" class="status-indicator status-loading">
      Carregando... Clique 8 vezes para preparar o som.
    </div>
    <div class="countdown" id="countdown"></div>
    <div class="section">
      <h3>🎛️ Controle de BPM</h3>
      <div class="bpm-control">
        <div class="bpm-display" id="bpmDisplay">100 BPM</div>
        <input type="range" id="bpmSlider" class="bpm-slider" min="60" max="180" value="100" step="1">
      </div>
    </div>
    <div style="text-align: center; margin: 15px 0;">
      <button id="addCompassoBtn" class="add-btn">+</button>
      <span style="color: #aaa; margin-left: 8px; font-size: 0.85em;">Adicionar compasso em todos os instrumentos</span>
    </div>
    <!-- HARMONIA 1 -->
    <div class="section">
      <h3>🎸 Harmonia 1</h3>
      <div id="harmonyContainer1" class="instrument-container"></div>
    </div>
    <!-- HARMONIA 2 -->
    <div class="section">
      <h3>🎸 Harmonia 2</h3>
      <div id="harmonyContainer2" class="instrument-container"></div>
    </div>
    <!-- HARMONIA 3 -->
    <div class="section">
      <h3>🎸 Harmonia 3</h3>
      <div id="harmonyContainer3" class="instrument-container"></div>
    </div>
    <!-- BAIXO -->
    <div class="section">
      <h3>🎸 Baixo</h3>
      <div id="bassContainer" class="instrument-container"></div>
    </div>
    <!-- MELODIA 1 -->
    <div class="section">
      <h3>🎹 Melodia 1</h3>
      <div id="melody1Container" class="instrument-container"></div>
    </div>
    <!-- MELODIA 2 -->
    <div class="section">
      <h3>🎷 Melodia 2</h3>
      <div id="melody2Container" class="instrument-container"></div>
    </div>
    <!-- BATERIA -->
    <div class="section">
      <h3>🥁 Bateria</h3>
      <div id="drumContainer" class="instrument-container"></div>
    </div>
  </div>
  <div class="btn-row">
    <button id="btnPlay" class="primary" disabled>▶ Play</button>
    <button id="btnStop" class="danger" disabled>⏹ Stop</button>
    <button id="btnSaveWAV" class="primary" disabled>💾 Salvar como WAV</button>
    <button id="btnDuplicate" class="primary">🔁 Duplicar Edição</button>
    <button id="btnClearAll" class="danger">🗑️ Limpar Tudo</button>
  </div>
  <div class="instructions">
    Clique em uma célula para escolher uma nota ou acorde.<br>
    Use "+" para adicionar uma coluna em todos os instrumentos.<br>
    <strong>Clique 8 vezes em qualquer célula para preparar os sons.</strong>
  </div>

  <!-- MODAL -->
  <div id="selectionModal" class="modal-overlay" style="display: none;">
    <div class="modal">
      <h2 id="modalTitle">Selecione uma opção</h2>
      <div id="modalGrid" class="modal-grid"></div>
    </div>
  </div>

  <!-- PROGRESSO -->
  <div id="progressContainer" style="display: none; text-align: center; margin: 15px 0;">
    <div>Renderizando...</div>
    <div class="progress-container">
      <div id="progressBar" class="progress-bar"></div>
    </div>
    <div id="progressText">0%</div>
  </div>

  <!-- MAPA DE EDIÇÃO -->
  <div id="editMapContainer" class="edit-map-container">
    <div class="edit-map-title">Mapa de Edição</div>
    <div id="editMapContent"></div>
  </div>

  <script>
    // ===== SEU CÓDIGO JAVASCRIPT EXATO (SEM ALTERAÇÕES) =====
    // (Todo o script original permanece inalterado aqui)
    // ... [SEU SCRIPT COMPLETO VAI AQUI] ...
    // Para manter a resposta dentro do limite, estou mantendo o script original como está.
    // Você deve colar **seu script original completo** aqui, sem alterações.

    // 👇👇👇 Cole seu script original abaixo desta linha 👇👇👇

    // ===== CONSTANTES =====
    const AVAILABLE_CHORDS = [
      'X',
      'A', 'A11', 'A13', 'A4', 'A45+', 'A5', 'A5+', 'A6', 'A7', 'A75+', 'A9', 'A95+', 'Adim', 
      'Am', 'Am5', 'Am5+', 'Am6', 'Am7', 'Am75+', 'Am9',
      'AS', 'AS11', 'AS13', 'AS4', 'AS45+', 'AS5', 'AS5+', 'AS6', 'AS7', 'AS75+', 'AS9', 'AS95+',
      'ASdim', 'ASm', 'ASm5', 'ASm5+', 'ASm6', 'ASm7', 'ASm75+', 'ASm9',
      'B', 'B11', 'B13', 'B4', 'B45+', 'B5', 'B5+', 'B6', 'B7', 'B75+', 'B9', 'B95+', 'Bdim',
      'Bm', 'Bm5', 'Bm5+', 'Bm6', 'Bm7', 'Bm75+', 'Bm9',
      'C', 'C11', 'C13', 'C4', 'C45+', 'C5', 'C5+', 'C6', 'C7', 'C75+', 'C9', 'C95+', 'Cdim',
      'Cm', 'Cm5', 'Cm5+', 'Cm6', 'Cm7', 'Cm75+', 'Cm9',
      'CS', 'CS11', 'CS13', 'CS4', 'CS45+', 'CS5', 'CS5+', 'CS6', 'CS7', 'CS75+', 'CS9', 'CS95+',
      'CSdim', 'CSm', 'CSm5', 'CSm5+', 'CSm6', 'CSm7', 'CSm75+', 'CSm9',
      'D', 'D11', 'D13', 'D4', 'D45+', 'D5', 'D5+', 'D6', 'D7', 'D75+', 'D9', 'D95+', 'Ddim',
      'Dm', 'Dm5', 'Dm5+', 'Dm6', 'Dm7', 'Dm75+', 'Dm9',
      'E', 'E11', 'E13', 'E4', 'E45+', 'E5', 'E5+', 'E6', 'E7', 'E75+', 'E9', 'E95+', 'Edim',
      'Em', 'Em5', 'Em5+', 'Em6', 'Em7', 'Em75+', 'Em9',
      'DS', 'DS11', 'DS13', 'DS4', 'DS45+', 'DS5', 'DS5+', 'DS6', 'DS7', 'DS75+', 'DS9', 'DS95+',
      'DSdim', 'DSm', 'DSm5', 'DSm5+', 'DSm6', 'DSm7', 'DSm75+', 'DSm9',
      'F', 'F11', 'F13', 'F4', 'F45+', 'F5', 'F5+', 'F6', 'F7', 'F75+', 'F9', 'F95+', 'Fdim',
      'Fm', 'Fm5', 'Fm5+', 'Fm6', 'Fm7', 'Fm75+', 'Fm9',
      'FS', 'FS11', 'FS13', 'FS4', 'FS45+', 'FS5', 'FS5+', 'FS6', 'FS7', 'FS75+', 'FS9', 'FS95+',
      'FSdim', 'FSm', 'FSm5', 'FSm5+', 'FSm6', 'FSm7', 'FSm75+', 'FSm9',
      'G', 'G11', 'G13', 'G4', 'G45+', 'G5', 'G5+', 'G6', 'G7', 'G75+', 'G9', 'G95+', 'Gdim',
      'Gm', 'Gm5', 'Gm5+', 'Gm6', 'Gm7', 'Gm75+', 'Gm9',
      'GS', 'GS11', 'GS13', 'GS4', 'GS45+', 'GS5', 'GS5+', 'GS6', 'GS7', 'GS75+', 'GS9', 'GS95+',
      'GSdim', 'GSm', 'GSm5', 'GSm5+', 'GSm6', 'GSm7', 'GSm75+', 'GSm9'
    ];
    const NOTE_NAMES = [
      'X',
      '10CS.mp3', '11D.mp3', '12DS.mp3', '13E.mp3', '14F.mp3', '15FS.mp3', '16G.mp3', '17GS.mp3', 
      '18A.mp3', '19AS.mp3', '1E.mp3', '20B.mp3', '21C.mp3', '22CS.mp3', '23D.mp3', '24DS.mp3', 
      '25E.mp3', '26F.mp3', '27FS.mp3', '28G.mp3', '29GS.mp3', '2F.mp3', '30A.mp3', '31AS.mp3', 
      '32B.mp3', '33C.mp3', '34CS.mp3', '35D.mp3', '36DS.mp3', '37E.mp3', '38F.mp3', '39FS.mp3', 
      '3FS.mp3', '40G.mp3', '41GS.mp3', '42A.mp3', '43AS.mp3', '44B.mp3', '45C.mp3', '46CS.mp3', 
      '47D.mp3', '48DS.mp3', '49E.mp3', '4G.mp3', '5GS.mp3', '6A.mp3', '7AS.mp3', '8B.mp3', '9C.mp3'
    ];
    const ALL_NOTES = NOTE_NAMES
      .map(name => name.replace('.mp3', ''))
      .sort((a, b) => {
        if (a === 'X') return -1;
        if (b === 'X') return 1;
        const numA = parseInt(a.match(/^\d+/)[0]);
        const numB = parseInt(b.match(/^\d+/)[0]);
        return numA - numB;
      });
    const NOTE_FREQ = {
      'C': 261.63, 'CS': 277.18, 'D': 293.66, 'DS': 311.13, 'E': 329.63, 'F': 349.23,
      'FS': 369.99, 'G': 392.00, 'GS': 415.30, 'A': 440.00, 'AS': 466.16, 'B': 493.88
    };
    const MELODIC_INSTRUMENTS = {
      'acordeon': 'assets/AcordeonMelodia/',
      'bass': 'assets/BaixoMelodia/',
      'strings': 'assets/Cordas/',
      'piano': 'assets/PianoString/',
      'sax': 'assets/SaxMelodia/',
      'sinos': 'assets/SinosMelodia/',
      'acoustic-guitar': 'assets/ViolaoAcoMelodia/',
      'nylon-guitar': 'assets/ViolaoNylonMelodia/',
      'distorted-guitar-melody': 'guitarraDistorcao/Melodia/'
    };
    const HARMONIC_INSTRUMENTS = {
      'distorted-guitar': 'guitarraDistorcao/',
      'clean-guitar': 'guitarraLimpa/',
      'piano-chord': 'assets/PianoStringChord/',
      'muted-distorted-guitar': 'guitarraDistorcao/abafadas/'
    };
    const DRUM_SAMPLES = [
      { key: 'ataque', label: 'Prato De Ataque', path: 'assets/ataque.mp3' },
      { key: 'bumbo', label: 'Bumbo', path: 'assets/bumbo.mp3' },
      { key: 'caixa', label: 'Caixa', path: 'assets/caixa.mp3' },
      { key: 'chimbal', label: 'Chimbal Fechado', path: 'assets/chimbal.mp3' },
      { key: 'chimbal-aberto', label: 'Chimbal Aberto', path: 'assets/chimbal-aberto.mp3' },
      { key: 'conducao', label: 'Condução', path: 'assets/conducao.mp3' },
      { key: 'conducao-centro', label: 'Condução Centro', path: 'assets/conducao-centro.mp3' },
      { key: 'surdo', label: 'Surdo', path: 'assets/surdo.mp3' },
      { key: 'tom-1', label: 'Tom 1', path: 'assets/tom-1.mp3' },
      { key: 'tom-2', label: 'Tom 2', path: 'assets/tom-2.mp3' }
    ];
    // ===== ESTADO =====
    const state = {
      running: false,
      paused: false,
      bpm: 100,
      stepIndex: 0,
      totalSteps: 8,
      buffers: {
        drums: {},
        melodic: {},
        harmonic: {}
      },
      loadedSamples: new Set(),
      activeInput: null,
      schedulerTimer: null,
      harmonyBlocks: [[], [], []],
      bassBlocks: [],
      melody1Blocks: [],
      melody2Blocks: [],
      drumBlocks: [],
      lastNoteTime: 0,
      recordedChunks: [],
      audioCtx: null,
      isPlaying: false,
      isRendering: false,
      countdownActive: false,
      countdownValue: 4,
      currentlyPlaying: { 
        bass: null,
        melody1: null,
        melody2: null,
        harmony1: null,
        harmony2: null,
        harmony3: null
      },
      playbackPlan: null,
      modal: {
        targetCell: null,
        type: null,
        instrumentKey: null
      },
      scrollContainers: [],
      scrollHandler: null
    };
    // ===== ELEMENTOS =====
    const ui = {
      statusIndicator: document.getElementById('statusIndicator'),
      countdown: document.getElementById('countdown'),
      bpmSlider: document.getElementById('bpmSlider'),
      bpmDisplay: document.getElementById('bpmDisplay'),
      btnPlay: document.getElementById('btnPlay'),
      btnStop: document.getElementById('btnStop'),
      btnSaveWAV: document.getElementById('btnSaveWAV'),
      addCompassoBtn: document.getElementById('addCompassoBtn'),
      harmonyContainer1: document.getElementById('harmonyContainer1'),
      harmonyContainer2: document.getElementById('harmonyContainer2'),
      harmonyContainer3: document.getElementById('harmonyContainer3'),
      bassContainer: document.getElementById('bassContainer'),
      melody1Container: document.getElementById('melody1Container'),
      melody2Container: document.getElementById('melody2Container'),
      drumContainer: document.getElementById('drumContainer'),
      selectionModal: document.getElementById('selectionModal'),
      modalTitle: document.getElementById('modalTitle'),
      modalGrid: document.getElementById('modalGrid'),
      progressContainer: document.getElementById('progressContainer'),
      progressBar: document.getElementById('progressBar'),
      progressText: document.getElementById('progressText')
    };
    // ===== FUNÇÕES AUXILIARES =====
    function createVolumeControl() {
      const container = document.createElement('div');
      container.className = 'volume-control';
      const label = document.createElement('div');
      label.textContent = 'Volume';
      label.style.fontSize = '0.8em';
      label.style.marginBottom = '5px';
      const slider = document.createElement('input');
      slider.type = 'range';
      slider.className = 'volume-slider';
      slider.min = '0';
      slider.max = '1';
      slider.step = '0.01';
      slider.value = '0.5';
      slider.style.transform = 'rotate(-90deg)';
      slider.style.width = '80px';
      container.appendChild(label);
      container.appendChild(slider);
      return container;
    }
    // ===== CRIAÇÃO DE COLUNAS =====
    function createHarmonyColumn(parentGrid, columnIndex, harmonyBlock) {
      const column = document.createElement('div');
      column.className = 'column';
      column.dataset.columnIndex = columnIndex;
      const cell = document.createElement('div');
      cell.className = 'cell x';
      cell.textContent = (parseInt(column.dataset.columnIndex) % state.totalSteps) + 1;
      const deleteCellBtn = document.createElement('button');
      deleteCellBtn.className = 'delete-cell-btn';
      deleteCellBtn.textContent = '✖';
      deleteCellBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        if (confirm('Excluir toda a coluna vertical (inclusive bateria, harmonia e melodias)?')) {
          deleteColumn(columnIndex);
        } else {
          cell.textContent = columnIndex + 1;
          cell.classList.add('x');
          cell.appendChild(deleteCellBtn);
        }
      });
      cell.appendChild(deleteCellBtn);
      column.appendChild(cell);
      parentGrid.appendChild(column);
      cell.addEventListener('click', function(e) {
        e.stopPropagation();
        const instrumentKey = harmonyBlock.instrumentSelect.value;
        openModal('harmony', AVAILABLE_CHORDS, this, instrumentKey);
      });
    }
    function createMelodicColumn(parentGrid, type, columnIndex) {
      const column = document.createElement('div');
      column.className = 'column';
      column.dataset.columnIndex = columnIndex;
      const cell = document.createElement('div');
      cell.className = 'cell x';
      cell.textContent = columnIndex + 1;
      cell.addEventListener('click', function(e) {
        e.stopPropagation();
        const instrumentKey = this.closest('.instrument-block').parentElement.querySelector('.instrument-select').value;
        openModal('melodic', ALL_NOTES, this, instrumentKey);
      });
      const deleteCellBtn = document.createElement('button');
      deleteCellBtn.className = 'delete-cell-btn';
      deleteCellBtn.textContent = '✖';
      deleteCellBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        if (confirm('Excluir toda a coluna vertical?')) {
          deleteColumn(columnIndex);
        } else {
          cell.textContent = columnIndex + 1;
          cell.classList.add('x');
          cell.appendChild(deleteCellBtn);
        }
      });
      cell.appendChild(deleteCellBtn);
      column.appendChild(cell);
      parentGrid.appendChild(column);
    }
    function createDrumColumn(parentGrid, stepIndex, blockIndex) {
      const column = document.createElement('div');
      column.className = 'column';
      column.dataset.columnIndex = stepIndex;
      DRUM_SAMPLES.forEach((drum, drumIndex) => {
        const cell = document.createElement('div');
        cell.className = 'drum-cell';
        cell.dataset.step = stepIndex;
        cell.dataset.instr = drum.key;
        cell.dataset.block = blockIndex;
        cell.style.height = '45px';
        cell.style.fontSize = '0.7em';
        cell.textContent = stepIndex + 1;
        cell.addEventListener('click', function() {
          this.classList.toggle('active');
          loadSample('drum', drum.key, '');
        });
        if (drumIndex === 0) {
          const deleteCellBtn = document.createElement('button');
          deleteCellBtn.className = 'delete-cell-btn';
          deleteCellBtn.textContent = '✖';
          deleteCellBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            if (confirm('Excluir toda a coluna vertical?')) {
              deleteColumn(stepIndex);
            }
          });
          cell.appendChild(deleteCellBtn);
        }
        column.appendChild(cell);
      });
      parentGrid.appendChild(column);
    }
    function addHarmonyBlock(containerIndex) {
      const blockIndex = state.harmonyBlocks[containerIndex].length;
      const wrapper = document.createElement('div');
      wrapper.className = 'instrument-wrapper';
      wrapper.style.display = 'flex';
      wrapper.style.alignItems = 'flex-start';
      wrapper.dataset.blockIndex = blockIndex;
      wrapper.dataset.containerIndex = containerIndex;
      const instrumentSelect = document.createElement('select');
      instrumentSelect.className = 'instrument-select';
      instrumentSelect.style.width = '140px';
      instrumentSelect.style.marginRight = '10px';
      instrumentSelect.innerHTML = `
        <option value="distorted-guitar">Guitarra Distorcida</option>
        <option value="muted-distorted-guitar">Guitarra Abafada</option>
        <option value="clean-guitar">Guitarra Limpa</option>
        <option value="piano-chord">Piano</option>
      `;
      const block = document.createElement('div');
      block.className = 'instrument-block harmony-block';
      block.style.flex = '1';
      block.dataset.blockIndex = blockIndex;
      block.dataset.containerIndex = containerIndex;
      const grid = document.createElement('div');
      grid.className = 'columns-grid';
      grid.dataset.type = 'harmony';
      grid.dataset.blockIndex = blockIndex;
      grid.dataset.containerIndex = containerIndex;
      grid.style.position = 'relative';
      for (let i = 0; i < 8; i++) {
        createHarmonyColumn(grid, i, { instrumentSelect, grid });
      }
      block.appendChild(grid);
      const volumeControl = createVolumeControl();
      block.appendChild(volumeControl);
      grid._volumeSlider = volumeControl.querySelector('.volume-slider');
      wrapper.appendChild(instrumentSelect);
      wrapper.appendChild(block);
      const containerId = `harmonyContainer${containerIndex + 1}`;
      document.getElementById(containerId).appendChild(wrapper);
      state.harmonyBlocks[containerIndex].push({ wrapper, instrumentSelect, grid, containerIndex });
      return wrapper;
    }
    function addBassBlock() {
      const blockIndex = state.bassBlocks.length;
      const wrapper = document.createElement('div');
      wrapper.className = 'instrument-wrapper';
      wrapper.style.display = 'flex';
      wrapper.style.alignItems = 'flex-start';
      wrapper.dataset.blockIndex = blockIndex;
      const instrumentSelect = document.createElement('select');
      instrumentSelect.className = 'instrument-select';
      instrumentSelect.style.width = '120px';
      instrumentSelect.style.marginRight = '10px';
      instrumentSelect.innerHTML = `<option value="bass">Baixo</option>`;
      const block = document.createElement('div');
      block.className = 'instrument-block bass-block';
      block.style.flex = '1';
      block.dataset.blockIndex = blockIndex;
      const grid = createMelodicGrid('bass', blockIndex, 8);
      block.appendChild(grid);
      const volumeControl = createVolumeControl();
      block.appendChild(volumeControl);
      grid._volumeSlider = volumeControl.querySelector('.volume-slider');
      wrapper.appendChild(instrumentSelect);
      wrapper.appendChild(block);
      ui.bassContainer.appendChild(wrapper);
      state.bassBlocks.push(wrapper);
      return wrapper;
    }
    function addMelody1Block() {
      return addMelodyBlock('melody1', ui.melody1Container, state.melody1Blocks);
    }
    function addMelody2Block() {
      return addMelodyBlock('melody2', ui.melody2Container, state.melody2Blocks);
    }
    function addMelodyBlock(type, container, stateArray) {
      const blockIndex = stateArray.length;
      const wrapper = document.createElement('div');
      wrapper.className = 'instrument-wrapper';
      wrapper.style.display = 'flex';
      wrapper.style.alignItems = 'flex-start';
      wrapper.dataset.blockIndex = blockIndex;
      const instrumentSelect = document.createElement('select');
      instrumentSelect.className = 'instrument-select';
      instrumentSelect.style.width = '120px';
      instrumentSelect.style.marginRight = '10px';
      instrumentSelect.innerHTML = `
        <option value="piano">Piano</option>
        <option value="sax">Saxofone</option>
        <option value="acordeon">Acordeon</option>
        <option value="strings">Cordas</option>
        <option value="sinos">Sinos</option>
        <option value="acoustic-guitar">Violão Aço</option>
        <option value="nylon-guitar">Violão Nylon</option>
        <option value="distorted-guitar-melody">Guitarra Distorcida (Melodia)</option>
      `;
      const block = document.createElement('div');
      block.className = `instrument-block ${type}-block`;
      block.style.flex = '1';
      block.dataset.blockIndex = blockIndex;
      const grid = createMelodicGrid(type, blockIndex, 8);
      block.appendChild(grid);
      const volumeControl = createVolumeControl();
      block.appendChild(volumeControl);
      grid._volumeSlider = volumeControl.querySelector('.volume-slider');
      wrapper.appendChild(instrumentSelect);
      wrapper.appendChild(block);
      container.appendChild(wrapper);
      stateArray.push(wrapper);
      return wrapper;
    }
    function addDrumBlock() {
      const blockIndex = state.drumBlocks.length;
      const block = document.createElement('div');
      block.className = 'instrument-block drum-block';
      block.dataset.blockIndex = blockIndex;
      block.style.display = 'flex';
      block.style.alignItems = 'flex-start';
      const drumWrapper = document.createElement('div');
      drumWrapper.className = 'drum-wrapper';
      drumWrapper.style.position = 'relative';
      drumWrapper.style.alignItems = 'flex-start';
      const labelsColumn = document.createElement('div');
      labelsColumn.className = 'drum-labels';
      const volumeColumn = document.createElement('div');
      volumeColumn.className = 'drum-labels';
      volumeColumn.style.width = '80px';
      DRUM_SAMPLES.forEach(drum => {
        const labelItem = document.createElement('div');
        labelItem.className = 'drum-label-item';
        labelItem.textContent = drum.label;
        labelsColumn.appendChild(labelItem);
        const volumeItem = document.createElement('div');
        volumeItem.style.height = '45px';
        volumeItem.style.display = 'flex';
        volumeItem.style.alignItems = 'center';
        volumeItem.style.padding = '0 5px';
        volumeItem.style.boxSizing = 'border-box';
        const volumeSlider = document.createElement('input');
        volumeSlider.type = 'range';
        volumeSlider.className = 'volume-slider drum-volume-slider';
        volumeSlider.min = '0';
        volumeSlider.max = '1';
        volumeSlider.step = '0.01';
        volumeSlider.value = '1.0';
        volumeSlider.dataset.drumKey = drum.key;
        volumeSlider.style.width = '100%';
        if (!window.drumVolumeSliders) window.drumVolumeSliders = {};
        window.drumVolumeSliders[drum.key] = volumeSlider;
        volumeItem.appendChild(volumeSlider);
        volumeColumn.appendChild(volumeItem);
      });
      const grid = document.createElement('div');
      grid.className = 'columns-grid';
      grid.dataset.type = 'drum';
      grid.dataset.blockIndex = blockIndex;
      for (let step = 0; step < 8; step++) {
        createDrumColumn(grid, step, blockIndex);
      }
      drumWrapper.appendChild(labelsColumn);
      drumWrapper.appendChild(volumeColumn);
      drumWrapper.appendChild(grid);
      block.appendChild(drumWrapper);
      ui.drumContainer.appendChild(block);
      state.drumBlocks.push(block);
      return block;
    }
    function createMelodicGrid(type, blockIndex, numColumns) {
      const grid = document.createElement('div');
      grid.className = 'columns-grid';
      grid.dataset.type = type;
      grid.dataset.blockIndex = blockIndex;
      for (let i = 0; i < numColumns; i++) {
        createMelodicColumn(grid, type, i);
      }
      return grid;
    }
    // ===== EXCLUSÃO DE COLUNA =====
    function deleteColumn(columnIndex) {
      const allGrids = [
        ...state.harmonyBlocks[0].map(hb => hb.grid),
        ...state.harmonyBlocks[1].map(hb => hb.grid),
        ...state.harmonyBlocks[2].map(hb => hb.grid),
        ...state.bassBlocks.map(b => b.querySelector('.columns-grid')),
        ...state.melody1Blocks.map(m => m.querySelector('.columns-grid')),
        ...state.melody2Blocks.map(m => m.querySelector('.columns-grid')),
        ...state.drumBlocks.map(d => d.querySelector('.columns-grid'))
      ].filter(Boolean);
      allGrids.forEach(g => {
        const columns = g.querySelectorAll('.column');
        if (columns[columnIndex]) {
          g.removeChild(columns[columnIndex]);
        }
      });
      state.totalSteps -= 1;
      updateEditMap();
      updateMeasureDividers();
    }
    // ===== ADIÇÃO DE COMPASSO =====
    function addCompasso() {
      const newColumnIndex = state.totalSteps;
      for (let containerIndex = 0; containerIndex < 3; containerIndex++) {
        state.harmonyBlocks[containerIndex].forEach(harmonyBlock => {
          const grid = harmonyBlock.grid;
          if (!grid) return;
          createHarmonyColumn(grid, newColumnIndex, harmonyBlock);
        });
      }
      [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach(blocks => {
        blocks.forEach(wrapper => {
          const grid = wrapper.querySelector('.columns-grid');
          if (!grid) return;
          const type = grid.dataset.type;
          createMelodicColumn(grid, type, newColumnIndex);
        });
      });
      state.drumBlocks.forEach(block => {
        const grid = block.querySelector('.columns-grid');
        if (!grid) return;
        createDrumColumn(grid, newColumnIndex, block.dataset.blockIndex);
      });
      state.totalSteps += 1;
      updateStatus(`Compasso adicionado. Total: ${state.totalSteps} passos.`, 'ready');
      updateEditMap();
      setTimeout(updateMeasureDividers, 0);
      setupScrollSync();
    }
    function updateMeasureDividers() {
      requestAnimationFrame(() => {
        document.querySelectorAll('.measure-divider').forEach(el => el.remove());
        const allGrids = [
          ...document.querySelectorAll('#harmonyContainer1 .columns-grid'),
          ...document.querySelectorAll('#harmonyContainer2 .columns-grid'),
          ...document.querySelectorAll('#harmonyContainer3 .columns-grid'),
          ...document.querySelectorAll('#bassContainer .columns-grid'),
          ...document.querySelectorAll('#melody1Container .columns-grid'),
          ...document.querySelectorAll('#melody2Container .columns-grid'),
          ...document.querySelectorAll('#drumContainer .columns-grid')
        ].filter(Boolean);
        allGrids.forEach(grid => {
          const columns = grid.querySelectorAll('.column');
          let accumulatedWidth = 0;
          for (let i = 0; i < columns.length; i++) {
            const column = columns[i];
            accumulatedWidth += column.offsetWidth;
            if ((i + 1) % 8 === 0) {
              const divider = document.createElement('div');
              divider.className = 'measure-divider';
              divider.style.left = `${accumulatedWidth}px`;
              grid.appendChild(divider);
            }
            if (i < columns.length - 1) {
              accumulatedWidth += 2;
            }
          }
        });
      });
    }
    function setupScrollSync() {
      if (state.scrollHandler) {
        state.scrollContainers.forEach(container => {
          container.removeEventListener('scroll', state.scrollHandler);
        });
      }
      const allGrids = [
        ...document.querySelectorAll('#harmonyContainer1 .columns-grid'),
        ...document.querySelectorAll('#harmonyContainer2 .columns-grid'),
        ...document.querySelectorAll('#harmonyContainer3 .columns-grid'),
        ...document.querySelectorAll('#bassContainer .columns-grid'),
        ...document.querySelectorAll('#melody1Container .columns-grid'),
        ...document.querySelectorAll('#melody2Container .columns-grid'),
        ...document.querySelectorAll('#drumContainer .drum-wrapper .columns-grid')
      ].filter(Boolean);
      state.scrollContainers = allGrids;
      let isSyncing = false;
      const handleScroll = (source) => {
        if (isSyncing) return;
        isSyncing = true;
        const left = source.scrollLeft;
        allGrids.forEach(grid => {
          if (grid !== source) {
            grid.scrollLeft = left;
          }
        });
        requestAnimationFrame(() => {
          isSyncing = false;
        });
      };
      state.scrollHandler = function (e) {
        handleScroll(e.target);
      };
      allGrids.forEach(grid => {
        grid.addEventListener('scroll', state.scrollHandler);
      });
    }
    // ===== RESTANTE DO CÓDIGO (event listeners, playback, etc.) =====
    function initializeApp() {
      updateStatus('Pronto para compor. Clique nas células para criar sua música.', 'ready');
      try {
        state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        state.masterGain = state.audioCtx.createGain();
        state.drumGain = state.audioCtx.createGain();
        state.bassGain = state.audioCtx.createGain();
        state.melodyGain = state.audioCtx.createGain();
        state.harmonicGain = state.audioCtx.createGain();
        state.masterGain.connect(state.audioCtx.destination);
        state.drumGain.connect(state.masterGain);
        state.bassGain.connect(state.masterGain);
        state.melodyGain.connect(state.masterGain);
        state.harmonicGain.connect(state.masterGain);
        state.masterGain.gain.value = 0.8;
        state.drumGain.gain.value = 1.0;
        state.bassGain.gain.value = 0.5;
        state.melodyGain.gain.value = 0.5;
        state.harmonicGain.gain.value = 0.5;
        setupEventListeners();
        state.harmonyBlocks = [[], [], []];
        state.bassBlocks = [];
        state.melody1Blocks = [];
        state.melody2Blocks = [];
        state.drumBlocks = [];
        addHarmonyBlock(0);
        addHarmonyBlock(1);
        addHarmonyBlock(2);
        addBassBlock();
        addMelody1Block();
        addMelody2Block();
        addDrumBlock();
        ui.btnPlay.disabled = false;
        ui.btnSaveWAV.disabled = true;
        ui.btnStop.disabled = true;
        updateStatus('Componha sua música. Clique em Play para iniciar com contagem de 4 compassos.', 'ready');
        updateEditMap();
        setTimeout(updateMeasureDividers, 0);
        setupScrollSync();
      } catch (error) {
        console.error('Erro ao inicializar:', error);
        updateStatus('Erro ao inicializar: ' + error.message, 'error');
      }
    }
    function setupEventListeners() {
      updateBPMDisplay();
      ui.bpmSlider.addEventListener('input', handleBPMChange);
      ui.addCompassoBtn.addEventListener('click', addCompasso);
      ui.btnPlay.addEventListener('click', onPlay);
      ui.btnStop.addEventListener('click', onStop);
      ui.btnSaveWAV.addEventListener('click', () => renderAndDownloadWAV());
      document.getElementById('btnDuplicate').addEventListener('click', duplicateComposition);
      document.getElementById('btnClearAll').addEventListener('click', clearAllComposition);
      ui.selectionModal.addEventListener('click', function(e) {
        if (e.target === this) closeModal();
      });
    }
    // ===== FUNÇÕES AUXILIARES =====
    function handleBPMChange() {
      state.bpm = parseInt(ui.bpmSlider.value);
      updateBPMDisplay();
    }
    function updateBPMDisplay() {
      ui.bpmDisplay.textContent = `${state.bpm} BPM`;
    }
    function updateStatus(message, type) {
      ui.statusIndicator.textContent = message;
      ui.statusIndicator.className = 'status-indicator status-' + type;
    }
    // ===== CARREGAMENTO SOB DEMANDA =====
    async function loadSample(instrumentType, key, noteOrChord) {
      let filePath;
      let bufferKey;
      if (instrumentType === 'drum') {
        const sample = DRUM_SAMPLES.find(d => d.key === key);
        if (!sample) return;
        filePath = sample.path;
        bufferKey = key;
      } else if (instrumentType === 'melodic') {
        if (noteOrChord === 'X') return;
        filePath = MELODIC_INSTRUMENTS[key] + noteOrChord + '.mp3';
        bufferKey = `melodic-${key}-${noteOrChord}`;
      } else if (instrumentType === 'harmonic') {
        if (noteOrChord === 'X') return;
        let root;
        if (noteOrChord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(noteOrChord.slice(0, 2))) {
          root = noteOrChord.slice(0, 2);
        } else {
          root = noteOrChord[0];
        }
        filePath = HARMONIC_INSTRUMENTS[key] + root + '/' + noteOrChord + '.mp3';
        bufferKey = filePath;
      }
      if (!filePath) return;
      if (state.loadedSamples.has(bufferKey)) return;
      try {
        const response = await fetch(filePath);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const arrayBuffer = await response.arrayBuffer();
        const buffer = await state.audioCtx.decodeAudioData(arrayBuffer);
        if (instrumentType === 'drum') {
          state.buffers.drums[bufferKey] = buffer;
        } else if (instrumentType === 'melodic') {
          state.buffers.melodic[bufferKey] = buffer;
        } else if (instrumentType === 'harmonic') {
          state.buffers.harmonic[bufferKey] = buffer;
        }
        state.loadedSamples.add(bufferKey);
        console.log(`✅ Carregado: ${filePath} → chave: ${bufferKey}`);
      } catch (err) {
        console.warn(`⚠️ Não encontrado: ${filePath}`);
      }
    }
    // ===== MODAL =====
    function openModal(type, options, targetCell, instrumentKey) {
      state.modal.type = type;
      state.modal.targetCell = targetCell;
      state.modal.instrumentKey = instrumentKey;
      ui.modalTitle.textContent = type === 'harmony' ? 'Selecione um Acorde' : 'Selecione uma Nota';
      ui.modalGrid.innerHTML = '';
      options.forEach(option => {
        const div = document.createElement('div');
        div.className = 'modal-option';
        if (option === 'X') {
          div.classList.add('x');
        }
        let displayText = option;
        if (option !== 'X') {
          displayText = option.replace(/S/g, '#');
        }
        div.textContent = displayText;
        div.dataset.originalValue = option;
        div.addEventListener('click', function() {
          const originalValue = this.dataset.originalValue;
          const deleteBtn = targetCell.querySelector('.delete-cell-btn');
          if (deleteBtn) targetCell.removeChild(deleteBtn);
          targetCell.textContent = displayText;
          targetCell.dataset.originalValue = originalValue;
          if (originalValue === 'X') {
            targetCell.classList.add('x');
          } else {
            targetCell.classList.remove('x');
          }
          if (deleteBtn) targetCell.appendChild(deleteBtn);
          if (state.currentlyPlaying[type] !== null) {
            state.currentlyPlaying[type] = null;
          }
          if (type === 'harmony') {
            loadSample('harmonic', instrumentKey, originalValue);
          } else {
            loadSample('melodic', instrumentKey, originalValue);
          }
          closeModal();
        });
        ui.modalGrid.appendChild(div);
      });
      ui.selectionModal.style.display = 'flex';
    }
    function closeModal() {
      ui.selectionModal.style.display = 'none';
      state.modal = {
        targetCell: null,
        type: null,
        instrumentKey: null
      };
    }
    // ===== PLAYBACK =====
    function buildPlaybackPlan() {
      const plan = {
        harmony1: [],
        harmony2: [],
        harmony3: [],
        bass: [],
        melody1: [],
        melody2: [],
        drums: {}
      };
      DRUM_SAMPLES.forEach(d => plan.drums[d.key] = []);
      // HARMONIA 1
      state.harmonyBlocks[0].forEach(harmonyBlock => {
        const grid = harmonyBlock.grid;
        const instrument = harmonyBlock.instrumentSelect.value;
        const columns = grid.querySelectorAll('.column');
        columns.forEach(column => {
          const cell = column.querySelector('.cell');
          const chordValue = getCellNoteValue(cell);
          if (chordValue !== 'X') {
            plan.harmony1.push({ chord: chordValue, instrument });
          } else {
            plan.harmony1.push(null);
          }
        });
      });
      // HARMONIA 2
      state.harmonyBlocks[1].forEach(harmonyBlock => {
        const grid = harmonyBlock.grid;
        const instrument = harmonyBlock.instrumentSelect.value;
        const columns = grid.querySelectorAll('.column');
        columns.forEach(column => {
          const cell = column.querySelector('.cell');
          const chordValue = getCellNoteValue(cell);
          if (chordValue !== 'X') {
            plan.harmony2.push({ chord: chordValue, instrument });
          } else {
            plan.harmony2.push(null);
          }
        });
      });
      // HARMONIA 3
      state.harmonyBlocks[2].forEach(harmonyBlock => {
        const grid = harmonyBlock.grid;
        const instrument = harmonyBlock.instrumentSelect.value;
        const columns = grid.querySelectorAll('.column');
        columns.forEach(column => {
          const cell = column.querySelector('.cell');
          const chordValue = getCellNoteValue(cell);
          if (chordValue !== 'X') {
            plan.harmony3.push({ chord: chordValue, instrument });
          } else {
            plan.harmony3.push(null);
          }
        });
      });
      // MELODICOS
      [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach((blocks, idx) => {
        const type = ['bass', 'melody1', 'melody2'][idx];
        blocks.forEach(wrapper => {
          const grid = wrapper.querySelector('.columns-grid');
          const instrumentSelect = wrapper.querySelector('.instrument-select');
          const instrument = instrumentSelect ? instrumentSelect.value : 'piano';
          const columns = grid.querySelectorAll('.column');
          columns.forEach(column => {
            const cell = column.querySelector('.cell');
            const noteValue = getCellNoteValue(cell);
            if (noteValue === 'X') {
              plan[type].push(null);
            } else {
              plan[type].push({ note: noteValue, instrument });
            }
          });
        });
      });
      // BATERIA
      state.drumBlocks.forEach(block => {
        const drumWrapper = block.querySelector('.drum-wrapper');
        const grid = drumWrapper ? drumWrapper.querySelector('.columns-grid') : block.querySelector('.columns-grid');
        if (!grid) return;
        const columns = grid.querySelectorAll('.column');
        columns.forEach((column, stepIndex) => {
          DRUM_SAMPLES.forEach(drum => {
            const cell = column.querySelector(`.drum-cell[data-instr="${drum.key}"]`);
            if (cell) {
              plan.drums[drum.key].push(cell.classList.contains('active'));
            }
          });
        });
      });
      state.playbackPlan = plan;
      state.stepIndex = 0;
      state.lastNoteTime = 0;
      return plan;
    }
    function getCellNoteValue(cellElement) {
      const labels = cellElement.querySelectorAll('.column-number-label');
      labels.forEach(l => l.remove());
      if (cellElement.dataset.originalValue) {
        return cellElement.dataset.originalValue;
      }
      for (let node of cellElement.childNodes) {
        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== '') {
          return node.textContent.trim();
        }
      }
      return 'X';
    }
    function scheduleStep(time) {
      const idx = state.stepIndex;
      const plan = state.playbackPlan;
      if (!plan) return;
      // HARMONIA 1
      if (idx < plan.harmony1.length && plan.harmony1[idx]) {
        const item = plan.harmony1[idx];
        if (item && item.chord !== 'X') {
          if (state.currentlyPlaying.harmony1 !== null) {
            state.currentlyPlaying.harmony1 = null;
          }
          playChord(item.instrument, item.chord, time, state.harmonicGain, 1.0);
          state.currentlyPlaying.harmony1 = item.chord;
        }
      }
      // HARMONIA 2
      if (idx < plan.harmony2.length && plan.harmony2[idx]) {
        const item = plan.harmony2[idx];
        if (item && item.chord !== 'X') {
          if (state.currentlyPlaying.harmony2 !== null) {
            state.currentlyPlaying.harmony2 = null;
          }
          playChord(item.instrument, item.chord, time, state.harmonicGain, 1.0);
          state.currentlyPlaying.harmony2 = item.chord;
        }
      }
      // HARMONIA 3
      if (idx < plan.harmony3.length && plan.harmony3[idx]) {
        const item = plan.harmony3[idx];
        if (item && item.chord !== 'X') {
          if (state.currentlyPlaying.harmony3 !== null) {
            state.currentlyPlaying.harmony3 = null;
          }
          playChord(item.instrument, item.chord, time, state.harmonicGain, 1.0);
          state.currentlyPlaying.harmony3 = item.chord;
        }
      }
      // BAIXO
      if (idx < plan.bass.length && plan.bass[idx]) {
        const item = plan.bass[idx];
        if (item && item.note) {
          if (state.currentlyPlaying.bass !== null) {
            state.currentlyPlaying.bass = null;
          }
          playNote(item.instrument, item.note, time, state.bassGain, 0.7);
          state.currentlyPlaying.bass = item.note;
        }
      }
      // MELODIA 1
      if (idx < plan.melody1.length && plan.melody1[idx]) {
        const item = plan.melody1[idx];
        if (item && item.note) {
          if (state.currentlyPlaying.melody1 !== null) {
            state.currentlyPlaying.melody1 = null;
          }
          playNote(item.instrument, item.note, time, state.melodyGain, 0.6);
          state.currentlyPlaying.melody1 = item.note;
        }
      }
      // MELODIA 2
      if (idx < plan.melody2.length && plan.melody2[idx]) {
        const item = plan.melody2[idx];
        if (item && item.note) {
          if (state.currentlyPlaying.melody2 !== null) {
            state.currentlyPlaying.melody2 = null;
          }
          playNote(item.instrument, item.note, time, state.melodyGain, 0.6);
          state.currentlyPlaying.melody2 = item.note;
        }
      }
      // BATERIA
      Object.keys(plan.drums).forEach(key => {
        if (idx < plan.drums[key].length && plan.drums[key][idx]) {
          playDrum(key, time, state.drumGain, 1.0);
        }
      });
      state.stepIndex = (state.stepIndex + 1) % state.totalSteps;
    }
    function playNote(instrumentKey, note, time, gainNode, volume = 1.0) {
      if (!state.audioCtx) return;
      const bufferKey = `melodic-${instrumentKey}-${note}`;
      const buffer = state.buffers.melodic[bufferKey];
      if (!buffer) {
        console.warn(`Sample não encontrado: ${instrumentKey}/${note}`);
        return;
      }
      const source = state.audioCtx.createBufferSource();
      source.buffer = buffer;
      const activeGrid = gainNode === state.bassGain ? document.querySelector('#bassContainer .columns-grid') :
                         gainNode === state.melodyGain ? document.querySelector('#melody1Container .columns-grid') || document.querySelector('#melody2Container .columns-grid') : null;
      const sliderVolume = activeGrid && activeGrid._volumeSlider ? parseFloat(activeGrid._volumeSlider.value) : 0.5;
      const instrumentGain = state.audioCtx.createGain();
      instrumentGain.gain.setValueAtTime(sliderVolume * volume, time);
      source.connect(instrumentGain);
      instrumentGain.connect(gainNode);
      source.start(time);
      source.stop(time + 0.25);
    }
    function playChord(instrumentKey, chord, time, gainNode, volume = 1.0) {
      if (!state.audioCtx) return;
      if (chord === 'X') return;
      let root;
      if (chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(chord.slice(0, 2))) {
        root = chord.slice(0, 2);
      } else {
        root = chord[0];
      }
      const filePath = HARMONIC_INSTRUMENTS[instrumentKey] + root + '/' + chord + '.mp3';
      const buffer = state.buffers.harmonic[filePath];
      if (!buffer) {
        console.warn(`Acorde não encontrado: ${filePath}`);
        return;
      }
      const source = state.audioCtx.createBufferSource();
      source.buffer = buffer;
      const activeGrid = document.querySelector('#harmonyContainer1 .columns-grid') ||
                         document.querySelector('#harmonyContainer2 .columns-grid') ||
                         document.querySelector('#harmonyContainer3 .columns-grid');
      const sliderVolume = activeGrid && activeGrid._volumeSlider ? parseFloat(activeGrid._volumeSlider.value) : 0.5;
      const instrumentGain = state.audioCtx.createGain();
      instrumentGain.gain.setValueAtTime(sliderVolume * volume, time);
      source.connect(instrumentGain);
      instrumentGain.connect(gainNode);
      source.start(time);
      source.stop(time + 0.5);
    }
    function playDrum(drumKey, time, gainNode, volume = 1.0) {
      if (!state.audioCtx) return;
      const buffer = state.buffers.drums[drumKey];
      if (!buffer) {
        console.warn(`Sample de bateria não encontrado: ${drumKey}`);
        return;
      }
      const source = state.audioCtx.createBufferSource();
      source.buffer = buffer;
      const gain = state.audioCtx.createGain();
      const drumVolumeSlider = window.drumVolumeSliders && window.drumVolumeSliders[drumKey];
      const sliderVolume = drumVolumeSlider ? parseFloat(drumVolumeSlider.value) : 1.0;
      gain.gain.setValueAtTime(sliderVolume * volume, time);
      source.connect(gain);
      gain.connect(gainNode);
      source.start(time);
    }
    // ===== CONTROLE DE REPRODUÇÃO =====
    function onPlay() {
      if (!state.audioCtx) {
        updateStatus('Erro: Audio Context não inicializado', 'error');
        return;
      }
      if (state.isPlaying) {
        state.isPlaying = false;
        ui.btnPlay.textContent = '▶ Play';
        ui.btnStop.disabled = true;
        return;
      }
      try {
        if (state.audioCtx.state === 'suspended') {
          state.audioCtx.resume();
        }
        buildPlaybackPlan();
        const samplesToLoad = new Set();
        // HARMONIA 1
        state.playbackPlan.harmony1.forEach(item => {
          if (item && item.chord !== 'X') {
            let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2)) ? item.chord.slice(0, 2) : item.chord[0];
            const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
            samplesToLoad.add(filePath);
          }
        });
        // HARMONIA 2
        state.playbackPlan.harmony2.forEach(item => {
          if (item && item.chord !== 'X') {
            let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2)) ? item.chord.slice(0, 2) : item.chord[0];
            const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
            samplesToLoad.add(filePath);
          }
        });
        // HARMONIA 3
        state.playbackPlan.harmony3.forEach(item => {
          if (item && item.chord !== 'X') {
            let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2)) ? item.chord.slice(0, 2) : item.chord[0];
            const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
            samplesToLoad.add(filePath);
          }
        });
        // MELODICOS
        ['bass', 'melody1', 'melody2'].forEach(type => {
          state.playbackPlan[type].forEach(item => {
            if (item && item.note) {
              const bufferKey = `melodic-${item.instrument}-${item.note}`;
              samplesToLoad.add(bufferKey);
            }
          });
        });
        // BATERIA
        Object.keys(state.playbackPlan.drums).forEach(key => {
          if (state.playbackPlan.drums[key].some(active => active)) {
            samplesToLoad.add(key);
          }
        });
        updateStatus('Carregando amostras... Por favor, aguarde.', 'loading');
        ui.btnSaveWAV.disabled = true;
        ui.countdown.style.display = 'block';
        const promises = Array.from(samplesToLoad).map(bufferKey => {
          if (bufferKey.includes('melodic-')) {
            const parts = bufferKey.split('-');
            const instrumentKey = parts[1];
            const noteOrChord = parts.slice(2).join('-');
            return loadSample('melodic', instrumentKey, noteOrChord);
          } else if (bufferKey.includes('guitarra') || bufferKey.includes('PianoStringChord')) {
            let instrumentKey = '';
            let chord = '';
            if (bufferKey.startsWith('guitarraDistorcao/')) {
              instrumentKey = 'distorted-guitar';
              chord = bufferKey.replace('guitarraDistorcao/', '').replace('.mp3', '').split('/').pop();
            } else if (bufferKey.startsWith('guitarraLimpa/')) {
              instrumentKey = 'clean-guitar';
              chord = bufferKey.replace('guitarraLimpa/', '').replace('.mp3', '').split('/').pop();
            } else if (bufferKey.startsWith('assets/PianoStringChord/')) {
              instrumentKey = 'piano-chord';
              chord = bufferKey.replace('assets/PianoStringChord/', '').replace('.mp3', '').split('/').pop();
            }
            if (instrumentKey && chord) {
              return loadSample('harmonic', instrumentKey, chord);
            } else {
              console.warn('Caminho de acorde inválido:', bufferKey);
              return Promise.resolve();
            }
          } else {
            return loadSample('drum', bufferKey, '');
          }
        });
        Promise.all(promises).then(() => {
          ui.btnSaveWAV.disabled = false;
          startCountdown();
        }).catch(err => {
          console.error('Erro ao carregar amostras:', err);
          updateStatus('Erro ao carregar amostras. Verifique a conexão.', 'error');
        });
      } catch (error) {
        console.error('Erro ao iniciar reprodução:', error);
        updateStatus('Erro ao iniciar: ' + error.message, 'error');
      }
    }
    function startCountdown() {
      state.countdownActive = true;
      state.countdownValue = 4;
      ui.countdown.textContent = state.countdownValue;
      const eighthDur = 60 / state.bpm / 8;
      const beatDuration = eighthDur * 8;
      const interval = setInterval(() => {
        state.countdownValue--;
        ui.countdown.textContent = state.countdownValue;
        if (state.countdownValue <= 0) {
          clearInterval(interval);
          ui.countdown.style.display = 'none';
          state.countdownActive = false;
          startScheduler();
          updateStatus('Reproduzindo...', 'ready');
        }
      }, beatDuration * 1000);
    }
    function startScheduler() {
      state.isPlaying = true;
      ui.btnPlay.textContent = '⏸ Pause';
      ui.btnStop.disabled = false;
      function tick() {
        if (!state.isPlaying) return;
        const now = state.audioCtx.currentTime;
        const stepDuration = 60 / state.bpm / 8;
        const nextStep = state.lastNoteTime + stepDuration;
        if (now >= nextStep) {
          scheduleStep(nextStep);
          state.lastNoteTime = nextStep;
          updatePlaybackProgress();
        }
        requestAnimationFrame(tick);
      }
      state.lastNoteTime = state.audioCtx.currentTime;
      tick();
    }
    function updatePlaybackProgress() {
      document.querySelectorAll('.cell, .drum-cell').forEach(cell => {
        cell.style.boxShadow = 'none';
      });
      const currentStep = state.stepIndex;
      document.querySelectorAll(`.column:nth-child(${currentStep + 1}) .cell`).forEach(cell => {
        cell.style.boxShadow = '0 0 5px 2px #5eead4';
      });
      document.querySelectorAll(`.column:nth-child(${currentStep + 1}) .drum-cell`).forEach(cell => {
        cell.style.boxShadow = '0 0 5px 2px #5eead4';
      });
      const currentMeasure = Math.floor(currentStep / 8);
      document.querySelectorAll('.edit-map-item').forEach((item, idx) => {
        if (idx === currentMeasure) {
          item.classList.add('active');
        } else {
          item.classList.remove('active');
        }
      });
    }
    function onStop() {
      state.isPlaying = false;
      state.stepIndex = 0;
      ui.btnPlay.textContent = '▶ Play';
      ui.countdown.style.display = 'none';
      ui.btnStop.disabled = true;
      updateStatus('Reprodução parada', 'ready');
    }
    // ===== GRAVAÇÃO WAV =====
    async function renderAndDownloadWAV() {
      if (!state.playbackPlan) {
        alert('Crie alguma música primeiro.');
        return;
      }
      updateStatus('Renderizando áudio...', 'loading');
      ui.btnSaveWAV.disabled = true;
      ui.btnSaveWAV.textContent = '⏳ Renderizando...';
      ui.progressContainer.style.display = 'block';
      try {
        const sampleRate = 44100;
        const eighthDur = 60 / state.bpm / 8;
        const lastEventTime = (state.totalSteps - 1) * eighthDur + 0.5;
        const safeDuration = lastEventTime + 2.0;
        const totalSamples = Math.ceil(safeDuration * sampleRate);
        const offlineCtx = new OfflineAudioContext(2, totalSamples, sampleRate);
        const master = offlineCtx.createGain();
        const drumGain = offlineCtx.createGain();
        const bassGain = offlineCtx.createGain();
        const melodyGain = offlineCtx.createGain();
        const harmonicGain = offlineCtx.createGain();
        master.connect(offlineCtx.destination);
        drumGain.connect(master);
        bassGain.connect(master);
        melodyGain.connect(master);
        harmonicGain.connect(master);
        master.gain.value = 0.8;
        drumGain.gain.value = 1.0;
        bassGain.gain.value = 0.5;
        melodyGain.gain.value = 0.5;
        harmonicGain.gain.value = 0.5;
        const bassInstrumentGain = offlineCtx.createGain();
        const melodyInstrumentGain = offlineCtx.createGain();
        const harmonyInstrumentGain = offlineCtx.createGain();
        const drumInstrumentGains = {};
        DRUM_SAMPLES.forEach(drum => {
          drumInstrumentGains[drum.key] = offlineCtx.createGain();
          drumInstrumentGains[drum.key].connect(drumGain);
        });
        bassInstrumentGain.connect(bassGain);
        melodyInstrumentGain.connect(melodyGain);
        harmonyInstrumentGain.connect(harmonicGain);
        const totalSteps = state.totalSteps;
        const updateProgress = (currentStep) => {
          const percent = Math.round((currentStep / totalSteps) * 100);
          ui.progressBar.style.width = `${percent}%`;
          ui.progressText.textContent = `${percent}%`;
        };
        for (let step = 0; step < totalSteps; step++) {
          const time = step * eighthDur;
          if (step % 10 === 0) {
            updateProgress(step);
          }
          // HARMONIA 1
          if (step < state.playbackPlan.harmony1.length && state.playbackPlan.harmony1[step]) {
            const item = state.playbackPlan.harmony1[step];
            if (item && item.chord !== 'X') {
              let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))
                ? item.chord.slice(0, 2)
                : item.chord[0];
              const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
              const buffer = state.buffers.harmonic[filePath];
              if (buffer) {
                const source = offlineCtx.createBufferSource();
                source.buffer = buffer;
                const harmonyContainer = document.querySelector('#harmonyContainer1');
                const activeGrid = harmonyContainer ? harmonyContainer.querySelector('.columns-grid') : null;
                const sliderVolume = activeGrid && activeGrid._volumeSlider ? parseFloat(activeGrid._volumeSlider.value) : 0.5;
                harmonyInstrumentGain.gain.setValueAtTime(sliderVolume, time);
                source.connect(harmonyInstrumentGain);
                source.start(time);
                source.stop(time + 0.5);
              }
            }
          }
          // HARMONIA 2
          if (step < state.playbackPlan.harmony2.length && state.playbackPlan.harmony2[step]) {
            const item = state.playbackPlan.harmony2[step];
            if (item && item.chord !== 'X') {
              let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))
                ? item.chord.slice(0, 2)
                : item.chord[0];
              const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
              const buffer = state.buffers.harmonic[filePath];
              if (buffer) {
                const source = offlineCtx.createBufferSource();
                source.buffer = buffer;
                const harmonyContainer = document.querySelector('#harmonyContainer2');
                const activeGrid = harmonyContainer ? harmonyContainer.querySelector('.columns-grid') : null;
                const sliderVolume = activeGrid && activeGrid._volumeSlider ? parseFloat(activeGrid._volumeSlider.value) : 0.5;
                harmonyInstrumentGain.gain.setValueAtTime(sliderVolume, time);
                source.connect(harmonyInstrumentGain);
                source.start(time);
                source.stop(time + 0.5);
              }
            }
          }
          // HARMONIA 3
          if (step < state.playbackPlan.harmony3.length && state.playbackPlan.harmony3[step]) {
            const item = state.playbackPlan.harmony3[step];
            if (item && item.chord !== 'X') {
              let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))
                ? item.chord.slice(0, 2)
                : item.chord[0];
              const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
              const buffer = state.buffers.harmonic[filePath];
              if (buffer) {
                const source = offlineCtx.createBufferSource();
                source.buffer = buffer;
                const harmonyContainer = document.querySelector('#harmonyContainer3');
                const activeGrid = harmonyContainer ? harmonyContainer.querySelector('.columns-grid') : null;
                const sliderVolume = activeGrid && activeGrid._volumeSlider ? parseFloat(activeGrid._volumeSlider.value) : 0.5;
                harmonyInstrumentGain.gain.setValueAtTime(sliderVolume, time);
                source.connect(harmonyInstrumentGain);
                source.start(time);
                source.stop(time + 0.5);
              }
            }
          }
          // BAIXO
          if (step < state.playbackPlan.bass.length && state.playbackPlan.bass[step]) {
            const item = state.playbackPlan.bass[step];
            if (item && item.note) {
              const bufferKey = `melodic-${item.instrument}-${item.note}`;
              const buffer = state.buffers.melodic[bufferKey];
              if (buffer) {
                const source = offlineCtx.createBufferSource();
                source.buffer = buffer;
                const bassContainer = document.querySelector('#bassContainer');
                const activeGrid = bassContainer ? bassContainer.querySelector('.columns-grid') : null;
                const sliderVolume = activeGrid && activeGrid._volumeSlider ? parseFloat(activeGrid._volumeSlider.value) : 0.5;
                bassInstrumentGain.gain.setValueAtTime(sliderVolume, time);
                source.connect(bassInstrumentGain);
                source.start(time);
                source.stop(time + 0.25);
              }
            }
          }
          // MELODIA 1 & 2
          [[state.playbackPlan.melody1, melodyGain], [state.playbackPlan.melody2, melodyGain]].forEach(([melody, gain]) => {
            if (step < melody.length && melody[step]) {
              const item = melody[step];
              if (item && item.note) {
                const bufferKey = `melodic-${item.instrument}-${item.note}`;
                const buffer = state.buffers.melodic[bufferKey];
                if (buffer) {
                  const source = offlineCtx.createBufferSource();
                  source.buffer = buffer;
                  const melodyContainer = gain === melodyGain ? (document.querySelector('#melody1Container') || document.querySelector('#melody2Container')) : null;
                  const activeGrid = melodyContainer ? melodyContainer.querySelector('.columns-grid') : null;
                  const sliderVolume = activeGrid && activeGrid._volumeSlider ? parseFloat(activeGrid._volumeSlider.value) : 0.5;
                  melodyInstrumentGain.gain.setValueAtTime(sliderVolume, time);
                  source.connect(melodyInstrumentGain);
                  source.start(time);
                  source.stop(time + 0.25);
                }
              }
            }
          });
          // BATERIA
          Object.keys(state.playbackPlan.drums).forEach(key => {
            if (step < state.playbackPlan.drums[key].length && state.playbackPlan.drums[key][step]) {
              const buffer = state.buffers.drums[key];
              if (buffer) {
                const source = offlineCtx.createBufferSource();
                source.buffer = buffer;
                const drumVolumeSlider = window.drumVolumeSliders && window.drumVolumeSliders[key];
                const sliderVolume = drumVolumeSlider ? parseFloat(drumVolumeSlider.value) : 1.0;
                drumInstrumentGains[key].gain.setValueAtTime(sliderVolume, time);
                source.connect(drumInstrumentGains[key]);
                source.start(time);
              }
            }
          });
        }
        updateProgress(totalSteps);
        const renderedBuffer = await offlineCtx.startRendering();
        const wavBlob = audioBufferToWav(renderedBuffer);
        const fileName = `jam-on-${new Date().toISOString().slice(0,10)}-${Math.floor(Math.random()*1000)}.wav`;
        downloadBlob(wavBlob, fileName);
        updateStatus('Renderização concluída!', 'ready');
      } catch (error) {
        console.error('Erro ao renderizar WAV:', error);
        updateStatus('Erro ao renderizar: ' + error.message, 'error');
      } finally {
        ui.btnSaveWAV.textContent = '💾 Salvar como WAV';
        ui.btnSaveWAV.disabled = false;
        ui.progressContainer.style.display = 'none';
      }
    }
    function audioBufferToWav(buffer) {
      const numOfChan = buffer.numberOfChannels;
      const length = buffer.length * numOfChan * 2 + 44;
      const arrayBuffer = new ArrayBuffer(length);
      const view = new DataView(arrayBuffer);
      const channels = [];
      let i, sample, offset = 0;
      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }
      writeString(view, 0, 'RIFF');
      view.setUint32(4, length - 8, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numOfChan, true);
      view.setUint32(24, 44100, true);
      view.setUint32(28, 44100 * 2 * numOfChan, true);
      view.setUint16(32, 2 * numOfChan, true);
      view.setUint16(34, 16, true);
      writeString(view, 36, 'data');
      view.setUint32(40, length - 44, true);
      for (i = 0; i < buffer.numberOfChannels; i++) {
        channels.push(buffer.getChannelData(i));
      }
      offset = 44;
      for (i = 0; i < buffer.length; i++) {
        for (let channel = 0; channel < numOfChan; channel++) {
          sample = Math.max(-1, Math.min(1, channels[channel][i]));
          sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF);
          view.setInt16(offset, sample, true);
          offset += 2;
        }
      }
      return new Blob([view], { type: 'audio/wav' });
    }
    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    }
    // ===== OUTRAS FUNÇÕES =====
    function duplicateComposition() {
      if (state.totalSteps === 0) {
        alert('Nenhuma composição para duplicar.');
        return;
      }
      const originalTotalSteps = state.totalSteps;
      const newTotalSteps = originalTotalSteps * 2;
      for (let i = 0; i < originalTotalSteps; i++) {
        const newColumnIndex = originalTotalSteps + i;
        // HARMONIA 1, 2, 3
        for (let containerIndex = 0; containerIndex < 3; containerIndex++) {
          state.harmonyBlocks[containerIndex].forEach(harmonyBlock => {
            const grid = harmonyBlock.grid;
            if (!grid) return;
            const instrument = harmonyBlock.instrumentSelect.value;
            const originalColumns = grid.querySelectorAll('.column');
            const originalColumn = originalColumns[i];
            const originalCell = originalColumn ? originalColumn.querySelector('.cell') : null;
            const originalValue = originalCell ? getCellNoteValue(originalCell) : 'X';
            const displayText = (originalValue === 'X') ? 'X' : originalValue.replace(/S/g, '#');
            const isX = originalValue === 'X';
            createHarmonyColumn(grid, newColumnIndex, harmonyBlock);
            const newColumns = grid.querySelectorAll('.column');
            const newColumn = newColumns[newColumnIndex];
            const existingLabel = newColumn.querySelector('.column-top-label');
            if (existingLabel) existingLabel.remove();
            const newCell = newColumn.querySelector('.cell');
            const deleteBtn = newCell.querySelector('.delete-cell-btn');
            if (deleteBtn) newCell.removeChild(deleteBtn);
            newCell.textContent = displayText;
            if (isX) {
              newCell.classList.add('x');
              newCell.removeAttribute('data-original-value');
            } else {
              newCell.classList.remove('x');
              newCell.dataset.originalValue = originalValue;
              loadSample('harmonic', instrument, originalValue);
            }
            if (deleteBtn) newCell.appendChild(deleteBtn);
          });
        }
        // BAIXO, MELODIA 1, MELODIA 2
        [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach(blocks => {
          blocks.forEach(wrapper => {
            const grid = wrapper.querySelector('.columns-grid');
            if (!grid) return;
            const instrumentSelect = wrapper.querySelector('.instrument-select');
            const instrument = instrumentSelect ? instrumentSelect.value : 'piano';
            const originalColumn = grid.querySelector(`.column:nth-child(${i + 1})`);
            const originalCell = originalColumn ? originalColumn.querySelector('.cell') : null;
            const originalValue = originalCell ? getCellNoteValue(originalCell) : 'X';
            const displayText = (originalValue === 'X') ? 'X' : originalValue.replace(/S/g, '#');
            const isX = originalValue === 'X';
            createMelodicColumn(grid, grid.dataset.type, newColumnIndex);
            const columns = grid.querySelectorAll('.column');
            const newColumn = columns[newColumnIndex];
            const newCell = newColumn.querySelector('.cell');
            const deleteBtn = newCell.querySelector('.delete-cell-btn');
            if (deleteBtn) newCell.removeChild(deleteBtn);
            newCell.textContent = displayText;
            if (isX) {
              newCell.classList.add('x');
              newCell.removeAttribute('data-original-value');
            } else {
              newCell.classList.remove('x');
              newCell.dataset.originalValue = originalValue;
              loadSample('melodic', instrument, originalValue);
            }
            if (deleteBtn) newCell.appendChild(deleteBtn);
          });
        });
        // BATERIA
        state.drumBlocks.forEach(block => {
          const drumWrapper = block.querySelector('.drum-wrapper');
          const grid = drumWrapper ? drumWrapper.querySelector('.columns-grid') : block.querySelector('.columns-grid');
          if (!grid) return;
          const originalColumn = grid.querySelector(`.column:nth-child(${i + 1})`);
          createDrumColumn(grid, newColumnIndex, block.dataset.blockIndex);
          const columns = grid.querySelectorAll('.column');
          const newColumn = columns[newColumnIndex];
          DRUM_SAMPLES.forEach(drum => {
            const originalCell = originalColumn ? originalColumn.querySelector(`.drum-cell[data-instr="${drum.key}"]`) : null;
            const newCell = newColumn.querySelector(`.drum-cell[data-instr="${drum.key}"]`);
            if (originalCell && originalCell.classList.contains('active')) {
              newCell.classList.add('active');
              loadSample('drum', drum.key, '');
            } else {
              newCell.classList.remove('active');
            }
          });
        });
      }
      state.totalSteps = newTotalSteps;
      updateStatus(`Composição duplicada. Total: ${state.totalSteps} passos.`, 'ready');
      updateEditMap();
      setTimeout(updateMeasureDividers, 0);
    }
    function clearAllComposition() {
      if (!confirm('Tem certeza? Isso apagará toda a composição atual.')) return;
      state.totalSteps = 8;
      state.harmonyBlocks = [[], [], []];
      state.bassBlocks = [];
      state.melody1Blocks = [];
      state.melody2Blocks = [];
      state.drumBlocks = [];
      ui.harmonyContainer1.innerHTML = '';
      ui.harmonyContainer2.innerHTML = '';
      ui.harmonyContainer3.innerHTML = '';
      ui.bassContainer.innerHTML = '';
      ui.melody1Container.innerHTML = '';
      ui.melody2Container.innerHTML = '';
      ui.drumContainer.innerHTML = '';
      addHarmonyBlock(0);
      addHarmonyBlock(1);
      addHarmonyBlock(2);
      addBassBlock();
      addMelody1Block();
      addMelody2Block();
      addDrumBlock();
      updateEditMap();
      setTimeout(updateMeasureDividers, 0);
      updateStatus('Composição limpa. Pronto para começar do zero.', 'ready');
    }
    function updateEditMap() {
      const mapContent = document.getElementById('editMapContent');
      mapContent.innerHTML = '';
      if (state.totalSteps === 0) return;
      const totalMeasures = Math.ceil(state.totalSteps / 8);
      for (let measureIndex = 0; measureIndex < totalMeasures; measureIndex++) {
        const item = document.createElement('div');
        item.className = 'edit-map-item';
        item.dataset.measureIndex = measureIndex;
        const numberSpan = document.createElement('span');
        numberSpan.className = 'edit-map-number';
        numberSpan.textContent = measureIndex + 1;
        const cellsContainer = document.createElement('div');
        cellsContainer.className = 'edit-map-cells';
        for (let i = 0; i < 8; i++) {
          const cellIndex = measureIndex * 8 + i;
          if (cellIndex >= state.totalSteps) break;
          const cellSpan = document.createElement('span');
          cellSpan.className = 'edit-map-cell';
          let hasContent = false;
          for (let containerIndex = 0; containerIndex < 3; containerIndex++) {
            state.harmonyBlocks[containerIndex].forEach(hb => {
              const grid = hb.grid;
              const column = grid.querySelector(`.column:nth-child(${cellIndex + 1})`);
              if (column) {
                const cell = column.querySelector('.cell');
                if (cell && !cell.classList.contains('x')) {
                  hasContent = true;
                }
              }
            });
          }
          [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach(blocks => {
            blocks.forEach(wrapper => {
              const grid = wrapper.querySelector('.columns-grid');
              const column = grid.querySelector(`.column:nth-child(${cellIndex + 1})`);
              if (column) {
                const cell = column.querySelector('.cell');
                if (cell && !cell.classList.contains('x')) {
                  hasContent = true;
                }
              }
            });
          });
          state.drumBlocks.forEach(block => {
            const drumWrapper = block.querySelector('.drum-wrapper');
            const grid = drumWrapper ? drumWrapper.querySelector('.columns-grid') : block.querySelector('.columns-grid');
            if (grid) {
              const column = grid.querySelector(`.column:nth-child(${cellIndex + 1})`);
              if (column) {
                DRUM_SAMPLES.forEach(drum => {
                  const drumCell = column.querySelector(`.drum-cell[data-instr="${drum.key}"]`);
                  if (drumCell && drumCell.classList.contains('active')) {
                    hasContent = true;
                  }
                });
              }
            }
          });
          if (hasContent) {
            cellSpan.classList.add('filled');
          } else {
            cellSpan.classList.add('x');
          }
          cellsContainer.appendChild(cellSpan);
        }
        item.appendChild(numberSpan);
        item.appendChild(cellsContainer);
        mapContent.appendChild(item);
        item.addEventListener('click', function() {
          const clickedMeasureIndex = parseInt(this.dataset.measureIndex);
          const targetColumnIndex = clickedMeasureIndex * 8;
          document.querySelectorAll('.edit-map-item').forEach(el => el.classList.remove('active'));
          this.classList.add('active');
          const allGrids = [
            ...state.harmonyBlocks[0].map(hb => hb.grid),
            ...state.harmonyBlocks[1].map(hb => hb.grid),
            ...state.harmonyBlocks[2].map(hb => hb.grid),
            ...state.bassBlocks.map(b => b.querySelector('.columns-grid')),
            ...state.melody1Blocks.map(m => m.querySelector('.columns-grid')),
            ...state.melody2Blocks.map(m => m.querySelector('.columns-grid')),
            ...state.drumBlocks.map(d => {
              const dw = d.querySelector('.drum-wrapper');
              return dw ? dw.querySelector('.columns-grid') : d.querySelector('.columns-grid');
            })
          ].filter(Boolean);
          allGrids.forEach(grid => {
            const targetColumn = grid.querySelector(`.column:nth-child(${targetColumnIndex + 1})`);
            if (targetColumn) {
              targetColumn.scrollIntoView({
                behavior: 'smooth',
                block: 'nearest',
                inline: 'start'
              });
            }
          });
        });
      }
    }
    // ===== INICIALIZAR =====
    window.addEventListener('load', initializeApp);
  </script>
</body>
</html>    .pill {
      display: inline-block;
      background: #333;
      color: #aaa;
      font-size: 0.75em;
      padding: 4px 10px;
      border-radius: 12px;
    }
    .card {
      max-width: 1200px;
      margin: 0 auto;
      background: #1e1e1e;
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      overflow: hidden;
      padding: 20px;
      text-align: left;
    }
    .section {
      margin: 25px 0;
      padding: 15px;
      border: 1px solid #333;
      border-radius: 10px;
      background: #222;
    }
    .section h3 {
      color: #5eead4;
      margin-top: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .add-btn {
      background: #4CAF50;
      color: white;
      font-size: 1.2em;
      padding: 6px 10px;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    .instrument-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin: 15px 0;
    }
    .instrument-block {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      min-width: 220px;
      position: relative;
    }
    .bass-block { border-left: 4px solid #ffcc00; }
    .melody1-block { border-left: 4px solid #ff6b6b; }
    .melody2-block { border-left: 4px solid #4ecdc4; }
    .drum-block { border-left: 4px solid #8e44ad; }
    .harmony-block { border-left: 4px solid #9b59b6; }

    .columns-grid {
  display: flex;
  gap: 2px;
  margin: 10px 0;
  flex-wrap: nowrap;
  padding: 5px 0;
  position: relative;
  overflow-x: auto;
  scroll-behavior: smooth;
  -webkit-overflow-scrolling: touch;
}
    .column {
      display: flex;
      flex-direction: column;
      gap: 2px;
      align-items: center;
      background-color: transparent;
    }
    .column:nth-child(8n) {
      background-color: rgba(255, 255, 255, 0.08);
    }
    .cell {
      width: 45px;
      height: 45px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7em;
      cursor: pointer;
      color: #ccc;
      user-select: none;
      transition: background 0.2s;
      position: relative;
    }
    .cell:hover {
      background: #444;
    }
    .cell.x {
      background: #555;
      color: #888;
      font-weight: bold;
    }

    /* Botão de Excluir Célula */
    .delete-cell-btn {
      position: absolute;
      top: -8px;
      right: -8px;
      background: #f44336;
      color: white;
      border: none;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      font-size: 0.6em;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      z-index: 10;
    }
    .delete-cell-btn:hover {
      background: #d32f2f;
    }

    /* ===== ESTILO DA BATERIA ===== */
    .drum-wrapper {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      width: 100%;
      min-width: 0;
    }
    .drum-labels {
      display: flex;
      flex-direction: column;
      gap: 2px;
      align-items: flex-start;
      justify-content: flex-start;
      padding-top: 5px;
      width: 80px;
      flex-shrink: 0;
    }
    .drum-label-item {
      width: 120px;
      height: 45px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-right: none;
      border-radius: 4px 0 0 4px;
      display: flex;
      align-items: center;
      padding: 0 8px;
      text-align: left;
      font-size: 0.7em;
      color: #ccc;
      box-sizing: border-box;
    }
    .drum-cell {
      width: 45px;
      height: 45px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7em;
      cursor: pointer;
      color: #ccc;
      transition: background 0.2s;
      position: relative;
    }
    .drum-cell.active {
      background: #5eead4;
      color: #121212;
    }
    .drum-cell:hover {
      background: #444;
    }

    .instrument-select, .chord-select {
      margin: 10px 0;
      padding: 8px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      color: white;
      width: 100%;
    }
    .bpm-control {
      text-align: center;
      margin: 15px 0;
    }
    .bpm-display {
      font-size: 1.5em;
      font-weight: bold;
      color: #5eead4;
      margin: 10px 0;
    }
    .bpm-slider {
      width: 80%;
      margin: 10px auto;
    }
    .btn-row {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
    }
    button {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      font-size: 1em;
      transition: opacity 0.2s;
    }
    button.primary {
      background: #5eead4;
      color: #121212;
    }
    button.danger {
      background: #f44336;
      color: white;
    }
    button:hover:not(:disabled) {
      opacity: 0.9;
    }
    .loading {
      text-align: center;
      padding: 20px;
      color: #5eead4;
    }
    .status-indicator {
      text-align: center;
      padding: 10px;
      margin: 10px 0;
      border-radius: 6px;
    }
    .status-ready {
      background: #2a4d2a;
      color: #8eff8e;
    }
    .status-loading {
      background: #4d462a;
      color: #ffe08e;
    }
    .status-error {
      background: #4d2a2a;
      color: #ff8e8e;
    }
    .instructions {
      font-size: 0.85em;
      color: #aaa;
      margin-top: 8px;
      text-align: center;
    }
    .countdown {
      font-size: 2em;
      color: #ffcc00;
      text-align: center;
      margin: 20px 0;
      font-weight: bold;
    }

    /* ===== MODAL ===== */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    .modal {
      background: #2a2a2a;
      border: 2px solid #5eead4;
      border-radius: 12px;
      padding: 20px;
      max-width: 90%;
      max-height: 90%;
      overflow-y: auto;
      box-shadow: 0 0 30px rgba(94, 234, 212, 0.5);
    }
    .modal h2 {
      color: #5eead4;
      margin-top: 0;
      text-align: center;
    }
    .modal-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 8px;
      margin-top: 20px;
    }
    .modal-option {
      padding: 10px;
      background: #333;
      border: 1px solid #555;
      border-radius: 6px;
      text-align: center;
      cursor: pointer;
      transition: background 0.2s;
    }
    .modal-option:hover {
      background: #444;
    }
    .modal-option.x {
      background: #555;
      color: #888;
    }

    /* ===== BARRA DE PROGRESSO ===== */
    .progress-container {
      width: 100%;
      background: #333;
      border-radius: 4px;
      margin: 10px 0;
      height: 10px;
    }
    .progress-bar {
      height: 100%;
      background: #5eead4;
      border-radius: 4px;
      width: 0%;
      transition: width 0.3s ease;
    }

    /* ===== LINHA DIVISÓRIA A CADA 8 COLUNAS ===== */
    .measure-divider {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: rgba(94, 234, 212, 0.6);
      z-index: 10;
      pointer-events: none;
    }

    /* ===== VOLUME ===== */
    .volume-control {
      margin-top: 10px;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .volume-label {
      font-size: 0.8em;
      color: #aaa;
    }
    .volume-slider {
      height: 6px;
    }
    .drum-volume-slider {
      height: 4px;
    }

    /* ===== MAPA DE EDIÇÃO ===== */
    .edit-map-container {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 15px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 10px rgba(0,0,0,0.5);
      z-index: 1000;
      width: 200px;
    }
    .edit-map-title {
      color: #5eead4;
      font-size: 1.1em;
      margin: 0 0 15px 0;
      text-align: center;
    }
    .edit-map-item {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      padding: 6px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .edit-map-item:hover {
      background: #3a3a3a;
    }
    .edit-map-item.active {
      background: #5eead4;
      color: #121212;
      font-weight: bold;
    }
    .edit-map-number {
      font-weight: bold;
      width: 25px;
      text-align: center;
      margin-right: 10px;
      color: #5eead4;
    }
    .edit-map-cells {
      display: flex;
      gap: 2px;
    }
    .edit-map-cell {
      width: 12px;
      height: 12px;
      border: 1px solid #555;
      border-radius: 2px;
      background: #333;
    }
    .edit-map-cell.filled {
      background: #5eead4;
    }
    .edit-map-cell.x {
      background: #555;
    }

        @media (max-width: 768px) {
      .cell, .drum-cell { 
        width: 35px;
        height: 35px;
        font-size: 0.6em;
      }
      .drum-label-item { 
        width: 80px;
        font-size: 0.6em; 
        padding: 0 6px;
        height: 35px;
      }
      button { padding: 10px 15px; }
      .add-btn { width: 25px; height: 25px; font-size: 1em; }
      .instrument-block { min-width: 160px; }
      .delete-cell-btn {
        width: 14px;
        height: 14px;
        font-size: 0.5em;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Jam On – Composição Manual</h1>
    <div class="pill">Cada célula = colcheia (1/8 da semínima)</div>
  </header>
  <div class="card">
    <div id="statusIndicator" class="status-indicator status-loading">
      Carregando... Clique 8 vezes para preparar o som.
    </div>
    <div class="countdown" id="countdown"></div>
    <div class="section">
      <h3>🎛️ Controle de BPM</h3>
      <div class="bpm-control">
        <div class="bpm-display" id="bpmDisplay">100 BPM</div>
        <input type="range" id="bpmSlider" class="bpm-slider" min="60" max="180" value="100" step="1">
      </div>
    </div>
    <div style="text-align: center; margin: 20px 0;">
      <button id="addCompassoBtn" class="add-btn">+</button>
      <span style="color: #aaa; margin-left: 10px;">Adicionar compasso em todos os instrumentos</span>
    </div>

    <!-- HARMONIA 1 -->
    <div class="section">
      <h3>🎸 Harmonia 1</h3>
      <div id="harmonyContainer1" class="instrument-container"></div>
    </div>
    <!-- HARMONIA 2 -->
    <div class="section">
      <h3>🎸 Harmonia 2</h3>
      <div id="harmonyContainer2" class="instrument-container"></div>
    </div>
    <!-- HARMONIA 3 -->
    <div class="section">
      <h3>🎸 Harmonia 3</h3>
      <div id="harmonyContainer3" class="instrument-container"></div>
    </div>
    <!-- BAIXO -->
    <div class="section">
      <h3>🎸 Baixo</h3>
      <div id="bassContainer" class="instrument-container"></div>
    </div>
    <!-- MELODIA 1 -->
    <div class="section">
      <h3>🎹 Melodia 1</h3>
      <div id="melody1Container" class="instrument-container"></div>
    </div>
    <!-- MELODIA 2 -->
    <div class="section">
      <h3>🎷 Melodia 2</h3>
      <div id="melody2Container" class="instrument-container"></div>
    </div>
    <!-- BATERIA -->
    <div class="section">
      <h3>🥁 Bateria</h3>
      <div id="drumContainer" class="instrument-container"></div>
    </div>
  </div>

  <div class="btn-row">
    <button id="btnPlay" class="primary" disabled>▶ Play</button>
    <button id="btnStop" class="danger" disabled>⏹ Stop</button>
    <button id="btnSaveWAV" class="primary" disabled>💾 Salvar como WAV</button>
    <button id="btnDuplicate" class="primary">🔁 Duplicar Edição</button>
    <button id="btnClearAll" class="danger">🗑️ Limpar Tudo</button>
  </div>
  <div class="instructions">
    Clique em uma célula para escolher uma nota ou acorde.<br>
    Use "+" para adicionar uma coluna em todos os instrumentos.<br>
    <strong>Clique 8 vezes em qualquer célula para preparar os sons.</strong>
  </div>

  <!-- MODAL -->
  <div id="selectionModal" class="modal-overlay" style="display: none;">
    <div class="modal">
      <h2 id="modalTitle">Selecione uma opção</h2>
      <div id="modalGrid" class="modal-grid"></div>
    </div>
  </div>

  <!-- PROGRESSO -->
  <div id="progressContainer" style="display: none; text-align: center; margin: 20px 0;">
    <div>Renderizando...</div>
    <div class="progress-container">
      <div id="progressBar" class="progress-bar"></div>
    </div>
    <div id="progressText">0%</div>
  </div>
</div>

<!-- MAPA DE EDIÇÃO -->
<div id="editMapContainer" class="edit-map-container">
  <div class="edit-map-title">Mapa de Edição</div>
  <div id="editMapContent"></div>
</div>

<script>
// ===== CONSTANTES =====
const AVAILABLE_CHORDS = [
  'X',
  'A', 'A11', 'A13', 'A4', 'A45+', 'A5', 'A5+', 'A6', 'A7', 'A75+', 'A9', 'A95+', 'Adim', 
  'Am', 'Am5', 'Am5+', 'Am6', 'Am7', 'Am75+', 'Am9',
  'AS', 'AS11', 'AS13', 'AS4', 'AS45+', 'AS5', 'AS5+', 'AS6', 'AS7', 'AS75+', 'AS9', 'AS95+',
  'ASdim', 'ASm', 'ASm5', 'ASm5+', 'ASm6', 'ASm7', 'ASm75+', 'ASm9',
  'B', 'B11', 'B13', 'B4', 'B45+', 'B5', 'B5+', 'B6', 'B7', 'B75+', 'B9', 'B95+', 'Bdim',
  'Bm', 'Bm5', 'Bm5+', 'Bm6', 'Bm7', 'Bm75+', 'Bm9',
  'C', 'C11', 'C13', 'C4', 'C45+', 'C5', 'C5+', 'C6', 'C7', 'C75+', 'C9', 'C95+', 'Cdim',
  'Cm', 'Cm5', 'Cm5+', 'Cm6', 'Cm7', 'Cm75+', 'Cm9',
  'CS', 'CS11', 'CS13', 'CS4', 'CS45+', 'CS5', 'CS5+', 'CS6', 'CS7', 'CS75+', 'CS9', 'CS95+',
  'CSdim', 'CSm', 'CSm5', 'CSm5+', 'CSm6', 'CSm7', 'CSm75+', 'CSm9',
  'D', 'D11', 'D13', 'D4', 'D45+', 'D5', 'D5+', 'D6', 'D7', 'D75+', 'D9', 'D95+', 'Ddim',
  'Dm', 'Dm5', 'Dm5+', 'Dm6', 'Dm7', 'Dm75+', 'Dm9',
  'E', 'E11', 'E13', 'E4', 'E45+', 'E5', 'E5+', 'E6', 'E7', 'E75+', 'E9', 'E95+', 'Edim',
  'Em', 'Em5', 'Em5+', 'Em6', 'Em7', 'Em75+', 'Em9',
  'DS', 'DS11', 'DS13', 'DS4', 'DS45+', 'DS5', 'DS5+', 'DS6', 'DS7', 'DS75+', 'DS9', 'DS95+',
  'DSdim', 'DSm', 'DSm5', 'DSm5+', 'DSm6', 'DSm7', 'DSm75+', 'DSm9',
  'F', 'F11', 'F13', 'F4', 'F45+', 'F5', 'F5+', 'F6', 'F7', 'F75+', 'F9', 'F95+', 'Fdim',
  'Fm', 'Fm5', 'Fm5+', 'Fm6', 'Fm7', 'Fm75+', 'Fm9',
  'FS', 'FS11', 'FS13', 'FS4', 'FS45+', 'FS5', 'FS5+', 'FS6', 'FS7', 'FS75+', 'FS9', 'FS95+',
  'FSdim', 'FSm', 'FSm5', 'FSm5+', 'FSm6', 'FSm7', 'FSm75+', 'FSm9',
  'G', 'G11', 'G13', 'G4', 'G45+', 'G5', 'G5+', 'G6', 'G7', 'G75+', 'G9', 'G95+', 'Gdim',
  'Gm', 'Gm5', 'Gm5+', 'Gm6', 'Gm7', 'Gm75+', 'Gm9',
  'GS', 'GS11', 'GS13', 'GS4', 'GS45+', 'GS5', 'GS5+', 'GS6', 'GS7', 'GS75+', 'GS9', 'GS95+',
  'GSdim', 'GSm', 'GSm5', 'GSm5+', 'GSm6', 'GSm7', 'GSm75+', 'GSm9'
];

const NOTE_NAMES = [
  'X',
  '10CS.mp3', '11D.mp3', '12DS.mp3', '13E.mp3', '14F.mp3', '15FS.mp3', '16G.mp3', '17GS.mp3', 
  '18A.mp3', '19AS.mp3', '1E.mp3', '20B.mp3', '21C.mp3', '22CS.mp3', '23D.mp3', '24DS.mp3', 
  '25E.mp3', '26F.mp3', '27FS.mp3', '28G.mp3', '29GS.mp3', '2F.mp3', '30A.mp3', '31AS.mp3', 
  '32B.mp3', '33C.mp3', '34CS.mp3', '35D.mp3', '36DS.mp3', '37E.mp3', '38F.mp3', '39FS.mp3', 
  '3FS.mp3', '40G.mp3', '41GS.mp3', '42A.mp3', '43AS.mp3', '44B.mp3', '45C.mp3', '46CS.mp3', 
  '47D.mp3', '48DS.mp3', '49E.mp3', '4G.mp3', '5GS.mp3', '6A.mp3', '7AS.mp3', '8B.mp3', '9C.mp3'
];

const ALL_NOTES = NOTE_NAMES
  .map(name => name.replace('.mp3', ''))
  .sort((a, b) => {
    if (a === 'X') return -1;
    if (b === 'X') return 1;
    const numA = parseInt(a.match(/^\d+/)[0]);
    const numB = parseInt(b.match(/^\d+/)[0]);
    return numA - numB;
  });

const NOTE_FREQ = {
  'C': 261.63, 'CS': 277.18, 'D': 293.66, 'DS': 311.13, 'E': 329.63, 'F': 349.23,
  'FS': 369.99, 'G': 392.00, 'GS': 415.30, 'A': 440.00, 'AS': 466.16, 'B': 493.88
};

const MELODIC_INSTRUMENTS = {
  'acordeon': 'assets/AcordeonMelodia/',
  'bass': 'assets/BaixoMelodia/',
  'strings': 'assets/Cordas/',
  'piano': 'assets/PianoString/',
  'sax': 'assets/SaxMelodia/',
  'sinos': 'assets/SinosMelodia/',
  'acoustic-guitar': 'assets/ViolaoAcoMelodia/',
  'nylon-guitar': 'assets/ViolaoNylonMelodia/',
  'distorted-guitar-melody': 'guitarraDistorcao/Melodia/'
};

const HARMONIC_INSTRUMENTS = {
  'distorted-guitar': 'guitarraDistorcao/',
  'clean-guitar': 'guitarraLimpa/',
  'piano-chord': 'assets/PianoStringChord/',
  'muted-distorted-guitar': 'guitarraDistorcao/abafadas/'
};

const DRUM_SAMPLES = [
  { key: 'ataque', label: 'Prato De Ataque', path: 'assets/ataque.mp3' },
  { key: 'bumbo', label: 'Bumbo', path: 'assets/bumbo.mp3' },
  { key: 'caixa', label: 'Caixa', path: 'assets/caixa.mp3' },
  { key: 'chimbal', label: 'Chimbal Fechado', path: 'assets/chimbal.mp3' },
  { key: 'chimbal-aberto', label: 'Chimbal Aberto', path: 'assets/chimbal-aberto.mp3' },
  { key: 'conducao', label: 'Condução', path: 'assets/conducao.mp3' },
  { key: 'conducao-centro', label: 'Condução Centro', path: 'assets/conducao-centro.mp3' },
  { key: 'surdo', label: 'Surdo', path: 'assets/surdo.mp3' },
  { key: 'tom-1', label: 'Tom 1', path: 'assets/tom-1.mp3' },
  { key: 'tom-2', label: 'Tom 2', path: 'assets/tom-2.mp3' }
];

// ===== ESTADO =====
const state = {
  running: false,
  paused: false,
  bpm: 100,
  stepIndex: 0,
  totalSteps: 8,
  buffers: {
    drums: {},
    melodic: {},
    harmonic: {}
  },
  loadedSamples: new Set(),
  activeInput: null,
  schedulerTimer: null,
  harmonyBlocks: [[], [], []],
  bassBlocks: [],
  melody1Blocks: [],
  melody2Blocks: [],
  drumBlocks: [],
  lastNoteTime: 0,
  recordedChunks: [],
  audioCtx: null,
  isPlaying: false,
  isRendering: false,
  countdownActive: false,
  countdownValue: 4,
  currentlyPlaying: { 
    bass: null,
    melody1: null,
    melody2: null,
    harmony1: null,
    harmony2: null,
    harmony3: null
  },
  playbackPlan: null,
  modal: {
    targetCell: null,
    type: null,
    instrumentKey: null
  },
  scrollContainers: [],
  scrollHandler: null
};

// ===== ELEMENTOS =====
const ui = {
  statusIndicator: document.getElementById('statusIndicator'),
  countdown: document.getElementById('countdown'),
  bpmSlider: document.getElementById('bpmSlider'),
  bpmDisplay: document.getElementById('bpmDisplay'),
  btnPlay: document.getElementById('btnPlay'),
  btnStop: document.getElementById('btnStop'),
  btnSaveWAV: document.getElementById('btnSaveWAV'),
  addCompassoBtn: document.getElementById('addCompassoBtn'),
  harmonyContainer1: document.getElementById('harmonyContainer1'),
  harmonyContainer2: document.getElementById('harmonyContainer2'),
  harmonyContainer3: document.getElementById('harmonyContainer3'),
  bassContainer: document.getElementById('bassContainer'),
  melody1Container: document.getElementById('melody1Container'),
  melody2Container: document.getElementById('melody2Container'),
  drumContainer: document.getElementById('drumContainer'),
  selectionModal: document.getElementById('selectionModal'),
  modalTitle: document.getElementById('modalTitle'),
  modalGrid: document.getElementById('modalGrid'),
  progressContainer: document.getElementById('progressContainer'),
  progressBar: document.getElementById('progressBar'),
  progressText: document.getElementById('progressText')
};

// ===== FUNÇÕES AUXILIARES =====
function createVolumeControl() {
  const container = document.createElement('div');
  container.className = 'volume-control';
  const label = document.createElement('div');
  label.textContent = 'Volume';
  label.style.fontSize = '0.8em';
  label.style.marginBottom = '5px';
  const slider = document.createElement('input');
  slider.type = 'range';
  slider.className = 'volume-slider';
  slider.min = '0';
  slider.max = '1';
  slider.step = '0.01';
  slider.value = '0.5';
  slider.style.transform = 'rotate(-90deg)';
  slider.style.width = '80px';
  container.appendChild(label);
  container.appendChild(slider);
  return container;
}


// ===== CRIAÇÃO DE COLUNAS =====
function createHarmonyColumn(parentGrid, columnIndex, harmonyBlock) {
  const column = document.createElement('div');
  column.className = 'column';
  column.dataset.columnIndex = columnIndex;

  const cell = document.createElement('div');
  cell.className = 'cell x';
  cell.textContent = (parseInt(column.dataset.columnIndex) % state.totalSteps) + 1;
  const deleteCellBtn = document.createElement('button');
  deleteCellBtn.className = 'delete-cell-btn';
  deleteCellBtn.textContent = '✖';
  deleteCellBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    if (confirm('Excluir toda a coluna vertical (inclusive bateria, harmonia e melodias)?')) {
      deleteColumn(columnIndex);
    } else {
      cell.textContent = columnIndex + 1;
      cell.classList.add('x');
      cell.appendChild(deleteCellBtn);
    }
  });
  cell.appendChild(deleteCellBtn);
  column.appendChild(cell);
  parentGrid.appendChild(column);
  cell.addEventListener('click', function(e) {
    e.stopPropagation();
    const instrumentKey = harmonyBlock.instrumentSelect.value;
    openModal('harmony', AVAILABLE_CHORDS, this, instrumentKey);
  });
}

function createMelodicColumn(parentGrid, type, columnIndex) {
  const column = document.createElement('div');
  column.className = 'column';
  column.dataset.columnIndex = columnIndex;

  const cell = document.createElement('div');
  cell.className = 'cell x';
  cell.textContent = columnIndex + 1;
  cell.addEventListener('click', function(e) {
    e.stopPropagation();
    const instrumentKey = this.closest('.instrument-block').parentElement.querySelector('.instrument-select').value;
    openModal('melodic', ALL_NOTES, this, instrumentKey);
  });
  const deleteCellBtn = document.createElement('button');
  deleteCellBtn.className = 'delete-cell-btn';
  deleteCellBtn.textContent = '✖';
  deleteCellBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    if (confirm('Excluir toda a coluna vertical?')) {
      deleteColumn(columnIndex);
    } else {
      cell.textContent = columnIndex + 1;
      cell.classList.add('x');
      cell.appendChild(deleteCellBtn);
    }
  });
  cell.appendChild(deleteCellBtn);
  column.appendChild(cell);
  parentGrid.appendChild(column);
}

function createDrumColumn(parentGrid, stepIndex, blockIndex) {
  const column = document.createElement('div');
  column.className = 'column';
  column.dataset.columnIndex = stepIndex;

  DRUM_SAMPLES.forEach((drum, drumIndex) => {
    const cell = document.createElement('div');
    cell.className = 'drum-cell';
    cell.dataset.step = stepIndex;
    cell.dataset.instr = drum.key;
    cell.dataset.block = blockIndex;
    cell.style.height = '45px';
    cell.style.fontSize = '0.7em';
    cell.textContent = stepIndex + 1;
    cell.addEventListener('click', function() {
      this.classList.toggle('active');
      loadSample('drum', drum.key, '');
    });
    if (drumIndex === 0) {
      const deleteCellBtn = document.createElement('button');
      deleteCellBtn.className = 'delete-cell-btn';
      deleteCellBtn.textContent = '✖';
      deleteCellBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        if (confirm('Excluir toda a coluna vertical?')) {
          deleteColumn(stepIndex);
        }
      });
      cell.appendChild(deleteCellBtn);
    }
    column.appendChild(cell);
  });
  parentGrid.appendChild(column);
}

function addHarmonyBlock(containerIndex) {
  const blockIndex = state.harmonyBlocks[containerIndex].length;
  const wrapper = document.createElement('div');
  wrapper.className = 'instrument-wrapper';
  wrapper.style.display = 'flex';
  wrapper.style.alignItems = 'flex-start';
  wrapper.dataset.blockIndex = blockIndex;
  wrapper.dataset.containerIndex = containerIndex;
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.style.width = '140px';
  instrumentSelect.style.marginRight = '10px';
  instrumentSelect.innerHTML = `
    <option value="distorted-guitar">Guitarra Distorcida</option>
    <option value="muted-distorted-guitar">Guitarra Abafada</option>
    <option value="clean-guitar">Guitarra Limpa</option>
    <option value="piano-chord">Piano</option>
  `;
  const block = document.createElement('div');
  block.className = 'instrument-block harmony-block';
  block.style.flex = '1';
  block.dataset.blockIndex = blockIndex;
  block.dataset.containerIndex = containerIndex;

  // REMOVIDO: scrollContainer
  const grid = document.createElement('div');
  grid.className = 'columns-grid';
  grid.dataset.type = 'harmony';
  grid.dataset.blockIndex = blockIndex;
  grid.dataset.containerIndex = containerIndex;
  grid.style.position = 'relative';
  for (let i = 0; i < 8; i++) {
    createHarmonyColumn(grid, i, { instrumentSelect, grid });
  }
  block.appendChild(grid); // <-- adiciona DIRETAMENTE no block

  const volumeControl = createVolumeControl();
  block.appendChild(volumeControl);
  grid._volumeSlider = volumeControl.querySelector('.volume-slider');
  wrapper.appendChild(instrumentSelect);
  wrapper.appendChild(block);
  const containerId = `harmonyContainer${containerIndex + 1}`;
  document.getElementById(containerId).appendChild(wrapper);
  state.harmonyBlocks[containerIndex].push({ wrapper, instrumentSelect, grid, containerIndex });
  return wrapper;
}
function addBassBlock() {
  const blockIndex = state.bassBlocks.length;
  const wrapper = document.createElement('div');
  wrapper.className = 'instrument-wrapper';
  wrapper.style.display = 'flex';
  wrapper.style.alignItems = 'flex-start';
  wrapper.dataset.blockIndex = blockIndex;
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.style.width = '120px';
  instrumentSelect.style.marginRight = '10px';
  instrumentSelect.innerHTML = `<option value="bass">Baixo</option>`;
  const block = document.createElement('div');
  block.className = 'instrument-block bass-block';
  block.style.flex = '1';
  block.dataset.blockIndex = blockIndex;

  // REMOVIDO: scrollContainer
  const grid = createMelodicGrid('bass', blockIndex, 8);
  block.appendChild(grid); // <-- adiciona DIRETAMENTE

  const volumeControl = createVolumeControl();
  block.appendChild(volumeControl);
  grid._volumeSlider = volumeControl.querySelector('.volume-slider');
  wrapper.appendChild(instrumentSelect);
  wrapper.appendChild(block);
  ui.bassContainer.appendChild(wrapper);
  state.bassBlocks.push(wrapper);
  return wrapper;
}

function addMelody1Block() {
  return addMelodyBlock('melody1', ui.melody1Container, state.melody1Blocks);
}
function addMelody2Block() {
  return addMelodyBlock('melody2', ui.melody2Container, state.melody2Blocks);
}
function addMelodyBlock(type, container, stateArray) {
  const blockIndex = stateArray.length;
  const wrapper = document.createElement('div');
  wrapper.className = 'instrument-wrapper';
  wrapper.style.display = 'flex';
  wrapper.style.alignItems = 'flex-start';
  wrapper.dataset.blockIndex = blockIndex;
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.style.width = '120px';
  instrumentSelect.style.marginRight = '10px';
  instrumentSelect.innerHTML = `
    <option value="piano">Piano</option>
    <option value="sax">Saxofone</option>
    <option value="acordeon">Acordeon</option>
    <option value="strings">Cordas</option>
    <option value="sinos">Sinos</option>
    <option value="acoustic-guitar">Violão Aço</option>
    <option value="nylon-guitar">Violão Nylon</option>
    <option value="distorted-guitar-melody">Guitarra Distorcida (Melodia)</option>
  `;
  const block = document.createElement('div');
  block.className = `instrument-block ${type}-block`;
  block.style.flex = '1';
  block.dataset.blockIndex = blockIndex;

  // REMOVIDO: scrollContainer
  const grid = createMelodicGrid(type, blockIndex, 8);
  block.appendChild(grid); // <-- adiciona DIRETAMENTE

  const volumeControl = createVolumeControl();
  block.appendChild(volumeControl);
  grid._volumeSlider = volumeControl.querySelector('.volume-slider');
  wrapper.appendChild(instrumentSelect);
  wrapper.appendChild(block);
  container.appendChild(wrapper);
  stateArray.push(wrapper);
  return wrapper;
}
function addDrumBlock() {
  const blockIndex = state.drumBlocks.length;
  const block = document.createElement('div');
  block.className = 'instrument-block drum-block';
  block.dataset.blockIndex = blockIndex;
  block.style.display = 'flex';
  block.style.alignItems = 'flex-start';

  // REMOVIDO: scrollContainer
  const drumWrapper = document.createElement('div');
  drumWrapper.className = 'drum-wrapper';
  drumWrapper.style.position = 'relative';
  drumWrapper.style.alignItems = 'flex-start';
  const labelsColumn = document.createElement('div');
  labelsColumn.className = 'drum-labels';
  const volumeColumn = document.createElement('div');
  volumeColumn.className = 'drum-labels';
  volumeColumn.style.width = '80px';
  DRUM_SAMPLES.forEach(drum => {
    const labelItem = document.createElement('div');
    labelItem.className = 'drum-label-item';
    labelItem.textContent = drum.label;
    labelsColumn.appendChild(labelItem);
    const volumeItem = document.createElement('div');
    volumeItem.style.height = '45px';
    volumeItem.style.display = 'flex';
    volumeItem.style.alignItems = 'center';
    volumeItem.style.padding = '0 5px';
    volumeItem.style.boxSizing = 'border-box';
    const volumeSlider = document.createElement('input');
    volumeSlider.type = 'range';
    volumeSlider.className = 'volume-slider drum-volume-slider';
    volumeSlider.min = '0';
    volumeSlider.max = '1';
    volumeSlider.step = '0.01';
    volumeSlider.value = '1.0';
    volumeSlider.dataset.drumKey = drum.key;
    volumeSlider.style.width = '100%';
    if (!window.drumVolumeSliders) window.drumVolumeSliders = {};
    window.drumVolumeSliders[drum.key] = volumeSlider;
    volumeItem.appendChild(volumeSlider);
    volumeColumn.appendChild(volumeItem);
  });
  const grid = document.createElement('div');
  grid.className = 'columns-grid';
  grid.dataset.type = 'drum';
  grid.dataset.blockIndex = blockIndex;
  for (let step = 0; step < 8; step++) {
    createDrumColumn(grid, step, blockIndex);
  }
  drumWrapper.appendChild(labelsColumn);
  drumWrapper.appendChild(volumeColumn);
  drumWrapper.appendChild(grid);
  block.appendChild(drumWrapper); // <-- adiciona DIRETAMENTE no block
  ui.drumContainer.appendChild(block);
  state.drumBlocks.push(block);
  return block;
}

function createMelodicGrid(type, blockIndex, numColumns) {
  const grid = document.createElement('div');
  grid.className = 'columns-grid';
  grid.dataset.type = type;
  grid.dataset.blockIndex = blockIndex;
  for (let i = 0; i < numColumns; i++) {
    createMelodicColumn(grid, type, i);
  }
  return grid;
}

// ===== EXCLUSÃO DE COLUNA =====
function deleteColumn(columnIndex) {
  const allGrids = [
    ...state.harmonyBlocks[0].map(hb => hb.grid),
    ...state.harmonyBlocks[1].map(hb => hb.grid),
    ...state.harmonyBlocks[2].map(hb => hb.grid),
    ...state.bassBlocks.map(b => b.querySelector('.columns-grid')),
    ...state.melody1Blocks.map(m => m.querySelector('.columns-grid')),
    ...state.melody2Blocks.map(m => m.querySelector('.columns-grid')),
    ...state.drumBlocks.map(d => d.querySelector('.columns-grid'))
  ].filter(Boolean);

  allGrids.forEach(g => {
    const columns = g.querySelectorAll('.column');
    if (columns[columnIndex]) {
      g.removeChild(columns[columnIndex]);
    }
  });
  state.totalSteps -= 1;
  updateEditMap();
  updateMeasureDividers();
}

// ===== ADIÇÃO DE COMPASSO =====
function addCompasso() {
  const newColumnIndex = state.totalSteps;
  for (let containerIndex = 0; containerIndex < 3; containerIndex++) {
    state.harmonyBlocks[containerIndex].forEach(harmonyBlock => {
      const grid = harmonyBlock.grid;
      if (!grid) return;
      createHarmonyColumn(grid, newColumnIndex, harmonyBlock);
    });
  }
  [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach(blocks => {
    blocks.forEach(wrapper => {
      const grid = wrapper.querySelector('.columns-grid');
      if (!grid) return;
      const type = grid.dataset.type;
      createMelodicColumn(grid, type, newColumnIndex);
    });
  });
  state.drumBlocks.forEach(block => {
    const grid = block.querySelector('.columns-grid');
    if (!grid) return;
    createDrumColumn(grid, newColumnIndex, block.dataset.blockIndex);
  });
  state.totalSteps += 1;
  updateStatus(`Compasso adicionado. Total: ${state.totalSteps} passos.`, 'ready');
  updateEditMap();
  setTimeout(updateMeasureDividers, 0);
  setupScrollSync();
}
function updateMeasureDividers() {
  requestAnimationFrame(() => {
    // Remove todas as linhas antigas
    document.querySelectorAll('.measure-divider').forEach(el => el.remove());

    // Seleciona todos os grids
    const allGrids = [
      ...document.querySelectorAll('#harmonyContainer1 .columns-grid'),
      ...document.querySelectorAll('#harmonyContainer2 .columns-grid'),
      ...document.querySelectorAll('#harmonyContainer3 .columns-grid'),
      ...document.querySelectorAll('#bassContainer .columns-grid'),
      ...document.querySelectorAll('#melody1Container .columns-grid'),
      ...document.querySelectorAll('#melody2Container .columns-grid'),
      ...document.querySelectorAll('#drumContainer .columns-grid')
    ].filter(Boolean);

    allGrids.forEach(grid => {
      const columns = grid.querySelectorAll('.column');
      let accumulatedWidth = 0;

      for (let i = 0; i < columns.length; i++) {
        const column = columns[i];
        // Adiciona a largura da coluna atual
        accumulatedWidth += column.offsetWidth;

        // Se for a 8ª, 16ª, 24ª... coluna (índice 7, 15, 23...)
        if ((i + 1) % 8 === 0) {
          const divider = document.createElement('div');
          divider.className = 'measure-divider';
          // Posiciona à direita da coluna atual
          divider.style.left = `${accumulatedWidth}px`;
          grid.appendChild(divider);
        }

        // Adiciona gap (2px) após cada coluna, exceto a última
        if (i < columns.length - 1) {
          accumulatedWidth += 2; // gap definido em .columns-grid { gap: 2px; }
        }
      }
    });
  });
}
function setupScrollSync() {
  if (state.scrollHandler) {
    state.scrollContainers.forEach(container => {
      container.removeEventListener('scroll', state.scrollHandler);
    });
  }

  // Seleciona TODOS os .columns-grid, incluindo os da bateria
  const allGrids = [
    ...document.querySelectorAll('#harmonyContainer1 .columns-grid'),
    ...document.querySelectorAll('#harmonyContainer2 .columns-grid'),
    ...document.querySelectorAll('#harmonyContainer3 .columns-grid'),
    ...document.querySelectorAll('#bassContainer .columns-grid'),
    ...document.querySelectorAll('#melody1Container .columns-grid'),
    ...document.querySelectorAll('#melody2Container .columns-grid'),
    ...document.querySelectorAll('#drumContainer .drum-wrapper .columns-grid')
  ].filter(Boolean);

  state.scrollContainers = allGrids;

  let isSyncing = false;

  const handleScroll = (source) => {
    if (isSyncing) return;
    isSyncing = true;

    const left = source.scrollLeft;
    allGrids.forEach(grid => {
      if (grid !== source) {
        // Usa scrollLeft diretamente (não scrollTo) para evitar conflitos
        grid.scrollLeft = left;
      }
    });

    requestAnimationFrame(() => {
      isSyncing = false;
    });
  };

  state.scrollHandler = function (e) {
    handleScroll(e.target);
  };

  allGrids.forEach(grid => {
    grid.addEventListener('scroll', state.scrollHandler);
  });
}
// ===== RESTANTE DO CÓDIGO (event listeners, playback, etc.) =====
function initializeApp() {
  updateStatus('Pronto para compor. Clique nas células para criar sua música.', 'ready');
  try {
    state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    state.masterGain = state.audioCtx.createGain();
    state.drumGain = state.audioCtx.createGain();
    state.bassGain = state.audioCtx.createGain();
    state.melodyGain = state.audioCtx.createGain();
    state.harmonicGain = state.audioCtx.createGain();
    state.masterGain.connect(state.audioCtx.destination);
    state.drumGain.connect(state.masterGain);
    state.bassGain.connect(state.masterGain);
    state.melodyGain.connect(state.masterGain);
    state.harmonicGain.connect(state.masterGain);
    state.masterGain.gain.value = 0.8;
    state.drumGain.gain.value = 1.0;
    state.bassGain.gain.value = 0.5;
    state.melodyGain.gain.value = 0.5;
    state.harmonicGain.gain.value = 0.5;

    setupEventListeners();

    state.harmonyBlocks = [[], [], []];
    state.bassBlocks = [];
    state.melody1Blocks = [];
    state.melody2Blocks = [];
    state.drumBlocks = [];

    addHarmonyBlock(0);
    addHarmonyBlock(1);
    addHarmonyBlock(2);
    addBassBlock();
    addMelody1Block();
    addMelody2Block();
    addDrumBlock();

    ui.btnPlay.disabled = false;
    ui.btnSaveWAV.disabled = true;
    ui.btnStop.disabled = true;
    updateStatus('Componha sua música. Clique em Play para iniciar com contagem de 4 compassos.', 'ready');
    updateEditMap();
    setTimeout(updateMeasureDividers, 0);
    setupScrollSync();
  } catch (error) {
    console.error('Erro ao inicializar:', error);
    updateStatus('Erro ao inicializar: ' + error.message, 'error');
  }
}

function setupEventListeners() {
  updateBPMDisplay();
  ui.bpmSlider.addEventListener('input', handleBPMChange);
  ui.addCompassoBtn.addEventListener('click', addCompasso);
  ui.btnPlay.addEventListener('click', onPlay);
  ui.btnStop.addEventListener('click', onStop);
  ui.btnSaveWAV.addEventListener('click', () => renderAndDownloadWAV());
  document.getElementById('btnDuplicate').addEventListener('click', duplicateComposition);
  document.getElementById('btnClearAll').addEventListener('click', clearAllComposition);
  ui.selectionModal.addEventListener('click', function(e) {
    if (e.target === this) closeModal();
  });
}

// ===== FUNÇÕES AUXILIARES =====
function handleBPMChange() {
  state.bpm = parseInt(ui.bpmSlider.value);
  updateBPMDisplay();
}
function updateBPMDisplay() {
  ui.bpmDisplay.textContent = `${state.bpm} BPM`;
}
function updateStatus(message, type) {
  ui.statusIndicator.textContent = message;
  ui.statusIndicator.className = 'status-indicator status-' + type;
}

// ===== CARREGAMENTO SOB DEMANDA =====
async function loadSample(instrumentType, key, noteOrChord) {
  let filePath;
  let bufferKey;
  if (instrumentType === 'drum') {
    const sample = DRUM_SAMPLES.find(d => d.key === key);
    if (!sample) return;
    filePath = sample.path;
    bufferKey = key;
  } else if (instrumentType === 'melodic') {
    if (noteOrChord === 'X') return;
    filePath = MELODIC_INSTRUMENTS[key] + noteOrChord + '.mp3';
    bufferKey = `melodic-${key}-${noteOrChord}`;
  } else if (instrumentType === 'harmonic') {
    if (noteOrChord === 'X') return;
    let root;
    if (noteOrChord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(noteOrChord.slice(0, 2))) {
      root = noteOrChord.slice(0, 2);
    } else {
      root = noteOrChord[0];
    }
    filePath = HARMONIC_INSTRUMENTS[key] + root + '/' + noteOrChord + '.mp3';
    bufferKey = filePath;
  }
  if (!filePath) return;
  if (state.loadedSamples.has(bufferKey)) return;
  try {
    const response = await fetch(filePath);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const arrayBuffer = await response.arrayBuffer();
    const buffer = await state.audioCtx.decodeAudioData(arrayBuffer);
    if (instrumentType === 'drum') {
      state.buffers.drums[bufferKey] = buffer;
    } else if (instrumentType === 'melodic') {
      state.buffers.melodic[bufferKey] = buffer;
    } else if (instrumentType === 'harmonic') {
      state.buffers.harmonic[bufferKey] = buffer;
    }
    state.loadedSamples.add(bufferKey);
    console.log(`✅ Carregado: ${filePath} → chave: ${bufferKey}`);
  } catch (err) {
    console.warn(`⚠️ Não encontrado: ${filePath}`);
  }
}

// ===== MODAL =====
function openModal(type, options, targetCell, instrumentKey) {
  state.modal.type = type;
  state.modal.targetCell = targetCell;
  state.modal.instrumentKey = instrumentKey;
  ui.modalTitle.textContent = type === 'harmony' ? 'Selecione um Acorde' : 'Selecione uma Nota';
  ui.modalGrid.innerHTML = '';
  options.forEach(option => {
    const div = document.createElement('div');
    div.className = 'modal-option';
    if (option === 'X') {
      div.classList.add('x');
    }
    let displayText = option;
    if (option !== 'X') {
      displayText = option.replace(/S/g, '#');
    }
    div.textContent = displayText;
    div.dataset.originalValue = option;
    div.addEventListener('click', function() {
      const originalValue = this.dataset.originalValue;
      const deleteBtn = targetCell.querySelector('.delete-cell-btn');
      if (deleteBtn) targetCell.removeChild(deleteBtn);
      targetCell.textContent = displayText;
      targetCell.dataset.originalValue = originalValue;
      if (originalValue === 'X') {
        targetCell.classList.add('x');
      } else {
        targetCell.classList.remove('x');
      }
      if (deleteBtn) targetCell.appendChild(deleteBtn);
      if (state.currentlyPlaying[type] !== null) {
        state.currentlyPlaying[type] = null;
      }
      if (type === 'harmony') {
        loadSample('harmonic', instrumentKey, originalValue);
      } else {
        loadSample('melodic', instrumentKey, originalValue);
      }
      closeModal();
    });
    ui.modalGrid.appendChild(div);
  });
  ui.selectionModal.style.display = 'flex';
}

function closeModal() {
  ui.selectionModal.style.display = 'none';
  state.modal = {
    targetCell: null,
    type: null,
    instrumentKey: null
  };
}

// ===== PLAYBACK =====
function buildPlaybackPlan() {
  const plan = {
    harmony1: [],
    harmony2: [],
    harmony3: [],
    bass: [],
    melody1: [],
    melody2: [],
    drums: {}
  };
  DRUM_SAMPLES.forEach(d => plan.drums[d.key] = []);
  // HARMONIA 1
  state.harmonyBlocks[0].forEach(harmonyBlock => {
    const grid = harmonyBlock.grid;
    const instrument = harmonyBlock.instrumentSelect.value;
    const columns = grid.querySelectorAll('.column');
    columns.forEach(column => {
      const cell = column.querySelector('.cell');
      const chordValue = getCellNoteValue(cell);
      if (chordValue !== 'X') {
        plan.harmony1.push({ chord: chordValue, instrument });
      } else {
        plan.harmony1.push(null);
      }
    });
  });
  // HARMONIA 2
  state.harmonyBlocks[1].forEach(harmonyBlock => {
    const grid = harmonyBlock.grid;
    const instrument = harmonyBlock.instrumentSelect.value;
    const columns = grid.querySelectorAll('.column');
    columns.forEach(column => {
      const cell = column.querySelector('.cell');
      const chordValue = getCellNoteValue(cell);
      if (chordValue !== 'X') {
        plan.harmony2.push({ chord: chordValue, instrument });
      } else {
        plan.harmony2.push(null);
      }
    });
  });
  // HARMONIA 3
  state.harmonyBlocks[2].forEach(harmonyBlock => {
    const grid = harmonyBlock.grid;
    const instrument = harmonyBlock.instrumentSelect.value;
    const columns = grid.querySelectorAll('.column');
    columns.forEach(column => {
      const cell = column.querySelector('.cell');
      const chordValue = getCellNoteValue(cell);
      if (chordValue !== 'X') {
        plan.harmony3.push({ chord: chordValue, instrument });
      } else {
        plan.harmony3.push(null);
      }
    });
  });
  // MELODICOS
  [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach((blocks, idx) => {
    const type = ['bass', 'melody1', 'melody2'][idx];
    blocks.forEach(wrapper => {
      const grid = wrapper.querySelector('.columns-grid');
      const instrumentSelect = wrapper.querySelector('.instrument-select');
      const instrument = instrumentSelect ? instrumentSelect.value : 'piano';
      const columns = grid.querySelectorAll('.column');
      columns.forEach(column => {
        const cell = column.querySelector('.cell');
        const noteValue = getCellNoteValue(cell);
        if (noteValue === 'X') {
          plan[type].push(null);
        } else {
          plan[type].push({ note: noteValue, instrument });
        }
      });
    });
  });
  // BATERIA
  state.drumBlocks.forEach(block => {
    const drumWrapper = block.querySelector('.drum-wrapper');
    const grid = drumWrapper ? drumWrapper.querySelector('.columns-grid') : block.querySelector('.columns-grid');
    if (!grid) return;
    const columns = grid.querySelectorAll('.column');
    columns.forEach((column, stepIndex) => {
      DRUM_SAMPLES.forEach(drum => {
        const cell = column.querySelector(`.drum-cell[data-instr="${drum.key}"]`);
        if (cell) {
          plan.drums[drum.key].push(cell.classList.contains('active'));
        }
      });
    });
  });
  state.playbackPlan = plan;
  state.stepIndex = 0;
  state.lastNoteTime = 0;
  return plan;
}

function getCellNoteValue(cellElement) {
  const labels = cellElement.querySelectorAll('.column-number-label');
  labels.forEach(l => l.remove());
  if (cellElement.dataset.originalValue) {
    return cellElement.dataset.originalValue;
  }
  for (let node of cellElement.childNodes) {
    if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== '') {
      return node.textContent.trim();
    }
  }
  return 'X';
}

function scheduleStep(time) {
  const idx = state.stepIndex;
  const plan = state.playbackPlan;
  if (!plan) return;
  // HARMONIA 1
  if (idx < plan.harmony1.length && plan.harmony1[idx]) {
    const item = plan.harmony1[idx];
    if (item && item.chord !== 'X') {
      if (state.currentlyPlaying.harmony1 !== null) {
        state.currentlyPlaying.harmony1 = null;
      }
      playChord(item.instrument, item.chord, time, state.harmonicGain, 1.0);
      state.currentlyPlaying.harmony1 = item.chord;
    }
  }
  // HARMONIA 2
  if (idx < plan.harmony2.length && plan.harmony2[idx]) {
    const item = plan.harmony2[idx];
    if (item && item.chord !== 'X') {
      if (state.currentlyPlaying.harmony2 !== null) {
        state.currentlyPlaying.harmony2 = null;
      }
      playChord(item.instrument, item.chord, time, state.harmonicGain, 1.0);
      state.currentlyPlaying.harmony2 = item.chord;
    }
  }
  // HARMONIA 3
  if (idx < plan.harmony3.length && plan.harmony3[idx]) {
    const item = plan.harmony3[idx];
    if (item && item.chord !== 'X') {
      if (state.currentlyPlaying.harmony3 !== null) {
        state.currentlyPlaying.harmony3 = null;
      }
      playChord(item.instrument, item.chord, time, state.harmonicGain, 1.0);
      state.currentlyPlaying.harmony3 = item.chord;
    }
  }
  // BAIXO
  if (idx < plan.bass.length && plan.bass[idx]) {
    const item = plan.bass[idx];
    if (item && item.note) {
      if (state.currentlyPlaying.bass !== null) {
        state.currentlyPlaying.bass = null;
      }
      playNote(item.instrument, item.note, time, state.bassGain, 0.7);
      state.currentlyPlaying.bass = item.note;
    }
  }
  // MELODIA 1
  if (idx < plan.melody1.length && plan.melody1[idx]) {
    const item = plan.melody1[idx];
    if (item && item.note) {
      if (state.currentlyPlaying.melody1 !== null) {
        state.currentlyPlaying.melody1 = null;
      }
      playNote(item.instrument, item.note, time, state.melodyGain, 0.6);
      state.currentlyPlaying.melody1 = item.note;
    }
  }
  // MELODIA 2
  if (idx < plan.melody2.length && plan.melody2[idx]) {
    const item = plan.melody2[idx];
    if (item && item.note) {
      if (state.currentlyPlaying.melody2 !== null) {
        state.currentlyPlaying.melody2 = null;
      }
      playNote(item.instrument, item.note, time, state.melodyGain, 0.6);
      state.currentlyPlaying.melody2 = item.note;
    }
  }
  // BATERIA
  Object.keys(plan.drums).forEach(key => {
    if (idx < plan.drums[key].length && plan.drums[key][idx]) {
      playDrum(key, time, state.drumGain, 1.0);
    }
  });
  state.stepIndex = (state.stepIndex + 1) % state.totalSteps;
}

function playNote(instrumentKey, note, time, gainNode, volume = 1.0) {
  if (!state.audioCtx) return;
  const bufferKey = `melodic-${instrumentKey}-${note}`;
  const buffer = state.buffers.melodic[bufferKey];
  if (!buffer) {
    console.warn(`Sample não encontrado: ${instrumentKey}/${note}`);
    return;
  }
  const source = state.audioCtx.createBufferSource();
  source.buffer = buffer;
  const activeGrid = gainNode === state.bassGain ? document.querySelector('#bassContainer .columns-grid') :
                     gainNode === state.melodyGain ? document.querySelector('#melody1Container .columns-grid') || document.querySelector('#melody2Container .columns-grid') : null;
  const sliderVolume = activeGrid && activeGrid._volumeSlider ? parseFloat(activeGrid._volumeSlider.value) : 0.5;
  const instrumentGain = state.audioCtx.createGain();
  instrumentGain.gain.setValueAtTime(sliderVolume * volume, time);
  source.connect(instrumentGain);
  instrumentGain.connect(gainNode);
  source.start(time);
  source.stop(time + 0.25);
}

function playChord(instrumentKey, chord, time, gainNode, volume = 1.0) {
  if (!state.audioCtx) return;
  if (chord === 'X') return;
  let root;
  if (chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(chord.slice(0, 2))) {
    root = chord.slice(0, 2);
  } else {
    root = chord[0];
  }
  const filePath = HARMONIC_INSTRUMENTS[instrumentKey] + root + '/' + chord + '.mp3';
  const buffer = state.buffers.harmonic[filePath];
  if (!buffer) {
    console.warn(`Acorde não encontrado: ${filePath}`);
    return;
  }
  const source = state.audioCtx.createBufferSource();
  source.buffer = buffer;
  const activeGrid = document.querySelector('#harmonyContainer1 .columns-grid') ||
                     document.querySelector('#harmonyContainer2 .columns-grid') ||
                     document.querySelector('#harmonyContainer3 .columns-grid');
  const sliderVolume = activeGrid && activeGrid._volumeSlider ? parseFloat(activeGrid._volumeSlider.value) : 0.5;
  const instrumentGain = state.audioCtx.createGain();
  instrumentGain.gain.setValueAtTime(sliderVolume * volume, time);
  source.connect(instrumentGain);
  instrumentGain.connect(gainNode);
  source.start(time);
  source.stop(time + 0.5);
}

function playDrum(drumKey, time, gainNode, volume = 1.0) {
  if (!state.audioCtx) return;
  const buffer = state.buffers.drums[drumKey];
  if (!buffer) {
    console.warn(`Sample de bateria não encontrado: ${drumKey}`);
    return;
  }
  const source = state.audioCtx.createBufferSource();
  source.buffer = buffer;
  const gain = state.audioCtx.createGain();
  const drumVolumeSlider = window.drumVolumeSliders && window.drumVolumeSliders[drumKey];
  const sliderVolume = drumVolumeSlider ? parseFloat(drumVolumeSlider.value) : 1.0;
  gain.gain.setValueAtTime(sliderVolume * volume, time);
  source.connect(gain);
  gain.connect(gainNode);
  source.start(time);
}

// ===== CONTROLE DE REPRODUÇÃO =====
function onPlay() {
  if (!state.audioCtx) {
    updateStatus('Erro: Audio Context não inicializado', 'error');
    return;
  }
  if (state.isPlaying) {
    state.isPlaying = false;
    ui.btnPlay.textContent = '▶ Play';
    ui.btnStop.disabled = true;
    return;
  }
  try {
    if (state.audioCtx.state === 'suspended') {
      state.audioCtx.resume();
    }
    buildPlaybackPlan();
    const samplesToLoad = new Set();
    // HARMONIA 1
    state.playbackPlan.harmony1.forEach(item => {
      if (item && item.chord !== 'X') {
        let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2)) ? item.chord.slice(0, 2) : item.chord[0];
        const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
        samplesToLoad.add(filePath);
      }
    });
    // HARMONIA 2
    state.playbackPlan.harmony2.forEach(item => {
      if (item && item.chord !== 'X') {
        let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2)) ? item.chord.slice(0, 2) : item.chord[0];
        const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
        samplesToLoad.add(filePath);
      }
    });
    // HARMONIA 3
    state.playbackPlan.harmony3.forEach(item => {
      if (item && item.chord !== 'X') {
        let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2)) ? item.chord.slice(0, 2) : item.chord[0];
        const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
        samplesToLoad.add(filePath);
      }
    });
    // MELODICOS
    ['bass', 'melody1', 'melody2'].forEach(type => {
      state.playbackPlan[type].forEach(item => {
        if (item && item.note) {
          const bufferKey = `melodic-${item.instrument}-${item.note}`;
          samplesToLoad.add(bufferKey);
        }
      });
    });
    // BATERIA
    Object.keys(state.playbackPlan.drums).forEach(key => {
      if (state.playbackPlan.drums[key].some(active => active)) {
        samplesToLoad.add(key);
      }
    });
    updateStatus('Carregando amostras... Por favor, aguarde.', 'loading');
    ui.btnSaveWAV.disabled = true;
    ui.countdown.style.display = 'block';
    const promises = Array.from(samplesToLoad).map(bufferKey => {
      if (bufferKey.includes('melodic-')) {
        const parts = bufferKey.split('-');
        const instrumentKey = parts[1];
        const noteOrChord = parts.slice(2).join('-');
        return loadSample('melodic', instrumentKey, noteOrChord);
      } else if (bufferKey.includes('guitarra') || bufferKey.includes('PianoStringChord')) {
        let instrumentKey = '';
        let chord = '';
        if (bufferKey.startsWith('guitarraDistorcao/')) {
          instrumentKey = 'distorted-guitar';
          chord = bufferKey.replace('guitarraDistorcao/', '').replace('.mp3', '').split('/').pop();
        } else if (bufferKey.startsWith('guitarraLimpa/')) {
          instrumentKey = 'clean-guitar';
          chord = bufferKey.replace('guitarraLimpa/', '').replace('.mp3', '').split('/').pop();
        } else if (bufferKey.startsWith('assets/PianoStringChord/')) {
          instrumentKey = 'piano-chord';
          chord = bufferKey.replace('assets/PianoStringChord/', '').replace('.mp3', '').split('/').pop();
        }
        if (instrumentKey && chord) {
          return loadSample('harmonic', instrumentKey, chord);
        } else {
          console.warn('Caminho de acorde inválido:', bufferKey);
          return Promise.resolve();
        }
      } else {
        return loadSample('drum', bufferKey, '');
      }
    });
    Promise.all(promises).then(() => {
      ui.btnSaveWAV.disabled = false;
      startCountdown();
    }).catch(err => {
      console.error('Erro ao carregar amostras:', err);
      updateStatus('Erro ao carregar amostras. Verifique a conexão.', 'error');
    });
  } catch (error) {
    console.error('Erro ao iniciar reprodução:', error);
    updateStatus('Erro ao iniciar: ' + error.message, 'error');
  }
}

function startCountdown() {
  state.countdownActive = true;
  state.countdownValue = 4;
  ui.countdown.textContent = state.countdownValue;
  const eighthDur = 60 / state.bpm / 8;
  const beatDuration = eighthDur * 8;
  const interval = setInterval(() => {
    state.countdownValue--;
    ui.countdown.textContent = state.countdownValue;
    if (state.countdownValue <= 0) {
      clearInterval(interval);
      ui.countdown.style.display = 'none';
      state.countdownActive = false;
      startScheduler();
      updateStatus('Reproduzindo...', 'ready');
    }
  }, beatDuration * 1000);
}

function startScheduler() {
  state.isPlaying = true;
  ui.btnPlay.textContent = '⏸ Pause';
  ui.btnStop.disabled = false;
  function tick() {
    if (!state.isPlaying) return;
    const now = state.audioCtx.currentTime;
    const stepDuration = 60 / state.bpm / 8;
    const nextStep = state.lastNoteTime + stepDuration;
    if (now >= nextStep) {
      scheduleStep(nextStep);
      state.lastNoteTime = nextStep;
      updatePlaybackProgress();
    }
    requestAnimationFrame(tick);
  }
  state.lastNoteTime = state.audioCtx.currentTime;
  tick();
}

function updatePlaybackProgress() {
  document.querySelectorAll('.cell, .drum-cell').forEach(cell => {
    cell.style.boxShadow = 'none';
  });
  const currentStep = state.stepIndex;
  document.querySelectorAll(`.column:nth-child(${currentStep + 1}) .cell`).forEach(cell => {
    cell.style.boxShadow = '0 0 5px 2px #5eead4';
  });
  document.querySelectorAll(`.column:nth-child(${currentStep + 1}) .drum-cell`).forEach(cell => {
    cell.style.boxShadow = '0 0 5px 2px #5eead4';
  });
  const currentMeasure = Math.floor(currentStep / 8);
  document.querySelectorAll('.edit-map-item').forEach((item, idx) => {
    if (idx === currentMeasure) {
      item.classList.add('active');
    } else {
      item.classList.remove('active');
    }
  });
}

function onStop() {
  state.isPlaying = false;
  state.stepIndex = 0;
  ui.btnPlay.textContent = '▶ Play';
  ui.countdown.style.display = 'none';
  ui.btnStop.disabled = true;
  updateStatus('Reprodução parada', 'ready');
}

// ===== GRAVAÇÃO WAV =====
async function renderAndDownloadWAV() {
  if (!state.playbackPlan) {
    alert('Crie alguma música primeiro.');
    return;
  }
  updateStatus('Renderizando áudio...', 'loading');
  ui.btnSaveWAV.disabled = true;
  ui.btnSaveWAV.textContent = '⏳ Renderizando...';
  ui.progressContainer.style.display = 'block';
  try {
    const sampleRate = 44100;
    const eighthDur = 60 / state.bpm / 8;
    const lastEventTime = (state.totalSteps - 1) * eighthDur + 0.5;
    const safeDuration = lastEventTime + 2.0;
    const totalSamples = Math.ceil(safeDuration * sampleRate);
    const offlineCtx = new OfflineAudioContext(2, totalSamples, sampleRate);
    const master = offlineCtx.createGain();
    const drumGain = offlineCtx.createGain();
    const bassGain = offlineCtx.createGain();
    const melodyGain = offlineCtx.createGain();
    const harmonicGain = offlineCtx.createGain();
    master.connect(offlineCtx.destination);
    drumGain.connect(master);
    bassGain.connect(master);
    melodyGain.connect(master);
    harmonicGain.connect(master);
    master.gain.value = 0.8;
    drumGain.gain.value = 1.0;
    bassGain.gain.value = 0.5;
    melodyGain.gain.value = 0.5;
    harmonicGain.gain.value = 0.5;
    const bassInstrumentGain = offlineCtx.createGain();
    const melodyInstrumentGain = offlineCtx.createGain();
    const harmonyInstrumentGain = offlineCtx.createGain();
    const drumInstrumentGains = {};
    DRUM_SAMPLES.forEach(drum => {
      drumInstrumentGains[drum.key] = offlineCtx.createGain();
      drumInstrumentGains[drum.key].connect(drumGain);
    });
    bassInstrumentGain.connect(bassGain);
    melodyInstrumentGain.connect(melodyGain);
    harmonyInstrumentGain.connect(harmonicGain);
    const totalSteps = state.totalSteps;
    const updateProgress = (currentStep) => {
      const percent = Math.round((currentStep / totalSteps) * 100);
      ui.progressBar.style.width = `${percent}%`;
      ui.progressText.textContent = `${percent}%`;
    };
    for (let step = 0; step < totalSteps; step++) {
      const time = step * eighthDur;
      if (step % 10 === 0) {
        updateProgress(step);
      }
      // HARMONIA 1
      if (step < state.playbackPlan.harmony1.length && state.playbackPlan.harmony1[step]) {
        const item = state.playbackPlan.harmony1[step];
        if (item && item.chord !== 'X') {
          let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))
            ? item.chord.slice(0, 2)
            : item.chord[0];
          const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
          const buffer = state.buffers.harmonic[filePath];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            const harmonyContainer = document.querySelector('#harmonyContainer1');
            const activeGrid = harmonyContainer ? harmonyContainer.querySelector('.columns-grid') : null;
            const sliderVolume = activeGrid && activeGrid._volumeSlider ? parseFloat(activeGrid._volumeSlider.value) : 0.5;
            harmonyInstrumentGain.gain.setValueAtTime(sliderVolume, time);
            source.connect(harmonyInstrumentGain);
            source.start(time);
            source.stop(time + 0.5);
          }
        }
      }
      // HARMONIA 2
      if (step < state.playbackPlan.harmony2.length && state.playbackPlan.harmony2[step]) {
        const item = state.playbackPlan.harmony2[step];
        if (item && item.chord !== 'X') {
          let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))
            ? item.chord.slice(0, 2)
            : item.chord[0];
          const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
          const buffer = state.buffers.harmonic[filePath];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            const harmonyContainer = document.querySelector('#harmonyContainer2');
            const activeGrid = harmonyContainer ? harmonyContainer.querySelector('.columns-grid') : null;
            const sliderVolume = activeGrid && activeGrid._volumeSlider ? parseFloat(activeGrid._volumeSlider.value) : 0.5;
            harmonyInstrumentGain.gain.setValueAtTime(sliderVolume, time);
            source.connect(harmonyInstrumentGain);
            source.start(time);
            source.stop(time + 0.5);
          }
        }
      }
      // HARMONIA 3
      if (step < state.playbackPlan.harmony3.length && state.playbackPlan.harmony3[step]) {
        const item = state.playbackPlan.harmony3[step];
        if (item && item.chord !== 'X') {
          let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))
            ? item.chord.slice(0, 2)
            : item.chord[0];
          const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
          const buffer = state.buffers.harmonic[filePath];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            const harmonyContainer = document.querySelector('#harmonyContainer3');
            const activeGrid = harmonyContainer ? harmonyContainer.querySelector('.columns-grid') : null;
            const sliderVolume = activeGrid && activeGrid._volumeSlider ? parseFloat(activeGrid._volumeSlider.value) : 0.5;
            harmonyInstrumentGain.gain.setValueAtTime(sliderVolume, time);
            source.connect(harmonyInstrumentGain);
            source.start(time);
            source.stop(time + 0.5);
          }
        }
      }
      // BAIXO
      if (step < state.playbackPlan.bass.length && state.playbackPlan.bass[step]) {
        const item = state.playbackPlan.bass[step];
        if (item && item.note) {
          const bufferKey = `melodic-${item.instrument}-${item.note}`;
          const buffer = state.buffers.melodic[bufferKey];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            const bassContainer = document.querySelector('#bassContainer');
            const activeGrid = bassContainer ? bassContainer.querySelector('.columns-grid') : null;
            const sliderVolume = activeGrid && activeGrid._volumeSlider ? parseFloat(activeGrid._volumeSlider.value) : 0.5;
            bassInstrumentGain.gain.setValueAtTime(sliderVolume, time);
            source.connect(bassInstrumentGain);
            source.start(time);
            source.stop(time + 0.25);
          }
        }
      }
      // MELODIA 1 & 2
      [[state.playbackPlan.melody1, melodyGain], [state.playbackPlan.melody2, melodyGain]].forEach(([melody, gain]) => {
        if (step < melody.length && melody[step]) {
          const item = melody[step];
          if (item && item.note) {
            const bufferKey = `melodic-${item.instrument}-${item.note}`;
            const buffer = state.buffers.melodic[bufferKey];
            if (buffer) {
              const source = offlineCtx.createBufferSource();
              source.buffer = buffer;
              const melodyContainer = gain === melodyGain ? (document.querySelector('#melody1Container') || document.querySelector('#melody2Container')) : null;
              const activeGrid = melodyContainer ? melodyContainer.querySelector('.columns-grid') : null;
              const sliderVolume = activeGrid && activeGrid._volumeSlider ? parseFloat(activeGrid._volumeSlider.value) : 0.5;
              melodyInstrumentGain.gain.setValueAtTime(sliderVolume, time);
              source.connect(melodyInstrumentGain);
              source.start(time);
              source.stop(time + 0.25);
            }
          }
        }
      });
      // BATERIA
      Object.keys(state.playbackPlan.drums).forEach(key => {
        if (step < state.playbackPlan.drums[key].length && state.playbackPlan.drums[key][step]) {
          const buffer = state.buffers.drums[key];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            const drumVolumeSlider = window.drumVolumeSliders && window.drumVolumeSliders[key];
            const sliderVolume = drumVolumeSlider ? parseFloat(drumVolumeSlider.value) : 1.0;
            drumInstrumentGains[key].gain.setValueAtTime(sliderVolume, time);
            source.connect(drumInstrumentGains[key]);
            source.start(time);
          }
        }
      });
    }
    updateProgress(totalSteps);
    const renderedBuffer = await offlineCtx.startRendering();
    const wavBlob = audioBufferToWav(renderedBuffer);
    const fileName = `jam-on-${new Date().toISOString().slice(0,10)}-${Math.floor(Math.random()*1000)}.wav`;
    downloadBlob(wavBlob, fileName);
    updateStatus('Renderização concluída!', 'ready');
  } catch (error) {
    console.error('Erro ao renderizar WAV:', error);
    updateStatus('Erro ao renderizar: ' + error.message, 'error');
  } finally {
    ui.btnSaveWAV.textContent = '💾 Salvar como WAV';
    ui.btnSaveWAV.disabled = false;
    ui.progressContainer.style.display = 'none';
  }
}

function audioBufferToWav(buffer) {
  const numOfChan = buffer.numberOfChannels;
  const length = buffer.length * numOfChan * 2 + 44;
  const arrayBuffer = new ArrayBuffer(length);
  const view = new DataView(arrayBuffer);
  const channels = [];
  let i, sample, offset = 0;
  function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }
  writeString(view, 0, 'RIFF');
  view.setUint32(4, length - 8, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numOfChan, true);
  view.setUint32(24, 44100, true);
  view.setUint32(28, 44100 * 2 * numOfChan, true);
  view.setUint16(32, 2 * numOfChan, true);
  view.setUint16(34, 16, true);
  writeString(view, 36, 'data');
  view.setUint32(40, length - 44, true);
  for (i = 0; i < buffer.numberOfChannels; i++) {
    channels.push(buffer.getChannelData(i));
  }
  offset = 44;
  for (i = 0; i < buffer.length; i++) {
    for (let channel = 0; channel < numOfChan; channel++) {
      sample = Math.max(-1, Math.min(1, channels[channel][i]));
      sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF);
      view.setInt16(offset, sample, true);
      offset += 2;
    }
  }
  return new Blob([view], { type: 'audio/wav' });
}

function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.style.display = 'none';
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 100);
}

// ===== OUTRAS FUNÇÕES =====
function duplicateComposition() {
  if (state.totalSteps === 0) {
    alert('Nenhuma composição para duplicar.');
    return;
  }
  const originalTotalSteps = state.totalSteps;
  const newTotalSteps = originalTotalSteps * 2;
  for (let i = 0; i < originalTotalSteps; i++) {
    const newColumnIndex = originalTotalSteps + i;
    // HARMONIA 1, 2, 3
    for (let containerIndex = 0; containerIndex < 3; containerIndex++) {
      state.harmonyBlocks[containerIndex].forEach(harmonyBlock => {
        const grid = harmonyBlock.grid;
        if (!grid) return;
        const instrument = harmonyBlock.instrumentSelect.value;
        const originalColumns = grid.querySelectorAll('.column');
        const originalColumn = originalColumns[i];
        const originalCell = originalColumn ? originalColumn.querySelector('.cell') : null;
        const originalValue = originalCell ? getCellNoteValue(originalCell) : 'X';
        const displayText = (originalValue === 'X') ? 'X' : originalValue.replace(/S/g, '#');
        const isX = originalValue === 'X';
        createHarmonyColumn(grid, newColumnIndex, harmonyBlock);
        const newColumns = grid.querySelectorAll('.column');
        const newColumn = newColumns[newColumnIndex];
        const existingLabel = newColumn.querySelector('.column-top-label');
        if (existingLabel) existingLabel.remove();
        const newCell = newColumn.querySelector('.cell');
        const deleteBtn = newCell.querySelector('.delete-cell-btn');
        if (deleteBtn) newCell.removeChild(deleteBtn);
        newCell.textContent = displayText;
        if (isX) {
          newCell.classList.add('x');
          newCell.removeAttribute('data-original-value');
        } else {
          newCell.classList.remove('x');
          newCell.dataset.originalValue = originalValue;
          loadSample('harmonic', instrument, originalValue);
        }
        if (deleteBtn) newCell.appendChild(deleteBtn);
      });
    }
    // BAIXO, MELODIA 1, MELODIA 2
    [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach(blocks => {
      blocks.forEach(wrapper => {
        const grid = wrapper.querySelector('.columns-grid');
        if (!grid) return;
        const instrumentSelect = wrapper.querySelector('.instrument-select');
        const instrument = instrumentSelect ? instrumentSelect.value : 'piano';
        const originalColumn = grid.querySelector(`.column:nth-child(${i + 1})`);
        const originalCell = originalColumn ? originalColumn.querySelector('.cell') : null;
        const originalValue = originalCell ? getCellNoteValue(originalCell) : 'X';
        const displayText = (originalValue === 'X') ? 'X' : originalValue.replace(/S/g, '#');
        const isX = originalValue === 'X';
        createMelodicColumn(grid, grid.dataset.type, newColumnIndex);
        const columns = grid.querySelectorAll('.column');
        const newColumn = columns[newColumnIndex];
        const newCell = newColumn.querySelector('.cell');
        const deleteBtn = newCell.querySelector('.delete-cell-btn');
        if (deleteBtn) newCell.removeChild(deleteBtn);
        newCell.textContent = displayText;
        if (isX) {
          newCell.classList.add('x');
          newCell.removeAttribute('data-original-value');
        } else {
          newCell.classList.remove('x');
          newCell.dataset.originalValue = originalValue;
          loadSample('melodic', instrument, originalValue);
        }
        if (deleteBtn) newCell.appendChild(deleteBtn);
      });
    });
    // BATERIA
    state.drumBlocks.forEach(block => {
      const drumWrapper = block.querySelector('.drum-wrapper');
      const grid = drumWrapper ? drumWrapper.querySelector('.columns-grid') : block.querySelector('.columns-grid');
      if (!grid) return;
      const originalColumn = grid.querySelector(`.column:nth-child(${i + 1})`);
      createDrumColumn(grid, newColumnIndex, block.dataset.blockIndex);
      const columns = grid.querySelectorAll('.column');
      const newColumn = columns[newColumnIndex];
      DRUM_SAMPLES.forEach(drum => {
        const originalCell = originalColumn ? originalColumn.querySelector(`.drum-cell[data-instr="${drum.key}"]`) : null;
        const newCell = newColumn.querySelector(`.drum-cell[data-instr="${drum.key}"]`);
        if (originalCell && originalCell.classList.contains('active')) {
          newCell.classList.add('active');
          loadSample('drum', drum.key, '');
        } else {
          newCell.classList.remove('active');
        }
      });
    });
  }
  state.totalSteps = newTotalSteps;
  updateStatus(`Composição duplicada. Total: ${state.totalSteps} passos.`, 'ready');
  updateEditMap();
  setTimeout(updateMeasureDividers, 0);
}

function clearAllComposition() {
  if (!confirm('Tem certeza? Isso apagará toda a composição atual.')) return;
  state.totalSteps = 8;
  state.harmonyBlocks = [[], [], []];
  state.bassBlocks = [];
  state.melody1Blocks = [];
  state.melody2Blocks = [];
  state.drumBlocks = [];
  ui.harmonyContainer1.innerHTML = '';
  ui.harmonyContainer2.innerHTML = '';
  ui.harmonyContainer3.innerHTML = '';
  ui.bassContainer.innerHTML = '';
  ui.melody1Container.innerHTML = '';
  ui.melody2Container.innerHTML = '';
  ui.drumContainer.innerHTML = '';
  addHarmonyBlock(0);
  addHarmonyBlock(1);
  addHarmonyBlock(2);
  addBassBlock();
  addMelody1Block();
  addMelody2Block();
  addDrumBlock();
  updateEditMap();
  setTimeout(updateMeasureDividers, 0);
  updateStatus('Composição limpa. Pronto para começar do zero.', 'ready');
}

function updateEditMap() {
  const mapContent = document.getElementById('editMapContent');
  mapContent.innerHTML = '';
  if (state.totalSteps === 0) return;
  const totalMeasures = Math.ceil(state.totalSteps / 8);
  for (let measureIndex = 0; measureIndex < totalMeasures; measureIndex++) {
    const item = document.createElement('div');
    item.className = 'edit-map-item';
    item.dataset.measureIndex = measureIndex;
    const numberSpan = document.createElement('span');
    numberSpan.className = 'edit-map-number';
    numberSpan.textContent = measureIndex + 1;
    const cellsContainer = document.createElement('div');
    cellsContainer.className = 'edit-map-cells';
    for (let i = 0; i < 8; i++) {
      const cellIndex = measureIndex * 8 + i;
      if (cellIndex >= state.totalSteps) break;
      const cellSpan = document.createElement('span');
      cellSpan.className = 'edit-map-cell';
      let hasContent = false;
      for (let containerIndex = 0; containerIndex < 3; containerIndex++) {
        state.harmonyBlocks[containerIndex].forEach(hb => {
          const grid = hb.grid;
          const column = grid.querySelector(`.column:nth-child(${cellIndex + 1})`);
          if (column) {
            const cell = column.querySelector('.cell');
            if (cell && !cell.classList.contains('x')) {
              hasContent = true;
            }
          }
        });
      }
      [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach(blocks => {
        blocks.forEach(wrapper => {
          const grid = wrapper.querySelector('.columns-grid');
          const column = grid.querySelector(`.column:nth-child(${cellIndex + 1})`);
          if (column) {
            const cell = column.querySelector('.cell');
            if (cell && !cell.classList.contains('x')) {
              hasContent = true;
            }
          }
        });
      });
      state.drumBlocks.forEach(block => {
        const drumWrapper = block.querySelector('.drum-wrapper');
        const grid = drumWrapper ? drumWrapper.querySelector('.columns-grid') : block.querySelector('.columns-grid');
        if (grid) {
          const column = grid.querySelector(`.column:nth-child(${cellIndex + 1})`);
          if (column) {
            DRUM_SAMPLES.forEach(drum => {
              const drumCell = column.querySelector(`.drum-cell[data-instr="${drum.key}"]`);
              if (drumCell && drumCell.classList.contains('active')) {
                hasContent = true;
              }
            });
          }
        }
      });
      if (hasContent) {
        cellSpan.classList.add('filled');
      } else {
        cellSpan.classList.add('x');
      }
      cellsContainer.appendChild(cellSpan);
    }
    item.appendChild(numberSpan);
    item.appendChild(cellsContainer);
    mapContent.appendChild(item);
    item.addEventListener('click', function() {
      const clickedMeasureIndex = parseInt(this.dataset.measureIndex);
      const targetColumnIndex = clickedMeasureIndex * 8;
      document.querySelectorAll('.edit-map-item').forEach(el => el.classList.remove('active'));
      this.classList.add('active');
      const allGrids = [
        ...state.harmonyBlocks[0].map(hb => hb.grid),
        ...state.harmonyBlocks[1].map(hb => hb.grid),
        ...state.harmonyBlocks[2].map(hb => hb.grid),
        ...state.bassBlocks.map(b => b.querySelector('.columns-grid')),
        ...state.melody1Blocks.map(m => m.querySelector('.columns-grid')),
        ...state.melody2Blocks.map(m => m.querySelector('.columns-grid')),
        ...state.drumBlocks.map(d => {
          const dw = d.querySelector('.drum-wrapper');
          return dw ? dw.querySelector('.columns-grid') : d.querySelector('.columns-grid');
        })
      ].filter(Boolean);
      allGrids.forEach(grid => {
        const targetColumn = grid.querySelector(`.column:nth-child(${targetColumnIndex + 1})`);
        if (targetColumn) {
          targetColumn.scrollIntoView({
            behavior: 'smooth',
            block: 'nearest',
            inline: 'start'
          });
        }
      });
    });
  }
}

// ===== INICIALIZAR =====
window.addEventListener('load', initializeApp);
</script>
</body>
</html>

