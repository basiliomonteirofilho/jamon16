<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jam On ‚Äì Composi√ß√£o Manual</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      background: #121212;
      color: #e0e0e0;
      margin: 0;
      padding: 20px;
    }
    header {
      text-align: center;
      margin-bottom: 20px;
    }
    h1 {
      color: #5eead4;
      font-size: 1.8em;
      margin: 0;
    }
    .pill {
      display: inline-block;
      background: #333;
      color: #aaa;
      font-size: 0.75em;
      padding: 4px 10px;
      border-radius: 12px;
    }
    .card {
      max-width: 900px;
      margin: 0 auto;
      background: #1e1e1e;
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      overflow: hidden;
      padding: 20px;
      text-align: left;
    }
    .chord-display {
      text-align: center;
      margin: 20px 0;
    }
    .chord-name {
      font-size: 2em;
      color: #5eead4;
      margin: 0;
      font-weight: bold;
    }
    .controls {
      margin-bottom: 30px;
    }
    .btn-row {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
    }
    button {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      font-size: 1em;
      transition: opacity 0.2s;
    }
    button.primary {
      background: #5eead4;
      color: #121212;
    }
    button.danger {
      background: #f44336;
      color: white;
    }
    button:hover:not(:disabled) {
      opacity: 0.9;
    }
    .section {
      margin: 25px 0;
      padding: 15px;
      border: 1px solid #333;
      border-radius: 10px;
      background: #222;
    }
    .section h3 {
      color: #5eead4;
      margin-top: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .add-btn {
      background: #4CAF50;
      color: white;
      font-size: 1.2em;
      padding: 6px 10px;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    .melody-block-container {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin: 10px 0;
    }
    .melody-block-group {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      border-left: 4px solid #5eead4;
    }
    .block-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .melody-grid {
      display: flex;
      gap: 2px;
    }
    .cell {
      width: 35px;
      height: 35px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7em;
      cursor: pointer;
      color: #ccc;
      user-select: none;
      position: relative;
    }
    .cell.selected {
      background: #5eead4;
      color: #121212;
    }
    .cell.x {
      background: #555;
      color: #aaa;
    }
    .bass-group { border-left-color: #ffcc00; }
    .melody1-group { border-left-color: #ff6b6b; }
    .melody2-group { border-left-color: #4ecdc4; }

    .drum-container {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin: 10px 0;
    }
    .drum-block {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      border-left: 4px solid #8e44ad;
    }
    .drum-grid {
      display: grid;
      grid-template-columns: 150px repeat(4, 1fr);
      gap: 2px;
      margin-top: 10px;
    }
    .drum-row {
      display: contents;
    }
    .drum-label {
      padding: 8px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-right: none;
      text-align: right;
      font-size: 0.8em;
      color: #ccc;
    }
    .drum-cell {
      aspect-ratio: 1 / 1;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7em;
      cursor: pointer;
      color: #ccc;
    }
    .drum-cell.active {
      background: #5eead4;
      color: #121212;
    }
    .instructions {
      font-size: 0.85em;
      color: #aaa;
      margin-top: 8px;
      text-align: center;
    }
    
    /* BPM Control */
    .bpm-control {
      text-align: center;
      margin: 15px 0;
    }
    .bpm-display {
      font-size: 1.5em;
      font-weight: bold;
      color: #5eead4;
      margin: 10px 0;
    }
    .bpm-slider {
      width: 80%;
      margin: 10px auto;
    }
    
    /* Instrument Selection */
    .instrument-select {
      margin: 15px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }
    .instrument-option {
      padding: 8px 15px;
      background: #333;
      border: 2px solid #444;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .instrument-option.selected {
      background: #5eead4;
      color: #121212;
      border-color: #5eead4;
    }
    .instrument-option:hover {
      background: #444;
    }
    
    /* Loading indicator */
    .loading {
      text-align: center;
      padding: 20px;
      color: #5eead4;
    }
    
    /* Mobile */
    @media (max-width: 768px) {
      .chord-name { font-size: 1.5em; }
      .cell, .drum-cell { 
        width: 30px;
        height: 30px;
        font-size: 0.6em;
      }
      .drum-label { font-size: 0.7em; padding: 6px; }
      button { padding: 10px 15px; }
      .add-btn { width: 25px; height: 25px; font-size: 1em; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Jam On ‚Äì Composi√ß√£o Manual</h1>
    <div class="pill">Cada c√©lula = semicolcheia (1/4 da sem√≠nima)</div>
  </header>

  <div class="card">
    <!-- CONTROLE DE BPM -->
    <div class="section">
      <h3>üéõÔ∏è Controle de BPM</h3>
      <div class="bpm-control">
        <div class="bpm-display" id="bpmDisplay">100 BPM</div>
        <input type="range" id="bpmSlider" class="bpm-slider" min="60" max="180" value="100" step="1">
      </div>
    </div>

    <!-- SE√á√ÉO DE BLOCO PRINCIPAL -->
    <div class="section">
      <h3>üéµ Composi√ß√£o <span class="add-btn" id="addMainBlock">+</span></h3>
      <div id="mainBlocksContainer" class="melody-block-container"></div>
    </div>

    <!-- MATRIZ DE BATERIA -->
    <div class="section">
      <h3>ü•Å Bateria <span class="add-btn" id="addDrumBlock">+</span></h3>
      <div id="drumContainer" class="drum-container"></div>
    </div>

    <!-- CONTROLES -->
    <div class="btn-row">
      <button id="btnPlay" class="primary">‚ñ∂ Play</button>
      <button id="btnStop" class="danger">‚èπ Stop</button>
      <button id="btnSaveWAV" class="primary">üíæ Salvar como WAV</button>
    </div>

    <div class="instructions">
      Clique em uma c√©lula para escolher uma nota. Clique √† esquerda do centro para diminuir, √† direita para aumentar.<br>
      Use o bot√£o "+" para adicionar mais blocos de 4 c√©lulas (uma sem√≠nima).
    </div>
    
    <div id="loadingIndicator" class="loading" style="display: none;">
      Carregando samples de √°udio...
    </div>
  </div>

  <script>
    // ===== CONSTANTES =====
    const AVAILABLE_CHORDS = [
      // Acordes em A
      'A', 'A11', 'A13', 'A4', 'A45+', 'A5', 'A5+', 'A6', 'A7', 'A75+', 'A9', 'A95+', 'Adim', 
      'Am', 'Am4', 'Am5', 'Am5+', 'Am6', 'Am7', 'Am75+', 'Am79', 'Am9',
      // Acordes em AS (A#)
      'AS', 'AS11', 'AS13', 'AS4', 'AS45+', 'AS5', 'AS5+', 'AS6', 'AS7', 'AS75+', 'AS9', 'AS95+',
      'ASdim', 'ASm', 'ASm4', 'ASm5', 'ASm5+', 'ASm6', 'ASm7', 'ASm75+', 'ASm79', 'ASm9',
      // Acordes em B
      'B', 'B11', 'B13', 'B4', 'B45+', 'B5', 'B5+', 'B6', 'B7', 'B75+', 'B9', 'B95+', 'Bdim',
      'Bm', 'Bm4', 'Bm5', 'Bm5+', 'Bm6', 'Bm7', 'Bm75+', 'Bm79', 'Bm9',
      // Acordes em C
      'C', 'C11', 'C13', 'C4', 'C45+', 'C5', 'C5+', 'C6', 'C7', 'C75+', 'C9', 'C95+', 'Cdim',
      'Cm', 'Cm4', 'Cm5', 'Cm5+', 'Cm6', 'Cm7', 'Cm75+', 'Cm79', 'Cm9',
      // Acordes em CS (C#)
      'CS', 'CS11', 'CS13', 'CS4', 'CS45+', 'CS5', 'CS5+', 'CS6', 'CS7', 'CS75+', 'CS9', 'CS95+',
      'CSdim', 'CSm', 'CSm4', 'CSm5', 'CSm5+', 'CSm6', 'CSm7', 'CSm75+', 'CSm79', 'CSm9',
      // Acordes em D
      'D', 'D11', 'D13', 'D4', 'D45+', 'D5', 'D5+', 'D6', 'D7', 'D75+', 'D9', 'D95+', 'Ddim',
      'Dm', 'Dm4', 'Dm5', 'Dm5+', 'Dm6', 'Dm7', 'Dm75+', 'Dm79', 'Dm9',
      // Acordes em E
      'E', 'E11', 'E13', 'E4', 'E45+', 'E5', 'E5+', 'E6', 'E7', 'E75+', 'E9', 'E95+', 'Edim',
      'Em', 'Em4', 'Em5', 'Em5+', 'Em6', 'Em7', 'Em75+', 'Em79', 'Em9',
      // Acordes em DS (D#)
      'DS', 'DS11', 'DS13', 'DS4', 'DS45+', 'DS5', 'DS5+', 'DS6', 'DS7', 'DS75+', 'DS9', 'DS95+',
      'DSdim', 'DSm', 'DSm4', 'DSm5', 'DSm5+', 'DSm6', 'DSm7', 'DSm75+', 'DSm79', 'DSm9',
      // Acordes em F
      'F', 'F11', 'F13', 'F4', 'F45+', 'F5', 'F5+', 'F6', 'F7', 'F75+', 'F9', 'F95+', 'Fdim',
      'Fm', 'Fm4', 'Fm5', 'Fm5+', 'Fm6', 'Fm7', 'Fm75+', 'Fm79', 'Fm9',
      // Acordes em FS (F#)
      'FS', 'FS11', 'FS13', 'FS4', 'FS45+', 'FS5', 'FS5+', 'FS6', 'FS7', 'FS75+', 'FS9', 'FS95+',
      'FSdim', 'FSm', 'FSm4', 'FSm5', 'FSm5+', 'FSm6', 'FSm7', 'FSm75+', 'FSm79', 'FSm9',
      // Acordes em G
      'G', 'G11', 'G13', 'G4', 'G45+', 'G5', 'G5+', 'G6', 'G7', 'G75+', 'G9', 'G95+', 'Gdim',
      'Gm', 'Gm4', 'Gm5', 'Gm5+', 'Gm6', 'Gm7', 'Gm75+', 'Gm79', 'Gm9',
      // Acordes em GS (G#)
      'GS', 'GS11', 'GS13', 'GS4', 'GS45+', 'GS5', 'GS5+', 'GS6', 'GS7', 'GS75+', 'GS9', 'GS95+',
      'GSdim', 'GSm', 'GSm4', 'GSm5', 'GSm5+', 'GSm6', 'GSm7', 'GSm75+', 'GSm79', 'GSm9'
    ];

    // Parse nomes.txt to get note names
    const NOTE_NAMES = [
      '10CS.mp3', '11D.mp3', '12DS.mp3', '13E.mp3', '14F.mp3', '15FS.mp3', '16G.mp3', '17GS.mp3', 
      '18A.mp3', '19AS.mp3', '1E.mp3', '20B.mp3', '21C.mp3', '22CS.mp3', '23D.mp3', '24DS.mp3', 
      '25E.mp3', '26F.mp3', '27FS.mp3', '28G.mp3', '29GS.mp3', '2F.mp3', '30A.mp3', '31AS.mp3', 
      '32B.mp3', '33C.mp3', '34CS.mp3', '35D.mp3', '36DS.mp3', '37E.mp3', '38F.mp3', '39FS.mp3', 
      '3FS.mp3', '40G.mp3', '41GS.mp3', '42A.mp3', '43AS.mp3', '44B.mp3', '45C.mp3', '46CS.mp3', 
      '47D.mp3', '48DS.mp3', '49E.mp3', '4G.mp3', '5GS.mp3', '6A.mp3', '7AS.mp3', '8B.mp3', '9C.mp3'
    ];

    // Extract just the note identifiers (without .mp3)
    const NOTE_IDS = NOTE_NAMES.map(name => name.replace('.mp3', ''));

    // Create mapping from number to note name
    const NUM_TO_NOTE = {};
    const NOTE_TO_NUM = {};
    NOTE_IDS.forEach(note => {
      const match = note.match(/^(\d+)([A-Z]+)$/);
      if (match) {
        const num = parseInt(match[1]);
        const noteName = match[2];
        NUM_TO_NOTE[num] = noteName;
        NOTE_TO_NUM[note] = num;
      }
    });

    // Get all note numbers sorted
    const ALL_NOTES = Object.keys(NUM_TO_NOTE).map(n => parseInt(n)).sort((a, b) => a - b);
    const MIN_NOTE = Math.min(...ALL_NOTES);
    const MAX_NOTE = Math.max(...ALL_NOTES);

    // Drum samples
    const DRUM_SAMPLES = [
      'ataque.mp3', 'bumbo.mp3', 'chimbal.mp3', 'chimbal-aberto.mp3', 
      'conducao.mp3', 'surdo.mp3', 'tom-1.mp3', 'tom-2.mp3'
    ];

    // Instrument folders
    const INSTRUMENT_FOLDERS = {
      'bass': 'BaixoMelodia',
      'piano': 'PianoString',
      'sax': 'SaxMelodia',
      'violin': 'ViolinMelodia', // Assumindo que existe
      'flute': 'FluteMelodia',   // Assumindo que existe
      'distorted-guitar': 'GuitarraDistorcida',
      'clean-guitar': 'GuitarraLimpa'
    };

    // ===== ESTADO =====
    const state = {
      running: false,
      paused: false,
      bpm: 100,
      stepIndex: 0,
      totalSteps: 4,
      buffers: {},
      activeInput: null,
      schedulerTimer: null,
      mainBlocks: [], // Array of main block groups (each containing bass, melody1, melody2)
      drumBlocks: [],
      drumPattern: {},
      lastNoteTime: 0,
      recordedChunks: [],
      audioCtx: null,
      isLoaded: false
    };

    // ===== ELEMENTOS =====
    const ui = {
      bpmSlider: document.getElementById('bpmSlider'),
      bpmDisplay: document.getElementById('bpmDisplay'),
      btnPlay: document.getElementById('btnPlay'),
      btnStop: document.getElementById('btnStop'),
      btnSaveWAV: document.getElementById('btnSaveWAV'),
      addMainBlock: document.getElementById('addMainBlock'),
      addDrumBlock: document.getElementById('addDrumBlock'),
      mainBlocksContainer: document.getElementById('mainBlocksContainer'),
      drumContainer: document.getElementById('drumContainer'),
      loadingIndicator: document.getElementById('loadingIndicator')
    };

    // ===== INICIALIZA√á√ÉO =====
    async function initializeApp() {
      // Initialize BPM
      updateBPMDisplay();
      ui.bpmSlider.addEventListener('input', handleBPMChange);
      
      // Event listeners
      ui.btnPlay.addEventListener('click', onPlay);
      ui.btnStop.addEventListener('click', onStop);
      ui.btnSaveWAV.addEventListener('click', () => renderAndDownloadWAV(8));
      ui.addMainBlock.addEventListener('click', addMainBlock);
      ui.addDrumBlock.addEventListener('click', addDrumBlock);
      
      // Add first main block
      addMainBlock();
      addDrumBlock();
      
      // Load audio samples
      await loadAudioSamples();
      state.isLoaded = true;
      ui.loadingIndicator.style.display = 'none';
      ui.btnPlay.disabled = false;
    }

    function handleBPMChange() {
      state.bpm = parseInt(ui.bpmSlider.value);
      updateBPMDisplay();
    }

    function updateBPMDisplay() {
      ui.bpmDisplay.textContent = `${state.bpm} BPM`;
    }

    // ===== BLOCOS PRINCIPAIS (SINCRONIZADOS) =====
    function addMainBlock() {
      const blockIndex = state.mainBlocks.length;
      
      // Create main block group container
      const blockGroup = document.createElement('div');
      blockGroup.className = 'melody-block-group';
      blockGroup.dataset.blockIndex = blockIndex;
      
      // Block header with block number
      const header = document.createElement('div');
      header.className = 'block-header';
      header.innerHTML = `<h4>Bloco ${blockIndex + 1}</h4>`;
      blockGroup.appendChild(header);
      
      // Add Bass section
      const bassSection = createInstrumentSection('üé∏ Baixo', 'bass', blockIndex, 'bass-group');
      blockGroup.appendChild(bassSection);
      
      // Add Melody 1 section
      const melody1Section = createInstrumentSection('üéπ Melodia 1', 'melody1', blockIndex, 'melody1-group');
      blockGroup.appendChild(melody1Section);
      
      // Add Melody 2 section
      const melody2Section = createInstrumentSection('üé∑ Melodia 2', 'melody2', blockIndex, 'melody2-group');
      blockGroup.appendChild(melody2Section);
      
      ui.mainBlocksContainer.appendChild(blockGroup);
      
      // Store reference
      state.mainBlocks.push({
        element: blockGroup,
        index: blockIndex
      });
    }

    function createInstrumentSection(title, type, blockIndex, cssClass) {
      const section = document.createElement('div');
      section.className = cssClass;
      section.style.margin = '15px 0';
      section.style.padding = '10px';
      section.style.borderRadius = '6px';
      
      // Title with instrument selection
      const titleDiv = document.createElement('div');
      titleDiv.style.display = 'flex';
      titleDiv.style.justifyContent = 'space-between';
      titleDiv.style.alignItems = 'center';
      titleDiv.style.marginBottom = '10px';
      
      const titleText = document.createElement('strong');
      titleText.textContent = title;
      titleDiv.appendChild(titleText);
      
      // Instrument selector
      const instrumentSelect = document.createElement('select');
      instrumentSelect.className = 'instrument-select-inline';
      instrumentSelect.style.padding = '5px';
      instrumentSelect.style.borderRadius = '4px';
      instrumentSelect.style.background = '#333';
      instrumentSelect.style.color = 'white';
      instrumentSelect.style.border = '1px solid #555';
      
      // Define instruments based on type
      let instruments = [];
      if (type === 'bass') {
        instruments = [
          { value: 'bass', label: 'Baixo' }
        ];
      } else if (type === 'melody1' || type === 'melody2') {
        instruments = [
          { value: 'piano', label: 'Piano' },
          { value: 'sax', label: 'Saxofone' },
          { value: 'violin', label: 'Violino' },
          { value: 'flute', label: 'Flauta' }
        ];
      }
      
      // Add options
      instruments.forEach(inst => {
        const option = document.createElement('option');
        option.value = inst.value;
        option.textContent = inst.label;
        instrumentSelect.appendChild(option);
      });
      
      titleDiv.appendChild(instrumentSelect);
      section.appendChild(titleDiv);
      
      // Chord selector for this block
      if (type !== 'bass') {
        const chordDiv = document.createElement('div');
        chordDiv.style.margin = '10px 0';
        
        const chordLabel = document.createElement('label');
        chordLabel.textContent = 'Harmonia: ';
        chordLabel.style.marginRight = '5px';
        chordDiv.appendChild(chordLabel);
        
        const chordSelect = document.createElement('select');
        chordSelect.className = `chord-select-${type}-${blockIndex}`;
        chordSelect.style.padding = '5px';
        chordSelect.style.borderRadius = '4px';
        chordSelect.style.background = '#333';
        chordSelect.style.color = 'white';
        chordSelect.style.border = '1px solid #555';
        chordSelect.style.width = '60%';
        
        // Populate with chords
        AVAILABLE_CHORDS.forEach(chord => {
          const option = document.createElement('option');
          option.value = chord;
          option.textContent = chord;
          chordSelect.appendChild(option);
        });
        
        chordDiv.appendChild(chordSelect);
        section.appendChild(chordDiv);
      }
      
      // Create note grid (4 cells for semiquavers)
      const grid = document.createElement('div');
      grid.className = 'melody-grid';
      grid.dataset.type = type;
      grid.dataset.blockIndex = blockIndex;
      
      for (let i = 0; i < 4; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.step = i;
        cell.textContent = '';
        
        // Enhanced click handling - left side decreases, right side increases
        cell.addEventListener('click', function(e) {
          const rect = this.getBoundingClientRect();
          const clickX = e.clientX - rect.left;
          const centerX = rect.width / 2;
          
          let currentNum = ALL_NOTES[0];
          let currentText = this.textContent;
          
          if (currentText === 'X') {
            currentNum = ALL_NOTES[0];
            this.classList.remove('x');
          } else if (currentText) {
            const match = currentText.match(/^(\d+)/);
            if (match) {
              currentNum = parseInt(match[1]);
            }
          }
          
          // Left side of center: decrease note
          if (clickX < centerX) {
            let currentIndex = ALL_NOTES.indexOf(currentNum);
            if (currentIndex > 0) {
              currentNum = ALL_NOTES[currentIndex - 1];
            } else {
              currentNum = ALL_NOTES[ALL_NOTES.length - 1];
            }
          } 
          // Right side of center: increase note
          else {
            let currentIndex = ALL_NOTES.indexOf(currentNum);
            if (currentIndex < ALL_NOTES.length - 1) {
              currentNum = ALL_NOTES[currentIndex + 1];
            } else {
              currentNum = ALL_NOTES[0];
            }
          }
          
          this.textContent = currentNum + (NUM_TO_NOTE[currentNum] || '');
        });
        
        // Double click for rest (X)
        cell.addEventListener('dblclick', function() {
          if (this.textContent === 'X') {
            this.textContent = '';
            this.classList.remove('x');
          } else {
            this.textContent = 'X';
            this.classList.add('x');
          }
        });
        
        grid.appendChild(cell);
      }
      
      section.appendChild(grid);
      return section;
    }

    // ===== BATERIA =====
    function addDrumBlock() {
      const blockIndex = state.drumBlocks.length;
      
      // Initialize drum pattern for this block
      if (!state.drumPattern[blockIndex]) {
        state.drumPattern[blockIndex] = {};
        DRUM_SAMPLES.forEach(sample => {
          const key = sample.replace('.mp3', '');
          state.drumPattern[blockIndex][key] = Array(4).fill(false);
        });
      }
      
      // Create drum block
      const blockDiv = document.createElement('div');
      blockDiv.className = 'drum-block';
      blockDiv.dataset.blockId = blockIndex;
      
      const title = document.createElement('div');
      title.textContent = `Bloco de Bateria ${blockIndex + 1}`;
      title.style.color = '#5eead4';
      title.style.fontWeight = 'bold';
      title.style.marginBottom = '10px';
      blockDiv.appendChild(title);
      
      const gridDiv = document.createElement('div');
      gridDiv.className = 'drum-grid';
      
      // Add drum rows
      const drumLabels = [
        { key: 'bumbo', label: 'Bumbo' },
        { key: 'ataque', label: 'Caixa' },
        { key: 'chimbal-aberto', label: 'Chimbal Aberto' },
        { key: 'chimbal', label: 'Chimbal Fechado' },
        { key: 'conducao', label: 'Prato de Ataque' },
        { key: 'tom-1', label: 'Tom 1' },
        { key: 'tom-2', label: 'Tom 2' },
        { key: 'surdo', label: 'Surdo' }
      ];
      
      drumLabels.forEach(drum => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'drum-row';
        
        const labelDiv = document.createElement('div');
        labelDiv.className = 'drum-label';
        labelDiv.textContent = drum.label;
        rowDiv.appendChild(labelDiv);
        
        for (let i = 0; i < 4; i++) {
          const cell = document.createElement('div');
          cell.className = 'drum-cell';
          cell.dataset.step = i;
          cell.dataset.instr = drum.key;
          cell.dataset.block = blockIndex;
          
          // Set active state if previously set
          if (state.drumPattern[blockIndex][drum.key][i]) {
            cell.classList.add('active');
          }
          
          cell.addEventListener('click', function() {
            const blockId = parseInt(this.dataset.block);
            const instr = this.dataset.instr;
            const step = parseInt(this.dataset.step);
            
            state.drumPattern[blockId][instr][step] = !state.drumPattern[blockId][instr][step];
            this.classList.toggle('active', state.drumPattern[blockId][instr][step]);
          });
          
          rowDiv.appendChild(cell);
        }
        
        gridDiv.appendChild(rowDiv);
      });
      
      blockDiv.appendChild(gridDiv);
      ui.drumContainer.appendChild(blockDiv);
      state.drumBlocks.push(blockDiv);
    }

    // ===== AUDIO LOADING =====
    async function loadAudioSamples() {
      ui.loadingIndicator.style.display = 'block';
      ui.btnPlay.disabled = true;
      
      try {
        // Initialize Audio Context
        state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        // Create gain nodes
        state.masterGain = state.audioCtx.createGain();
        state.drumGain = state.audioCtx.createGain();
        state.bassGain = state.audioCtx.createGain();
        state.melodyGain = state.audioCtx.createGain();
        state.harmonicGain = state.audioCtx.createGain();
        
        // Connect gain nodes
        state.masterGain.connect(state.audioCtx.destination);
        state.drumGain.connect(state.masterGain);
        state.bassGain.connect(state.masterGain);
        state.melodyGain.connect(state.masterGain);
        state.harmonicGain.connect(state.masterGain);
        
        // Set volumes
        state.masterGain.gain.value = 0.8;
        state.drumGain.gain.value = 0.6;
        state.bassGain.gain.value = 0.5;
        state.melodyGain.gain.value = 0.5;
        state.harmonicGain.gain.value = 0.5;
        
        // Initialize buffers object
        state.buffers = {};
        
        // Load drum samples
        for (const sample of DRUM_SAMPLES) {
          const key = sample.replace('.mp3', '');
          state.buffers[key] = await loadAudioFile(`./${sample}`);
        }
        
        // Load instrument samples
        for (const [instrument, folder] of Object.entries(INSTRUMENT_FOLDERS)) {
          state.buffers[folder] = {};
          
          for (const noteId of NOTE_IDS) {
            const filename = `${noteId}.mp3`;
            state.buffers[folder][noteId] = await loadAudioFile(`./${folder}/${filename}`);
          }
        }
        
        console.log('All audio samples loaded successfully');
      } catch (error) {
        console.error('Error loading audio samples:', error);
        alert('Erro ao carregar samples de √°udio: ' + error.message);
      }
    }

    // Load an audio file and return an AudioBuffer
    async function loadAudioFile(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) {
          console.warn(`Audio file not found: ${url}`);
          return null;
        }
        
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await state.audioCtx.decodeAudioData(arrayBuffer);
        return audioBuffer;
      } catch (error) {
        console.warn(`Error loading audio file ${url}:`, error);
        return null;
      }
    }

    // ===== NOTAS E ACORDES =====
    function getChordNotes(chordName) {
      // Extract root note (first letter or first two if it's AS, CS, etc.)
      let root = chordName.substring(0, 2);
      if (!['AS', 'CS', 'DS', 'FS', 'GS'].includes(root)) {
        root = chordName.substring(0, 1);
      }
      
      // Map to standard note names
      const noteMap = {
        'C': 0, 'CS': 1, 'D': 2, 'DS': 3, 'E': 4, 'F': 5, 
        'FS': 6, 'G': 7, 'GS': 8, 'A': 9, 'AS': 10, 'B': 11
      };
      
      const rootIndex = noteMap[root];
      if (rootIndex === undefined) return [root];
      
      // Determine chord type
      let chordType = 'major';
      if (chordName.includes('m') && !chordName.includes('dim')) chordType = 'minor';
      if (chordName.includes('dim')) chordType = 'diminished';
      
      // Generate chord notes
      let notes = [];
      switch(chordType) {
        case 'major':
          notes = [rootIndex, (rootIndex + 4) % 12, (rootIndex + 7) % 12];
          break;
        case 'minor':
          notes = [rootIndex, (rootIndex + 3) % 12, (rootIndex + 7) % 12];
          break;
        case 'diminished':
          notes = [rootIndex, (rootIndex + 3) % 12, (rootIndex + 6) % 12];
          break;
        default:
          notes = [rootIndex, (rootIndex + 4) % 12, (rootIndex + 7) % 12];
      }
      
      // Convert back to note names
      const reverseNoteMap = ['C', 'CS', 'D', 'DS', 'E', 'F', 'FS', 'G', 'GS', 'A', 'AS', 'B'];
      return notes.map(index => reverseNoteMap[index]);
    }

    function adaptNoteToChord(noteNum, chordName) {
      if (!NUM_TO_NOTE[noteNum]) return noteNum;
      
      const noteName = NUM_TO_NOTE[noteNum];
      const chordNotes = getChordNotes(chordName);
      
      // If note is in chord, keep it
      if (chordNotes.includes(noteName)) return noteNum;
      
      // Otherwise find closest chord note
      const noteMap = {
        'C': 0, 'CS': 1, 'D': 2, 'DS': 3, 'E': 4, 'F': 5, 
        'FS': 6, 'G': 7, 'GS': 8, 'A': 9, 'AS': 10, 'B': 11
      };
      
      const noteIndex = noteMap[noteName];
      if (noteIndex === undefined) return noteNum;
      
      // Find closest chord note
      let closestNote = chordNotes[0];
      let minDistance = 12;
      
      for (const chordNote of chordNotes) {
        const chordIndex = noteMap[chordNote];
        if (chordIndex === undefined) continue;
        
        // Calculate distance (considering circular nature of notes)
        let distance = Math.abs(noteIndex - chordIndex);
        if (distance > 6) distance = 12 - distance;
        
        if (distance < minDistance) {
          minDistance = distance;
          closestNote = chordNote;
        }
      }
      
      // Find a note number that corresponds to the closest chord note
      for (let i = 1; i <= 49; i++) {
        if (NUM_TO_NOTE[i] === closestNote) {
          return i;
        }
      }
      
      return noteNum; // fallback
    }

    // ===== PLAYBACK =====
    function playSample(key, time, gainNode, volume = 1.0) {
      if (!state.audioCtx) {
        console.error('Audio context not initialized');
        return;
      }
      
      if (!state.buffers[key]) {
        console.warn('Sample not found:', key);
        return;
      }
      
      const src = state.audioCtx.createBufferSource();
      const g = state.audioCtx.createGain();
      src.buffer = state.buffers[key];
      src.connect(g);
      g.connect(gainNode);
      g.gain.setValueAtTime(0, time);
      g.gain.linearRampToValueAtTime(volume, time + 0.01);
      g.gain.linearRampToValueAtTime(0, time + 0.2);
      src.start(time);
      src.stop(time + src.buffer.duration);
    }

    function playNoteSample(folder, noteId, time, gainNode, volume = 1.0) {
      if (!state.buffers[folder] || !state.buffers[folder][noteId]) {
        console.warn('Note sample not found:', folder, noteId);
        return;
      }
      
      const src = state.audioCtx.createBufferSource();
      const g = state.audioCtx.createGain();
      src.buffer = state.buffers[folder][noteId];
      src.connect(g);
      g.connect(gainNode);
      g.gain.setValueAtTime(0, time);
      g.gain.linearRampToValueAtTime(volume, time + 0.01);
      g.gain.linearRampToValueAtTime(0, time + 0.2);
      src.start(time);
      src.stop(time + src.buffer.duration);
    }

    function buildPlaybackPlan() {
      const plan = {
        bass: [],
        melody1: [],
        melody2: [],
        harmony1: [], // Chord for melody1
        harmony2: [], // Chord for melody2
        drums: {}
      };
      
      // Initialize drum patterns
      DRUM_SAMPLES.forEach(sample => {
        const key = sample.replace('.mp3', '');
        plan.drums[key] = [];
      });

      // Collect all drum patterns from all blocks
      for (let blockId = 0; blockId < state.drumBlocks.length; blockId++) {
        DRUM_SAMPLES.forEach(sample => {
          const key = sample.replace('.mp3', '');
          if (state.drumPattern[blockId] && state.drumPattern[blockId][key]) {
            state.drumPattern[blockId][key].forEach(step => {
              plan.drums[key].push(step);
            });
          }
        });
      }

      // Collect data from all main blocks
      state.mainBlocks.forEach((block, blockIndex) => {
        // Get bass grid
        const bassGrid = block.element.querySelector('.melody-grid[data-type="bass"]');
        if (bassGrid) {
          const cells = bassGrid.querySelectorAll('.cell');
          cells.forEach(cell => {
            const val = cell.textContent;
            if (val === 'X') {
              plan.bass.push(null);
            } else if (val) {
              const match = val.match(/^(\d+)/);
              if (match) {
                const num = parseInt(match[1]);
                plan.bass.push(num);
              } else {
                plan.bass.push(null);
              }
            } else {
              plan.bass.push(null);
            }
          });
        }
        
        // Get melody1 grid and harmony
        const melody1Grid = block.element.querySelector('.melody-grid[data-type="melody1"]');
        const chordSelect1 = block.element.querySelector(`.chord-select-melody1-${blockIndex}`);
        
        if (melody1Grid) {
          const cells = melody1Grid.querySelectorAll('.cell');
          const chordValue = chordSelect1 ? chordSelect1.value : 'C';
          
          cells.forEach(cell => {
            const val = cell.textContent;
            if (val === 'X') {
              plan.melody1.push(null);
              plan.harmony1.push(null);
            } else if (val) {
              const match = val.match(/^(\d+)/);
              if (match) {
                const num = parseInt(match[1]);
                plan.melody1.push(num);
                plan.harmony1.push(chordValue);
              } else {
                plan.melody1.push(null);
                plan.harmony1.push(null);
              }
            } else {
              plan.melody1.push(null);
              plan.harmony1.push(null);
            }
          });
        }
        
        // Get melody2 grid and harmony
        const melody2Grid = block.element.querySelector('.melody-grid[data-type="melody2"]');
        const chordSelect2 = block.element.querySelector(`.chord-select-melody2-${blockIndex}`);
        
        if (melody2Grid) {
          const cells = melody2Grid.querySelectorAll('.cell');
          const chordValue = chordSelect2 ? chordSelect2.value : 'C';
          
          cells.forEach(cell => {
            const val = cell.textContent;
            if (val === 'X') {
              plan.melody2.push(null);
              plan.harmony2.push(null);
            } else if (val) {
              const match = val.match(/^(\d+)/);
              if (match) {
                const num = parseInt(match[1]);
                plan.melody2.push(num);
                plan.harmony2.push(chordValue);
              } else {
                plan.melody2.push(null);
                plan.harmony2.push(null);
              }
            } else {
              plan.melody2.push(null);
              plan.harmony2.push(null);
            }
          });
        }
      });

      state.playbackPlan = plan;
      
      // Calculate total steps
      state.totalSteps = Math.max(
        plan.bass.length || 0,
        plan.melody1.length || 0,
        plan.melody2.length || 0,
        plan.harmony1.length || 0,
        plan.harmony2.length || 0,
        Object.keys(plan.drums).reduce((max, key) => Math.max(max, plan.drums[key].length || 0), 0)
      );
      
      state.stepIndex = 0;
      state.lastNoteTime = 0;
    }

    function scheduleStep(time) {
      const idx = state.stepIndex;

      // Baixo
      if (idx < state.playbackPlan.bass.length) {
        const bassNote = state.playbackPlan.bass[idx];
        if (bassNote !== null) {
          const noteId = bassNote + (NUM_TO_NOTE[bassNote] || '');
          playNoteSample('BaixoMelodia', noteId, time, state.bassGain, 0.7);
          console.log('Playing bass note:', noteId);
        }
      }

      // Melodia 1
      if (idx < state.playbackPlan.melody1.length) {
        const m1Note = state.playbackPlan.melody1[idx];
        const m1Chord = state.playbackPlan.harmony1[idx];
        
        if (m1Note !== null) {
          const adapted = adaptNoteToChord(m1Note, m1Chord || 'C');
          const noteId = adapted + (NUM_TO_NOTE[adapted] || '');
          
          // Get selected instrument for melody 1 in this block
          const blockIndex = Math.floor(idx / 4); // Assuming 4 steps per block
          const instrumentSelect = document.querySelector(`.melody-block-group:nth-child(${blockIndex + 1}) .instrument-select-inline`);
          const instrument = instrumentSelect ? instrumentSelect.value : 'piano';
          const folder = INSTRUMENT_FOLDERS[instrument] || 'PianoString';
          
          playNoteSample(folder, noteId, time, state.melodyGain, 0.6);
          console.log('Playing melody 1 note:', noteId, 'with chord:', m1Chord, 'instrument:', instrument);
        }
      }

      // Melodia 2
      if (idx < state.playbackPlan.melody2.length) {
        const m2Note = state.playbackPlan.melody2[idx];
        const m2Chord = state.playbackPlan.harmony2[idx];
        
        if (m2Note !== null) {
          const adapted = adaptNoteToChord(m2Note, m2Chord || 'C');
          const noteId = adapted + (NUM_TO_NOTE[adapted] || '');
          
          // Get selected instrument for melody 2 in this block
          const blockIndex = Math.floor(idx / 4); // Assuming 4 steps per block
          const instrumentSelect = document.querySelector(`.melody-block-group:nth-child(${blockIndex + 1}) .instrument-select-inline`);
          const instrument = instrumentSelect ? instrumentSelect.value : 'sax';
          const folder = INSTRUMENT_FOLDERS[instrument] || 'SaxMelodia';
          
          playNoteSample(folder, noteId, time, state.melodyGain, 0.6);
          console.log('Playing melody 2 note:', noteId, 'with chord:', m2Chord, 'instrument:', instrument);
        }
      }

      // Bateria
      Object.keys(state.playbackPlan.drums).forEach(d => {
        if (idx < state.playbackPlan.drums[d].length && state.playbackPlan.drums[d][idx]) {
          playSample(d, time, state.drumGain, 0.8);
          console.log('Playing drum:', d);
        }
      });

      state.stepIndex = (state.stepIndex + 1) % state.totalSteps;
    }

    function startScheduler() {
      function tick() {
        if (state.running && !state.paused && state.audioCtx) {
          const now = state.audioCtx.currentTime;
          const nextStep = state.lastNoteTime + (60 / state.bpm / 4); // sixteenth note
          
          if (now >= nextStep) {
            scheduleStep(nextStep);
            state.lastNoteTime = nextStep;
          }
        }
        requestAnimationFrame(tick);
      }
      tick();
    }

    function onPlay() {
      if (state.running) return;
      if (!state.isLoaded) {
        alert('Aguarde o carregamento dos samples de √°udio!');
        return;
      }
      
      buildPlaybackPlan();
      state.running = true;
      state.paused = false;
      state.lastNoteTime = state.audioCtx.currentTime;
      startScheduler();
      
      // Update button states
      ui.btnPlay.disabled = true;
      ui.btnStop.disabled = false;
    }

    function onStop() {
      state.running = false;
      state.paused = false;
      state.stepIndex = 0;
      state.lastNoteTime = 0;
      
      // Update button states
      ui.btnPlay.disabled = false;
      ui.btnStop.disabled = true;
    }

    // ===== GRAVA√á√ÉO WAV =====
    function audioBufferToWav(buffer) {
      const numOfChan = buffer.numberOfChannels;
      const length = buffer.length * numOfChan * 2 + 44;
      const arrayBuffer = new ArrayBuffer(length);
      const view = new DataView(arrayBuffer);
      const channels = [];
      let i, sample, offset = 0;

      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }
      
      writeString(view, 0, 'RIFF');
      view.setUint32(4, length - 8, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numOfChan, true);
      view.setUint32(24, 44100, true);
      view.setUint32(28, 44100 * 2 * numOfChan, true);
      view.setUint16(32, 2 * numOfChan, true);
      view.setUint16(34, 16, true);
      writeString(view, 36, 'data');
      view.setUint32(40, length - 44, true);

      for (i = 0; i < buffer.numberOfChannels; i++) {
        channels.push(buffer.getChannelData(i));
      }

      offset = 44;
      for (i = 0; i < buffer.length; i++) {
        for (let channel = 0; channel < numOfChan; channel++) {
          sample = Math.max(-1, Math.min(1, channels[channel][i]));
          sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF);
          view.setInt16(offset, sample, true);
          offset += 2;
        }
      }
      
      return new Blob([view], { type: 'audio/wav' });
    }

    async function renderAndDownloadWAV(durationInSeconds) {
      if (!state.isLoaded) {
        alert('Aguarde o carregamento dos samples de √°udio!');
        return;
      }

      const sampleRate = 44100;
      const totalLength = Math.ceil(durationInSeconds * sampleRate);
      const offlineCtx = new OfflineAudioContext(2, totalLength, sampleRate);

      const master = offlineCtx.createGain();
      const drumGain = offlineCtx.createGain();
      const bassGain = offlineCtx.createGain();
      const melodyGain = offlineCtx.createGain();
      const harmonicGain = offlineCtx.createGain();

      master.connect(offlineCtx.destination);
      drumGain.connect(master);
      bassGain.connect(master);
      melodyGain.connect(master);
      harmonicGain.connect(master);

      master.gain.value = 0.8;
      drumGain.gain.value = 0.6;
      bassGain.gain.value = 0.5;
      melodyGain.gain.value = 0.5;
      harmonicGain.gain.value = 0.5;

      buildPlaybackPlan();

      const sixteenthDur = 60 / state.bpm / 4;
      const totalSteps = state.totalSteps;

      for (let step = 0; step < totalSteps; step++) {
        const time = step * sixteenthDur;
        if (time >= durationInSeconds) break;

        // Baixo
        if (step < state.playbackPlan.bass.length) {
          const bassNote = state.playbackPlan.bass[step];
          if (bassNote !== null) {
            const noteId = bassNote + (NUM_TO_NOTE[bassNote] || '');
            if (state.buffers['BaixoMelodia'] && state.buffers['BaixoMelodia'][noteId]) {
              const src = offlineCtx.createBufferSource();
              const g = offlineCtx.createGain();
              src.buffer = state.buffers['BaixoMelodia'][noteId];
              src.connect(g);
              g.connect(bassGain);
              g.gain.setValueAtTime(0, time);
              g.gain.linearRampToValueAtTime(0.7, time + 0.01);
              g.gain.linearRampToValueAtTime(0, time + 0.2);
              src.start(time);
            }
          }
        }

        // Melodia 1
        if (step < state.playbackPlan.melody1.length) {
          const m1Note = state.playbackPlan.melody1[step];
          const m1Chord = state.playbackPlan.harmony1[step];
          
          if (m1Note !== null) {
            const adapted = adaptNoteToChord(m1Note, m1Chord || 'C');
            const noteId = adapted + (NUM_TO_NOTE[adapted] || '');
            
            // Get instrument for this block
            const blockIndex = Math.floor(step / 4);
            const instrumentSelect = document.querySelector(`.melody-block-group:nth-child(${blockIndex + 1}) .instrument-select-inline`);
            const instrument = instrumentSelect ? instrumentSelect.value : 'piano';
            const folder = INSTRUMENT_FOLDERS[instrument] || 'PianoString';
            
            if (state.buffers[folder] && state.buffers[folder][noteId]) {
              const src = offlineCtx.createBufferSource();
              const g = offlineCtx.createGain();
              src.buffer = state.buffers[folder][noteId];
              src.connect(g);
              g.connect(melodyGain);
              g.gain.setValueAtTime(0, time);
              g.gain.linearRampToValueAtTime(0.6, time + 0.01);
              g.gain.linearRampToValueAtTime(0, time + 0.2);
              src.start(time);
            }
          }
        }
        
        // Melodia 2
        if (step < state.playbackPlan.melody2.length) {
          const m2Note = state.playbackPlan.melody2[step];
          const m2Chord = state.playbackPlan.harmony2[step];
          
          if (m2Note !== null) {
            const adapted = adaptNoteToChord(m2Note, m2Chord || 'C');
            const noteId = adapted + (NUM_TO_NOTE[adapted] || '');
            
            // Get instrument for this block
            const blockIndex = Math.floor(step / 4);
            const instrumentSelect = document.querySelector(`.melody-block-group:nth-child(${blockIndex + 1}) .instrument-select-inline`);
            const instrument = instrumentSelect ? instrumentSelect.value : 'sax';
            const folder = INSTRUMENT_FOLDERS[instrument] || 'SaxMelodia';
            
            if (state.buffers[folder] && state.buffers[folder][noteId]) {
              const src = offlineCtx.createBufferSource();
              const g = offlineCtx.createGain();
              src.buffer = state.buffers[folder][noteId];
              src.connect(g);
              g.connect(melodyGain);
              g.gain.setValueAtTime(0, time);
              g.gain.linearRampToValueAtTime(0.6, time + 0.01);
              g.gain.linearRampToValueAtTime(0, time + 0.2);
              src.start(time);
            }
          }
        }

        // Bateria
        Object.keys(state.playbackPlan.drums).forEach(d => {
          if (step < state.playbackPlan.drums[d].length && state.playbackPlan.drums[d][step]) {
            if (state.buffers[d]) {
              const src = offlineCtx.createBufferSource();
              const g = offlineCtx.createGain();
              src.buffer = state.buffers[d];
              src.connect(g);
              g.connect(drumGain);
              g.gain.setValueAtTime(0, time);
              g.gain.linearRampToValueAtTime(0.8, time + 0.01);
              g.gain.linearRampToValueAtTime(0, time + 0.2);
              src.start(time);
            }
          }
        });
      }

      ui.btnSaveWAV.innerHTML = '‚è≥ Renderizando...';
      ui.btnSaveWAV.disabled = true;

      try {
        const renderedBuffer = await offlineCtx.startRendering();
        const wavBlob = audioBufferToWav(renderedBuffer);
        const fileName = `jam-on-${new Date().toISOString().slice(0,10)}-${Math.floor(Math.random()*1000)}.wav`;
        downloadBlob(wavBlob, fileName);
      } catch (error) {
        console.error('Error rendering WAV:', error);
        alert('Erro ao renderizar o arquivo WAV: ' + error.message);
      }

      ui.btnSaveWAV.innerHTML = 'üíæ Salvar como WAV';
      ui.btnSaveWAV.disabled = false;
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    }

    // ===== INICIALIZAR =====
    window.addEventListener('load', initializeApp);
  </script>
</body>
</html>
