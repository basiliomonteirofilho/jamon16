<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jam On ‚Äì Composi√ß√£o Manual</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      background: #121212;
      color: #e0e0e0;
      margin: 0;
      padding: 20px;
    }
    header {
      text-align: center;
      margin-bottom: 20px;
    }
    h1 {
      color: #5eead4;
      font-size: 1.8em;
      margin: 0;
    }
    .pill {
      display: inline-block;
      background: #333;
      color: #aaa;
      font-size: 0.75em;
      padding: 4px 10px;
      border-radius: 12px;
    }
    .card {
      max-width: 1200px;
      margin: 0 auto;
      background: #1e1e1e;
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      overflow: hidden;
      padding: 20px;
      text-align: left;
    }
    .section {
      margin: 25px 0;
      padding: 15px;
      border: 1px solid #333;
      border-radius: 10px;
      background: #222;
    }
    .section h3 {
      color: #5eead4;
      margin-top: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .add-btn {
      background: #4CAF50;
      color: white;
      font-size: 1.2em;
      padding: 6px 10px;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    .instrument-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin: 15px 0;
    }
    .instrument-block {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      min-width: 220px;
    }
    .bass-block { border-left: 4px solid #ffcc00; }
    .melody1-block { border-left: 4px solid #ff6b6b; }
    .melody2-block { border-left: 4px solid #4ecdc4; }
    .drum-block { border-left: 4px solid #8e44ad; }
    .harmony-block { border-left: 4px solid #9b59b6; }
    /* ===== ESTILO DO GRID DE COLUNAS ===== */
    .columns-grid {
      display: flex;
      gap: 2px;
      margin: 10px 0;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding: 5px 0;
      position: relative;
    }
    .column {
  display: flex;
  flex-direction: column;
  gap: 2px;
  align-items: center;
  /* --- NOVO: Fundo alternado a cada 4 colunas --- */
  background-color: transparent; /* Fundo padr√£o */
}
.column:nth-child(4n+1),
.column:nth-child(4n+2),
.column:nth-child(4n+3) {
  background-color: rgba(255, 255, 255, 0.03); /* Cinza muito claro */
}
.column:nth-child(4n) {
  background-color: rgba(255, 255, 255, 0.08); /* Cinza um pouco mais escuro, marca o final do compasso */
}
    .cell {
  width: 45px;
  height: 45px;
  background: #333;
  border: 1px solid #555;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.7em;
  cursor: pointer;
  color: #ccc;
  user-select: none;
  transition: background 0.2s;
  position: relative; /* Para posicionar o bot√£o de delete e o r√≥tulo */
}

/* Estilo do r√≥tulo num√©rico (aparece a cada 4 colunas) */
.cell .column-number-label {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.1); /* Cinza claro com baixa opacidade */
  color: rgba(255, 255, 255, 0.6);
  font-size: 0.9em;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2;
  pointer-events: none; /* Torna o r√≥tulo n√£o clic√°vel */
  border-radius: 4px;
}
    .cell:hover {
      background: #444;
    }
    .cell.x {
      background: #555;
      color: #888;
      font-weight: bold;
    }
    /* Bot√£o de Excluir C√©lula Individual (e agora tamb√©m Coluna) */
    .delete-cell-btn {
      position: absolute;
      top: -8px;
      right: -8px;
      background: #f44336;
      color: white;
      border: none;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      font-size: 0.6em;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      z-index: 10;
    }
    .delete-cell-btn:hover {
      background: #d32f2f;
    }
    /* ===== ESTILO DA BATERIA ===== */
    /* Container principal da bateria com layout em grid */
    .drum-wrapper {
  display: flex;
  align-items: flex-start;
  gap: 10px;
  width: 100%; /* For√ßa o wrapper a respeitar a largura do pai */
  min-width: 0; /* Permite que o conte√∫do interno seja cortado (crucial para overflow) */
}
    /* Coluna fixa para os r√≥tulos das pe√ßas da bateria */
    .drum-labels {
      display: flex;
      flex-direction: column;
      gap: 2px;
      align-items: flex-start;
      justify-content: flex-start;
      padding-top: 5px; /* Ajuste fino para alinhar verticalmente */
    }
    /* Estilo do r√≥tulo da pe√ßa da bateria */
    .drum-label-item {
      width: 120px;
      height: 45px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-right: none;
      border-radius: 4px 0 0 4px;
      display: flex;
      align-items: center;
      padding: 0 8px;
      text-align: left;
      font-size: 0.7em;
      color: #ccc;
      box-sizing: border-box;
    }
    /* C√©lula da bateria - agora sem o label interno */
    .drum-cell {
      width: 45px;
      height: 45px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7em;
      cursor: pointer;
      color: #ccc;
      transition: background 0.2s;
      position: relative;
    }
    .drum-cell.active {
      background: #5eead4;
      color: #121212;
    }
    .drum-cell:hover {
      background: #444;
    }
    .instrument-select, .chord-select {
      margin: 10px 0;
      padding: 8px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      color: white;
      width: 100%;
    }
    .bpm-control {
      text-align: center;
      margin: 15px 0;
    }
    .bpm-display {
      font-size: 1.5em;
      font-weight: bold;
      color: #5eead4;
      margin: 10px 0;
    }
    .bpm-slider {
      width: 80%;
      margin: 10px auto;
    }
    .btn-row {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
    }
    button {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      font-size: 1em;
      transition: opacity 0.2s;
    }
    button.primary {
      background: #5eead4;
      color: #121212;
    }
    button.danger {
      background: #f44336;
      color: white;
    }
    button:hover:not(:disabled) {
      opacity: 0.9;
    }
    .loading {
      text-align: center;
      padding: 20px;
      color: #5eead4;
    }
    .status-indicator {
      text-align: center;
      padding: 10px;
      margin: 10px 0;
      border-radius: 6px;
    }
    .status-ready {
      background: #2a4d2a;
      color: #8eff8e;
    }
    .status-loading {
      background: #4d462a;
      color: #ffe08e;
    }
    .status-error {
      background: #4d2a2a;
      color: #ff8e8e;
    }
    .instructions {
      font-size: 0.85em;
      color: #aaa;
      margin-top: 8px;
      text-align: center;
    }
    .countdown {
      font-size: 2em;
      color: #ffcc00;
      text-align: center;
      margin: 20px 0;
      font-weight: bold;
    }
    /* ===== ESTILO DO MODAL ===== */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    .modal {
      background: #2a2a2a;
      border: 2px solid #5eead4;
      border-radius: 12px;
      padding: 20px;
      max-width: 90%;
      max-height: 90%;
      overflow-y: auto;
      box-shadow: 0 0 30px rgba(94, 234, 212, 0.5);
    }
    .modal h2 {
      color: #5eead4;
      margin-top: 0;
      text-align: center;
    }
    .modal-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 8px;
      margin-top: 20px;
    }
    .modal-option {
      padding: 10px;
      background: #333;
      border: 1px solid #555;
      border-radius: 6px;
      text-align: center;
      cursor: pointer;
      transition: background 0.2s;
    }
    .modal-option:hover {
      background: #444;
    }
    .modal-option.x {
      background: #555;
      color: #888;
    }
    /* ===== ESTILO DA BARRA DE PROGRESSO ===== */
    .progress-container {
      width: 100%;
      background: #333;
      border-radius: 4px;
      margin: 10px 0;
      height: 10px;
    }
    .progress-bar {
      height: 100%;
      background: #5eead4;
      border-radius: 4px;
      width: 0%;
      transition: width 0.3s ease;
    }
    /* ===== MARCADOR DE SEM√çNIMA ===== */
    .semibreve-marker {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 1px;
      background: rgba(255, 255, 255, 0.3);
      z-index: 5;
      pointer-events: none;
    }
    .semibreve-marker::after {
      content: '|';
      position: absolute;
      top: -20px;
      left: -5px;
      color: rgba(255, 255, 255, 0.5);
      font-size: 14px;
      font-weight: bold;
    }
    /* ===== ESTILO DO MAPA DE EDI√á√ÉO ===== */
.edit-map-container {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #2a2a2a;
  border: 1px solid #444;
  border-radius: 8px;
  padding: 15px;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 4px 10px rgba(0,0,0,0.5);
  z-index: 1000;
  width: 200px;
}

.edit-map-title {
  color: #5eead4;
  font-size: 1.1em;
  margin: 0 0 15px 0;
  text-align: center;
}

.edit-map-item {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
  padding: 6px;
  border-radius: 4px;
  cursor: pointer;
  transition: background 0.2s;
}

.edit-map-item:hover {
  background: #3a3a3a;
}

.edit-map-item.active {
  background: #5eead4;
  color: #121212;
  font-weight: bold;
}

.edit-map-number {
  font-weight: bold;
  width: 25px;
  text-align: center;
  margin-right: 10px;
  color: #5eead4;
}

.edit-map-cells {
  display: flex;
  gap: 2px;
}

.edit-map-cell {
  width: 12px;
  height: 12px;
  border: 1px solid #555;
  border-radius: 2px;
  background: #333;
}

.edit-map-cell.filled {
  background: #5eead4;
}

.edit-map-cell.x {
  background: #555;
}
    @media (max-width: 768px) {
      .cell, .drum-cell { 
        width: 35px;
        height: 35px;
        font-size: 0.6em;
      }
      .drum-label-item { 
        width: 80px;
        font-size: 0.6em; 
        padding: 0 6px;
        height: 35px;
      }
      button { padding: 10px 15px; }
      .add-btn { width: 25px; height: 25px; font-size: 1em; }
      .instrument-block { min-width: 160px; }
      .delete-cell-btn {
        width: 14px;
        height: 14px;
        font-size: 0.5em;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Jam On ‚Äì Composi√ß√£o Manual</h1>
    <div class="pill">Cada c√©lula = semicolcheia (1/4 da sem√≠nima)</div>
  </header>
  <div class="card">
    <div id="statusIndicator" class="status-indicator status-loading">
      Carregando... Clique 8 vezes para preparar o som.
    </div>
    <div class="countdown" id="countdown"></div>
    <div class="section">
      <h3>üéõÔ∏è Controle de BPM</h3>
      <div class="bpm-control">
        <div class="bpm-display" id="bpmDisplay">100 BPM</div>
        <input type="range" id="bpmSlider" class="bpm-slider" min="60" max="180" value="100" step="1">
      </div>
    </div>
    <!-- √öNICO BOT√ÉO "+" QUE ADICIONA COMPASSO EM TODOS OS INSTRUMENTOS -->
    <div style="text-align: center; margin: 20px 0;">
      <button id="addCompassoBtn" class="add-btn">+</button>
      <span style="color: #aaa; margin-left: 10px;">Adicionar compasso em todos os instrumentos</span>
    </div>
    <!-- HARMONIA (4 c√©lulas por instrumento = 1 compasso) -->
    <div class="section">
      <h3>üé∏ Harmonia 1</h3>
      <div id="harmonyContainer1" class="instrument-container"></div>
    </div>
    <div class="section">
      <h3>üé∏ Harmonia 2</h3>
      <div id="harmonyContainer2" class="instrument-container"></div>
    </div>
    <div class="section">
      <h3>üé∏ Harmonia 3</h3>
      <div id="harmonyContainer3" class="instrument-container"></div>
    </div>
    <!-- BAIXO (4 c√©lulas = 1 compasso) -->
    <div class="section">
      <h3>üé∏ Baixo</h3>
      <div id="bassContainer" class="instrument-container"></div>
    </div>
    <!-- MELODIA 1 (4 c√©lulas = 1 compasso) -->
    <div class="section">
      <h3>üéπ Melodia 1</h3>
      <div id="melody1Container" class="instrument-container"></div>
    </div>
    <!-- MELODIA 2 (4 c√©lulas = 1 compasso) -->
    <div class="section">
      <h3>üé∑ Melodia 2</h3>
      <div id="melody2Container" class="instrument-container"></div>
    </div>
    <!-- BATERIA (4 c√©lulas = 1 compasso) -->
    <div class="section">
      <h3>ü•Å Bateria</h3>
      <div id="drumContainer" class="instrument-container"></div>
    </div>    
    <div class="btn-row">
      <button id="btnPlay" class="primary" disabled>‚ñ∂ Play</button>
      <button id="btnStop" class="danger" disabled>‚èπ Stop</button>
      <button id="btnSaveWAV" class="primary" disabled>üíæ Salvar como WAV</button>
      <button id="btnDuplicate" class="primary">üîÅ Duplicar Edi√ß√£o</button>
    </div>
    <div class="instructions">
      Clique em uma c√©lula para escolher uma nota ou acorde.<br>
      Use "+" para adicionar uma coluna em todos os instrumentos.<br>
      <strong>Clique 8 vezes em qualquer c√©lula para preparar os sons.</strong>
    </div>
  </div>
  <!-- MODAL (inicialmente oculto) -->
  <div id="selectionModal" class="modal-overlay" style="display: none;">
    <div class="modal">
      <h2 id="modalTitle">Selecione uma op√ß√£o</h2>
      <div id="modalGrid" class="modal-grid">
        <!-- As op√ß√µes ser√£o inseridas aqui dinamicamente -->
      </div>
    </div>
  </div>
  <!-- CONTAINER DA BARRA DE PROGRESSO (inicialmente oculto) -->
  <div id="progressContainer" style="display: none; text-align: center; margin: 20px 0;">
    <div>Renderizando...</div>
    <div class="progress-container">
      <div id="progressBar" class="progress-bar"></div>
    </div>
    <div id="progressText">0%</div>
  </div>
 <script>
// ===== CONSTANTES =====
const AVAILABLE_CHORDS = [
  'X', // ‚Üê OP√á√ÉO EM BRANCO ADICIONADA
  // Acordes em A
  'A', 'A11', 'A13', 'A4', 'A45+', 'A5', 'A5+', 'A6', 'A7', 'A75+', 'A9', 'A95+', 'Adim', 
  'Am', 'Am5', 'Am5+', 'Am6', 'Am7', 'Am75+', 'Am9',
  // Acordes em AS (A#)
  'AS', 'AS11', 'AS13', 'AS4', 'AS45+', 'AS5', 'AS5+', 'AS6', 'AS7', 'AS75+', 'AS9', 'AS95+',
  'ASdim', 'ASm', 'ASm5', 'ASm5+', 'ASm6', 'ASm7', 'ASm75+', 'ASm9',
  // Acordes em B
  'B', 'B11', 'B13', 'B4', 'B45+', 'B5', 'B5+', 'B6', 'B7', 'B75+', 'B9', 'B95+', 'Bdim',
  'Bm', 'Bm5', 'Bm5+', 'Bm6', 'Bm7', 'Bm75+', 'Bm9',
  // Acordes em C
  'C', 'C11', 'C13', 'C4', 'C45+', 'C5', 'C5+', 'C6', 'C7', 'C75+', 'C9', 'C95+', 'Cdim',
  'Cm', 'Cm5', 'Cm5+', 'Cm6', 'Cm7', 'Cm75+', 'Cm9',
  // Acordes em CS (C#)
  'CS', 'CS11', 'CS13', 'CS4', 'CS45+', 'CS5', 'CS5+', 'CS6', 'CS7', 'CS75+', 'CS9', 'CS95+',
  'CSdim', 'CSm', 'CSm5', 'CSm5+', 'CSm6', 'CSm7', 'CSm75+', 'CSm9',
  // Acordes em D
  'D', 'D11', 'D13', 'D4', 'D45+', 'D5', 'D5+', 'D6', 'D7', 'D75+', 'D9', 'D95+', 'Ddim',
  'Dm', 'Dm5', 'Dm5+', 'Dm6', 'Dm7', 'Dm75+', 'Dm9',
  // Acordes em E
  'E', 'E11', 'E13', 'E4', 'E45+', 'E5', 'E5+', 'E6', 'E7', 'E75+', 'E9', 'E95+', 'Edim',
  'Em', 'Em5', 'Em5+', 'Em6', 'Em7', 'Em75+', 'Em9',
  // Acordes em DS (D#)
  'DS', 'DS11', 'DS13', 'DS4', 'DS45+', 'DS5', 'DS5+', 'DS6', 'DS7', 'DS75+', 'DS9', 'DS95+',
  'DSdim', 'DSm', 'DSm5', 'DSm5+', 'DSm6', 'DSm7', 'DSm75+', 'DSm9',
  // Acordes em F
  'F', 'F11', 'F13', 'F4', 'F45+', 'F5', 'F5+', 'F6', 'F7', 'F75+', 'F9', 'F95+', 'Fdim',
  'Fm', 'Fm5', 'Fm5+', 'Fm6', 'Fm7', 'Fm75+', 'Fm9',
  // Acordes em FS (F#)
  'FS', 'FS11', 'FS13', 'FS4', 'FS45+', 'FS5', 'FS5+', 'FS6', 'FS7', 'FS75+', 'FS9', 'FS95+',
  'FSdim', 'FSm', 'FSm5', 'FSm5+', 'FSm6', 'FSm7', 'FSm75+', 'FSm9',
  // Acordes em G
  'G', 'G11', 'G13', 'G4', 'G45+', 'G5', 'G5+', 'G6', 'G7', 'G75+', 'G9', 'G95+', 'Gdim',
  'Gm', 'Gm5', 'Gm5+', 'Gm6', 'Gm7', 'Gm75+', 'Gm9',
  // Acordes em GS (G#)
  'GS', 'GS11', 'GS13', 'GS4', 'GS45+', 'GS5', 'GS5+', 'GS6', 'GS7', 'GS75+', 'GS9', 'GS95+',
  'GSdim', 'GSm', 'GSm5', 'GSm5+', 'GSm6', 'GSm7', 'GSm75+', 'GSm9'
];
const NOTE_NAMES = [
  'X', // ‚Üê OP√á√ÉO EM BRANCO ADICIONADA
  '10CS.mp3', '11D.mp3', '12DS.mp3', '13E.mp3', '14F.mp3', '15FS.mp3', '16G.mp3', '17GS.mp3', 
  '18A.mp3', '19AS.mp3', '1E.mp3', '20B.mp3', '21C.mp3', '22CS.mp3', '23D.mp3', '24DS.mp3', 
  '25E.mp3', '26F.mp3', '27FS.mp3', '28G.mp3', '29GS.mp3', '2F.mp3', '30A.mp3', '31AS.mp3', 
  '32B.mp3', '33C.mp3', '34CS.mp3', '35D.mp3', '36DS.mp3', '37E.mp3', '38F.mp3', '39FS.mp3', 
  '3FS.mp3', '40G.mp3', '41GS.mp3', '42A.mp3', '43AS.mp3', '44B.mp3', '45C.mp3', '46CS.mp3', 
  '47D.mp3', '48DS.mp3', '49E.mp3', '4G.mp3', '5GS.mp3', '6A.mp3', '7AS.mp3', '8B.mp3', '9C.mp3'
];
// Ordena as notas pelo n√∫mero antes do nome da nota (ex: '1E' vem antes de '10CS')
const ALL_NOTES = NOTE_NAMES
  .map(name => name.replace('.mp3', ''))
  .sort((a, b) => {
    if (a === 'X') return -1; // Mant√©m 'X' no in√≠cio
    if (b === 'X') return 1;
    const numA = parseInt(a.match(/^\d+/)[0]);
    const numB = parseInt(b.match(/^\d+/)[0]);
    return numA - numB;
  });
const NOTE_FREQ = {
  'C': 261.63, 'CS': 277.18, 'D': 293.66, 'DS': 311.13, 'E': 329.63, 'F': 349.23,
  'FS': 369.99, 'G': 392.00, 'GS': 415.30, 'A': 440.00, 'AS': 466.16, 'B': 493.88
};
const MELODIC_INSTRUMENTS = {
  'acordeon': 'assets/AcordeonMelodia/',       // assets/AcordeonMelodia/nota.mp3
  'bass': 'assets/BaixoMelodia/',              // assets/BaixoMelodia/nota.mp3
  'strings': 'assets/Cordas/',                 // assets/Cordas/nota.mp3
  'piano': 'assets/PianoString/',              // assets/PianoString/nota.mp3
  'sax': 'assets/SaxMelodia/',                 // assets/SaxMelodia/nota.mp3
  'sinos': 'assets/SinosMelodia/',             // assets/SinosMelodia/nota.mp3 (adicionado)
  'acoustic-guitar': 'assets/ViolaoAcoMelodia/', // assets/ViolaoAcoMelodia/nota.mp3
  'nylon-guitar': 'assets/ViolaoNylonMelodia/',  // assets/ViolaoNylonMelodia/nota.mp3
  'distorted-guitar-melody': 'guitarraDistorcao/Melodia/' // guitarraDistorcao/Melodia/nota.mp3
};
// ===== CORRE√á√ÉO AQUI: Caminhos dos Instrumentos Harm√¥nicos =====
const HARMONIC_INSTRUMENTS = {
  'distorted-guitar': 'guitarraDistorcao/',    // guitarraDistorcao/Nota/acorde.mp3
  'clean-guitar': 'guitarraLimpa/',            // guitarraLimpa/Nota/acorde.mp3
  'piano-chord': 'assets/PianoStringChord/'    // assets/PianoStringChord/Nota/acorde.mp3
};
const DRUM_SAMPLES = [
  { key: 'ataque', label: 'Prato De Ataque', path: 'assets/ataque.mp3' },
  { key: 'bumbo', label: 'Bumbo', path: 'assets/bumbo.mp3' },
  { key: 'caixa', label: 'Caixa', path: 'assets/caixa.mp3' },
  { key: 'chimbal', label: 'Chimbal Fechado', path: 'assets/chimbal.mp3' },
  { key: 'chimbal-aberto', label: 'Chimbal Aberto', path: 'assets/chimbal-aberto.mp3' },
  { key: 'conducao', label: 'Condu√ß√£o', path: 'assets/conducao.mp3' },
  { key: 'conducao-centro', label: 'Condu√ß√£o Centro', path: 'assets/conducao-centro.mp3' },
  { key: 'surdo', label: 'Surdo', path: 'assets/surdo.mp3' },
  { key: 'tom-1', label: 'Tom 1', path: 'assets/tom-1.mp3' },
  { key: 'tom-2', label: 'Tom 2', path: 'assets/tom-2.mp3' }
];
// ===== ESTADO =====
const state = {
  running: false,
  paused: false,
  bpm: 100,
  stepIndex: 0,
  totalSteps: 4,
  buffers: {
    drums: {},
    melodic: {},
    harmonic: {}
  },
  loadedSamples: new Set(),
  activeInput: null,
  schedulerTimer: null,
  harmonyBlocks: [[], [], []], // Agora √© um array de 3 arrays, um para cada container de harmonia
  bassBlocks: [],
  melody1Blocks: [],
  melody2Blocks: [],
  drumBlocks: [],
  lastNoteTime: 0,
  recordedChunks: [],
  audioCtx: null,
  isPlaying: false,
  isRendering: false,
  countdownActive: false,
  countdownValue: 4,
  currentlyPlaying: { 
    bass: null,
    melody1: null,
    melody2: null,
    harmony1: null,
    harmony2: null,
    harmony3: null
  },
  playbackPlan: null,
  // Estado do Modal
  modal: {
    targetCell: null,
    type: null, // 'harmony' ou 'melodic'
    instrumentKey: null
  }
};
// ===== ELEMENTOS =====
const ui = {
  statusIndicator: document.getElementById('statusIndicator'),
  countdown: document.getElementById('countdown'),
  bpmSlider: document.getElementById('bpmSlider'),
  bpmDisplay: document.getElementById('bpmDisplay'),
  btnPlay: document.getElementById('btnPlay'),
  btnStop: document.getElementById('btnStop'),
  btnSaveWAV: document.getElementById('btnSaveWAV'),
  addCompassoBtn: document.getElementById('addCompassoBtn'),
  harmonyContainer1: document.getElementById('harmonyContainer1'),
  harmonyContainer2: document.getElementById('harmonyContainer2'),
  harmonyContainer3: document.getElementById('harmonyContainer3'),
  bassContainer: document.getElementById('bassContainer'),
  melody1Container: document.getElementById('melody1Container'),
  melody2Container: document.getElementById('melody2Container'),
  drumContainer: document.getElementById('drumContainer'),
  selectionModal: document.getElementById('selectionModal'),
  modalTitle: document.getElementById('modalTitle'),
  modalGrid: document.getElementById('modalGrid'),
  progressContainer: document.getElementById('progressContainer'),
  progressBar: document.getElementById('progressBar'),
  progressText: document.getElementById('progressText')
};
// ===== INICIALIZA√á√ÉO =====
async function initializeApp() {
  updateStatus('Pronto para compor. Clique nas c√©lulas para criar sua m√∫sica.', 'ready');
  try {
    state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    state.masterGain = state.audioCtx.createGain();
    state.drumGain = state.audioCtx.createGain();
    state.bassGain = state.audioCtx.createGain();
    state.melodyGain = state.audioCtx.createGain();
    state.harmonicGain = state.audioCtx.createGain();
    state.masterGain.connect(state.audioCtx.destination);
    state.drumGain.connect(state.masterGain);
    state.bassGain.connect(state.masterGain);
    state.melodyGain.connect(state.masterGain);
    state.harmonicGain.connect(state.masterGain);
    state.masterGain.gain.value = 0.8;
    state.drumGain.gain.value = 1.0;
    state.bassGain.gain.value = 0.5;
    state.melodyGain.gain.value = 0.5;
    state.harmonicGain.gain.value = 0.5;
    setupEventListeners();
    // --- CORRE√á√ÉO DEFINITIVA: Garante 3 blocos independentes ---
    // Limpa os arrays de estado antes de adicionar os blocos
    state.harmonyBlocks = [[], [], []];
    state.bassBlocks = [];
    state.melody1Blocks = [];
    state.melody2Blocks = [];
    state.drumBlocks = [];
    
    // Adiciona 1 bloco em cada container de harmonia
    addHarmonyBlock(0); // Harmonia 1
    addHarmonyBlock(1); // Harmonia 2
    addHarmonyBlock(2); // Harmonia 3
    
    // Adiciona 1 bloco de cada instrumento mel√≥dico e de bateria
    addBassBlock();
    addMelody1Block();
    addMelody2Block();
    addDrumBlock();
    ui.btnPlay.disabled = false;
    ui.btnSaveWAV.disabled = true;
    ui.btnStop.disabled = true;
    updateStatus('Componha sua m√∫sica. Clique em Play para iniciar com contagem de 4 compassos.', 'ready');
    updateEditMap();
} catch (error) {
    console.error('Erro ao inicializar:', error);
    updateStatus('Erro ao inicializar: ' + error.message, 'error');
  }
}
function setupEventListeners() {
  updateBPMDisplay();
  ui.bpmSlider.addEventListener('input', handleBPMChange);
  ui.addCompassoBtn.addEventListener('click', addCompasso);
  ui.btnPlay.addEventListener('click', onPlay);
  ui.btnStop.addEventListener('click', onStop);
  ui.btnSaveWAV.addEventListener('click', () => renderAndDownloadWAV()); // Sem dura√ß√£o fixa
  document.getElementById('btnDuplicate').addEventListener('click', duplicateComposition);
  document.addEventListener('click', function(e) {
    if (e.target.classList.contains('cell') || e.target.classList.contains('drum-cell')) {
      if (e.target.classList.contains('cell')) {
        const instrument = e.target.parentElement.parentElement.querySelector('.instrument-select').value;
        const type = e.target.parentElement.dataset.type;
        const noteOrChord = e.target.textContent;
        if (type === 'harmony') {
          loadSample('harmonic', instrument, noteOrChord);
        } else {
          loadSample('melodic', instrument, noteOrChord);
        }
      } else if (e.target.classList.contains('drum-cell')) {
        const drumKey = e.target.dataset.instr;
        loadSample('drum', drumKey, '');
      }
    }
  });
  // Evento para fechar o modal ao clicar fora dele
  ui.selectionModal.addEventListener('click', function(e) {
    if (e.target === this) {
      closeModal();
    }
  });

  
}
function handleBPMChange() {
  state.bpm = parseInt(ui.bpmSlider.value);
  updateBPMDisplay();
}
function updateBPMDisplay() {
  ui.bpmDisplay.textContent = `${state.bpm} BPM`;
}
function updateStatus(message, type) {
  ui.statusIndicator.textContent = message;
  ui.statusIndicator.className = 'status-indicator status-' + type;
}
// ===== CARREGAMENTO SOB DEMANDA (CORRIGIDO) =====
async function loadSample(instrumentType, key, noteOrChord) {
  let filePath;
  let bufferKey;
  if (instrumentType === 'drum') {
    const sample = DRUM_SAMPLES.find(d => d.key === key);
    if (!sample) return;
    filePath = sample.path;
    bufferKey = key;
  } else if (instrumentType === 'melodic') {
    if (noteOrChord === 'X') return; // Ignora 'X'
    filePath = MELODIC_INSTRUMENTS[key] + noteOrChord + '.mp3';
    bufferKey = `melodic-${key}-${noteOrChord}`;
  } else if (instrumentType === 'harmonic') {
    if (noteOrChord === 'X') return; // Ignora 'X'
    let root;
    if (noteOrChord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(noteOrChord.slice(0, 2))) {
      root = noteOrChord.slice(0, 2);
    } else {
      root = noteOrChord[0];
    }
    // Monta o caminho: HARMONIC_INSTRUMENTS[key] + root + '/' + noteOrChord + '.mp3'
    filePath = HARMONIC_INSTRUMENTS[key] + root + '/' + noteOrChord + '.mp3';
    bufferKey = filePath; // Usa o caminho completo como chave
  }
  if (!filePath) return;
  if (state.loadedSamples.has(bufferKey)) return;
  try {
    const response = await fetch(filePath);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const arrayBuffer = await response.arrayBuffer();
    const buffer = await state.audioCtx.decodeAudioData(arrayBuffer);
    if (instrumentType === 'drum') {
      state.buffers.drums[bufferKey] = buffer;
    } else if (instrumentType === 'melodic') {
      state.buffers.melodic[bufferKey] = buffer;
    } else if (instrumentType === 'harmonic') {
      state.buffers.harmonic[bufferKey] = buffer;
    }
    state.loadedSamples.add(bufferKey);
    console.log(`‚úÖ Carregado: ${filePath} ‚Üí chave: ${bufferKey}`);
  } catch (err) {
    console.warn(`‚ö†Ô∏è N√£o encontrado: ${filePath}`);
  }
}
// ===== MODAL DE SELE√á√ÉO =====
function openModal(type, options, targetCell, instrumentKey) {
  state.modal.type = type;
  state.modal.targetCell = targetCell;
  state.modal.instrumentKey = instrumentKey;
  ui.modalTitle.textContent = type === 'harmony' ? 'Selecione um Acorde' : 'Selecione uma Nota';
  ui.modalGrid.innerHTML = '';
  // CORRE√á√ÉO: Substitui "S" por "#" apenas na exibi√ß√£o
  options.forEach(option => {
    const div = document.createElement('div');
    div.className = 'modal-option';
    if (option === 'X') {
      div.classList.add('x');
    }
    // Exibe "#" em vez de "S" na interface, mas mant√©m o valor original
    let displayText = option;
    if (option !== 'X') {
      displayText = option.replace(/S/g, '#');
    }
    div.textContent = displayText;
    // Armazena o valor original como atributo
    div.dataset.originalValue = option;
    div.addEventListener('click', function() {
      const originalValue = this.dataset.originalValue;
      // --- CORRE√á√ÉO AQUI ---
      // 1. Guarda uma refer√™ncia ao bot√£o de delete
      const deleteBtn = targetCell.querySelector('.delete-cell-btn');
      // 2. Remove o bot√£o temporariamente
      if (deleteBtn) {
        targetCell.removeChild(deleteBtn);
      }
      // 3. Define o novo texto da c√©lula (com # na interface)
      targetCell.textContent = displayText;
      // 4. Armazena o valor original
      targetCell.dataset.originalValue = originalValue;
      // 5. Reaplica a classe 'x' conforme necess√°rio
      if (originalValue === 'X') {
        targetCell.classList.add('x');
      } else {
        targetCell.classList.remove('x');
      }
      // 6. Adiciona o bot√£o de volta
      if (deleteBtn) {
        targetCell.appendChild(deleteBtn);
      }
      // Muta o som anterior
      const category = type === 'harmony' ? 'harmony' : targetCell.parentElement.parentElement.dataset.type.replace('Block', '').toLowerCase();
      if (state.currentlyPlaying[category] !== null) {
        state.currentlyPlaying[category] = null;
      }
      // Carrega a amostra (usa o valor original)
      if (type === 'harmony') {
        loadSample('harmonic', instrumentKey, originalValue);
      } else {
        loadSample('melodic', instrumentKey, originalValue);
      }
      closeModal();
    });
    ui.modalGrid.appendChild(div);
  });
  ui.selectionModal.style.display = 'flex';
}
function closeModal() {
  ui.selectionModal.style.display = 'none';
  state.modal = {
    targetCell: null,
    type: null,
    instrumentKey: null
  };
}

// Fun√ß√£o modificada para aceitar um √≠ndice de container
function addHarmonyBlock(containerIndex) {
  const blockIndex = state.harmonyBlocks[containerIndex].length;
  const wrapper = document.createElement('div');
  wrapper.className = 'instrument-wrapper';
  wrapper.style.display = 'flex';
  wrapper.style.alignItems = 'flex-start';
  wrapper.dataset.blockIndex = blockIndex;
  wrapper.dataset.containerIndex = containerIndex; // Identifica qual container pertence
  
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.style.width = '120px';
  instrumentSelect.style.marginRight = '10px';
  instrumentSelect.innerHTML = `
    <option value="distorted-guitar">Guitarra Distorcida</option>
    <option value="clean-guitar">Guitarra Limpa</option>
    <option value="piano-chord">Piano</option>
  `;
  
  const block = document.createElement('div');
  block.className = 'instrument-block harmony-block';
  block.style.flex = '1';
  block.dataset.blockIndex = blockIndex;
  block.dataset.containerIndex = containerIndex;
  
  const grid = document.createElement('div');
  grid.className = 'columns-grid';
  grid.dataset.type = 'harmony';
  grid.dataset.blockIndex = blockIndex;
  grid.dataset.containerIndex = containerIndex;
  grid.style.position = 'relative';
  
  const harmonyBlock = {
    wrapper,
    instrumentSelect,
    grid,
    containerIndex
  };
  
  for (let i = 0; i < 4; i++) {
    createHarmonyColumn(grid, i, harmonyBlock);
  }
  
  block.appendChild(grid);
  wrapper.appendChild(instrumentSelect);
  wrapper.appendChild(block);
  
  
  // Adiciona ao container correto
  const containerId = `harmonyContainer${containerIndex + 1}`;
  document.getElementById(containerId).appendChild(wrapper);
  
  state.harmonyBlocks[containerIndex].push(harmonyBlock);
  return wrapper;
}
function createHarmonyColumn(parentGrid, columnIndex, harmonyBlock) {
  const column = document.createElement('div');
  column.className = 'column';
  column.dataset.columnIndex = columnIndex;
  const cell = document.createElement('div');
  cell.className = 'cell x';
  cell.textContent = 'X';

  // --- ADICIONA O R√ìTULO NUM√âRICO A CADA 4 COLUNAS ---
  if ((columnIndex + 1) % 4 === 0 && columnIndex > 0) {
    const label = document.createElement('div');
    label.className = 'column-number-label';
    label.textContent = columnIndex + 1; // Exibe o n√∫mero da coluna (1-indexed)
    cell.appendChild(label);
  }

  const deleteCellBtn = document.createElement('button');
  deleteCellBtn.className = 'delete-cell-btn';
  deleteCellBtn.textContent = '‚úñ';
  deleteCellBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    if (confirm('Excluir toda a coluna vertical (inclusive bateria, harmonia e melodias)?')) {
      deleteColumn(columnIndex);
    } else {
      cell.textContent = 'X';
      cell.classList.add('x');
      cell.appendChild(deleteCellBtn);
    }
  });
  cell.appendChild(deleteCellBtn);
  column.appendChild(cell);
  parentGrid.appendChild(column);
  cell.addEventListener('click', function(e) {
    e.stopPropagation();
    const instrumentKey = harmonyBlock.instrumentSelect.value;
    openModal('harmony', AVAILABLE_CHORDS, this, instrumentKey);
  });
}

function addBassBlock() {
  const blockIndex = state.bassBlocks.length;
  const wrapper = document.createElement('div');
  wrapper.className = 'instrument-wrapper';
  wrapper.style.display = 'flex';
  wrapper.style.alignItems = 'flex-start';
  wrapper.dataset.blockIndex = blockIndex;
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.style.width = '120px';
  instrumentSelect.style.marginRight = '10px';
  instrumentSelect.innerHTML = `
    <option value="bass">Baixo</option>   
  `;
  const block = document.createElement('div');
  block.className = 'instrument-block bass-block';
  block.style.flex = '1';
  block.dataset.blockIndex = blockIndex;
  const grid = createMelodicGrid('bass', blockIndex, 4);
  // Adiciona marcadores de sem√≠nima
  
  block.appendChild(grid);
  wrapper.appendChild(instrumentSelect);
  wrapper.appendChild(block);
  ui.bassContainer.appendChild(wrapper);
  state.bassBlocks.push(wrapper);
  return wrapper;
}

function addMelody1Block() {
  const blockIndex = state.melody1Blocks.length;
  const wrapper = document.createElement('div');
  wrapper.className = 'instrument-wrapper';
  wrapper.style.display = 'flex';
  wrapper.style.alignItems = 'flex-start';
  wrapper.dataset.blockIndex = blockIndex;
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.style.width = '120px';
  instrumentSelect.style.marginRight = '10px';
  instrumentSelect.innerHTML = `
    <option value="piano">Piano</option>
  <option value="sax">Saxofone</option>
  <option value="acordeon">Acordeon</option>
  <option value="strings">Cordas</option>
  <option value="sinos">Sinos</option> <!-- Adicionado -->
  <option value="acoustic-guitar">Viol√£o A√ßo</option>
  <option value="nylon-guitar">Viol√£o Nylon</option>
  <option value="distorted-guitar-melody">Guitarra Distorcida (Melodia)
  </option>
  `;
  const block = document.createElement('div');
  block.className = 'instrument-block melody1-block';
  block.style.flex = '1';
  block.dataset.blockIndex = blockIndex;
  const grid = createMelodicGrid('melody1', blockIndex, 4);
  // Adiciona marcadores de sem√≠nima
  
  block.appendChild(grid);
  wrapper.appendChild(instrumentSelect);
  wrapper.appendChild(block);
  ui.melody1Container.appendChild(wrapper);
  state.melody1Blocks.push(wrapper);
  return wrapper;
}

function addMelody2Block() {
  const blockIndex = state.melody2Blocks.length;
  const wrapper = document.createElement('div');
  wrapper.className = 'instrument-wrapper';
  wrapper.style.display = 'flex';
  wrapper.style.alignItems = 'flex-start';
  wrapper.dataset.blockIndex = blockIndex;
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.style.width = '120px';
  instrumentSelect.style.marginRight = '10px';
  instrumentSelect.innerHTML = `
    <option value="piano">Piano</option>
  <option value="sax">Saxofone</option>
  <option value="acordeon">Acordeon</option>
  <option value="strings">Cordas</option>
  <option value="sinos">Sinos</option> <!-- Adicionado -->
  <option value="acoustic-guitar">Viol√£o A√ßo</option>
  <option value="nylon-guitar">Viol√£o Nylon</option>
  <option value="distorted-guitar-melody">Guitarra Distorcida (Melodia)
  </option>
  `;
  const block = document.createElement('div');
  block.className = 'instrument-block melody2-block';
  block.style.flex = '1';
  block.dataset.blockIndex = blockIndex;
  const grid = createMelodicGrid('melody2', blockIndex, 4);
  // Adiciona marcadores de sem√≠nima
  
  block.appendChild(grid);
  wrapper.appendChild(instrumentSelect);
  wrapper.appendChild(block);
  ui.melody2Container.appendChild(wrapper);
  state.melody2Blocks.push(wrapper);
  return wrapper;
}

function addDrumBlock() {
  const blockIndex = state.drumBlocks.length;
  const block = document.createElement('div');
  block.className = 'instrument-block drum-block';
  block.dataset.blockIndex = blockIndex;
  block.style.display = 'flex';
  block.style.alignItems = 'flex-start'; // Alinha ao topo
  // Cria o wrapper principal da bateria (labels + grid)
  const drumWrapper = document.createElement('div');
  drumWrapper.className = 'drum-wrapper';
  drumWrapper.style.position = 'relative';
  // Cria a coluna de r√≥tulos (labels)
  const labelsColumn = document.createElement('div');
  labelsColumn.className = 'drum-labels';
  // Adiciona os r√≥tulos
  DRUM_SAMPLES.forEach(drum => {
    const labelItem = document.createElement('div');
    labelItem.className = 'drum-label-item';
    labelItem.textContent = drum.label;
    labelsColumn.appendChild(labelItem);
  });
  // Cria a grade de colunas (sem os labels internos)
  const grid = document.createElement('div');
  grid.className = 'columns-grid';
  grid.dataset.type = 'drum';
  grid.dataset.blockIndex = blockIndex;
  // Para cada passo (coluna)
  for (let step = 0; step < 4; step++) {
    createDrumColumn(grid, step, blockIndex);
  }
 
  
  // Monta a estrutura
  drumWrapper.appendChild(labelsColumn);
  drumWrapper.appendChild(grid);
  block.appendChild(drumWrapper);
  ui.drumContainer.appendChild(block);
  state.drumBlocks.push(block);
  return block;
}

function createDrumColumn(parentGrid, stepIndex, blockIndex) {
  const column = document.createElement('div');
  column.className = 'column';
  column.dataset.columnIndex = stepIndex;
  column.style.display = 'flex';
  column.style.flexDirection = 'column';

  DRUM_SAMPLES.forEach((drum, drumIndex) => {
    const cell = document.createElement('div');
    cell.className = 'drum-cell';
    cell.dataset.step = stepIndex;
    cell.dataset.instr = drum.key;
    cell.dataset.block = blockIndex;
    cell.style.height = '45px';
    cell.style.fontSize = '0.7em';

    // --- ADICIONA O R√ìTULO NUM√âRICO NA PRIMEIRA C√âLULA A CADA 4 COLUNAS ---
    if (drumIndex === 0 && (stepIndex + 1) % 4 === 0 && stepIndex > 0) {
      const label = document.createElement('div');
      label.className = 'column-number-label';
      label.textContent = stepIndex + 1; // Exibe o n√∫mero da coluna (1-indexed)
      cell.appendChild(label);
    }

    cell.addEventListener('click', function() {
      this.classList.toggle('active');
      loadSample('drum', drum.key, '');
    });

    // >>>>> MODIFICA√á√ÉO: Bot√£o de delete s√≥ na primeira c√©lula (Prato de Ataque) <<<<<
    if (drumIndex === 0) { // S√≥ adiciona o bot√£o na primeira c√©lula (ataque)
      const deleteCellBtn = document.createElement('button');
      deleteCellBtn.className = 'delete-cell-btn';
      deleteCellBtn.textContent = '‚úñ';
      deleteCellBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        if (confirm('Excluir toda a coluna vertical (inclusive bateria, harmonia e melodias)?')) {
          deleteColumn(stepIndex);
        } else {
          // N√£o precisa fazer nada, pois o bot√£o s√≥ existe na c√©lula de ataque
          // e n√£o afeta o estado 'active' das outras.
        }
      });
      cell.appendChild(deleteCellBtn);
    }

    column.appendChild(cell);
  });

  parentGrid.appendChild(column);

  // >>>>> CORRE√á√ÉO: For√ßa o reflow do grid ap√≥s adicionar a coluna <<<<<
  parentGrid.style.display = 'none';
  parentGrid.offsetHeight; // Trigger reflow
  parentGrid.style.display = 'flex';
}

function createMelodicGrid(type, blockIndex, numColumns) {
  const grid = document.createElement('div');
  grid.className = 'columns-grid';
  grid.dataset.type = type;
  grid.dataset.blockIndex = blockIndex;
  for (let i = 0; i < numColumns; i++) {
    createMelodicColumn(grid, type, i);
  }
  return grid;
}

function createMelodicColumn(parentGrid, type, columnIndex) {
  const column = document.createElement('div');
  column.className = 'column';
  column.dataset.columnIndex = columnIndex;
  const cell = document.createElement('div');
  cell.className = 'cell x';
  cell.textContent = 'X';

  // --- ADICIONA O R√ìTULO NUM√âRICO A CADA 4 COLUNAS ---
  if ((columnIndex + 1) % 4 === 0 && columnIndex > 0) {
    const label = document.createElement('div');
    label.className = 'column-number-label';
    label.textContent = columnIndex + 1; // Exibe o n√∫mero da coluna (1-indexed)
    cell.appendChild(label);
  }

  cell.addEventListener('click', function(e) {
    e.stopPropagation();
    const instrumentKey = this.closest('.instrument-block').parentElement.querySelector('.instrument-select').value;
    openModal('melodic', ALL_NOTES, this, instrumentKey);
  });
  const deleteCellBtn = document.createElement('button');
  deleteCellBtn.className = 'delete-cell-btn';
  deleteCellBtn.textContent = '‚úñ';
  deleteCellBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    if (confirm('Excluir toda a coluna vertical (inclusive bateria, harmonia e melodias)?')) {
      deleteColumn(columnIndex);
    } else {
      cell.textContent = 'X';
      cell.classList.add('x');
      cell.appendChild(deleteCellBtn);
    }
  });
  cell.appendChild(deleteCellBtn);
  column.appendChild(cell);
  parentGrid.appendChild(column);
}



// ===== FUN√á√ÉO PARA EXCLUIR COLUNA =====
function deleteColumn(columnIndex) {
  // Coleta todos os grids: bateria, harmonia e melodias
  const allGrids = [
    // Todos os containers de harmonia
    ...state.harmonyBlocks[0].map(hb => hb.grid),
    ...state.harmonyBlocks[1].map(hb => hb.grid),
    ...state.harmonyBlocks[2].map(hb => hb.grid),
    // Outros instrumentos
    ...state.bassBlocks.map(b => b.querySelector('.columns-grid')),
    ...state.melody1Blocks.map(m => m.querySelector('.columns-grid')),
    ...state.melody2Blocks.map(m => m.querySelector('.columns-grid')),
    ...state.drumBlocks.map(d => d.querySelector('.columns-grid'))
  ].filter(Boolean); // remove nulos
  
  // Remove a coluna correspondente em todos os grids
  allGrids.forEach(g => {
    const columns = g.querySelectorAll('.column');
    if (columns[columnIndex]) {
      g.removeChild(columns[columnIndex]);
    }
  });
  state.totalSteps -= 1;
updateEditMap();
}

function addCompasso() {
  const newColumnIndex = state.totalSteps;
  
  // Harmonia - para cada um dos 3 containers
  for (let containerIndex = 0; containerIndex < 3; containerIndex++) {
    state.harmonyBlocks[containerIndex].forEach(harmonyBlock => {
      const grid = harmonyBlock.grid;
      if (!grid) return;
      createHarmonyColumn(grid, newColumnIndex, harmonyBlock);
      
    });
  }
  
  // Baixo, Melodia 1, Melodia 2
  [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach(blocks => {
    blocks.forEach(wrapper => {
      const grid = wrapper.querySelector('.columns-grid');
      if (!grid) return;
      const type = grid.dataset.type;
      createMelodicColumn(grid, type, newColumnIndex);
      
    });
  });
  
  // BATERIA
  state.drumBlocks.forEach(block => {
    const grid = block.querySelector('.columns-grid');
    if (!grid) return;
    createDrumColumn(grid, newColumnIndex, block.dataset.blockIndex);
  });
  
  state.totalSteps += 1;
  updateStatus(`Compasso adicionado. Total: ${state.totalSteps} passos.`, 'ready');

  
updateEditMap();

}
function duplicateComposition() {
  if (state.totalSteps === 0) {
    alert('Nenhuma composi√ß√£o para duplicar.');
    return;
  }
  const originalTotalSteps = state.totalSteps;
  // Para cada coluna existente, cria uma c√≥pia
  for (let i = 0; i < originalTotalSteps; i++) {
    const newColumnIndex = state.totalSteps; // Sempre adiciona no final
    // Harmonia 1, 2, 3
    for (let containerIndex = 0; containerIndex < 3; containerIndex++) {
      state.harmonyBlocks[containerIndex].forEach(harmonyBlock => {
        const grid = harmonyBlock.grid;
        if (!grid) return;
        // Encontra a c√©lula original
        const originalColumn = grid.querySelector(`.column:nth-child(${i + 1})`);
        const originalCell = originalColumn.querySelector('.cell');
        const originalText = originalCell.textContent;
        const isX = originalCell.classList.contains('x');
        // Cria nova coluna
        createHarmonyColumn(grid, newColumnIndex, harmonyBlock);
        // Configura a nova c√©lula com o conte√∫do da original
        const newColumn = grid.querySelector(`.column:nth-child(${newColumnIndex + 1})`);
        const newCell = newColumn.querySelector('.cell');
        // Remove o bot√£o temporariamente para manipular o texto
        const deleteBtn = newCell.querySelector('.delete-cell-btn');
        if (deleteBtn) newCell.removeChild(deleteBtn);
        newCell.textContent = originalText;
        if (isX) {
          newCell.classList.add('x');
        } else {
          newCell.classList.remove('x');
          // Armazena o valor original (com 'S') no dataset para uso posterior pelo sistema de playback
          newCell.dataset.originalValue = originalText.replace(/#/g, 'S');
        }
        // Adiciona o bot√£o de volta
        if (deleteBtn) newCell.appendChild(deleteBtn);
      });
    }
    // Baixo, Melodia 1, Melodia 2
    [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach(blocks => {
      blocks.forEach(wrapper => {
        const grid = wrapper.querySelector('.columns-grid');
        if (!grid) return;
        const originalColumn = grid.querySelector(`.column:nth-child(${i + 1})`);
        const originalCell = originalColumn.querySelector('.cell');
        const originalText = originalCell.textContent;
        const isX = originalCell.classList.contains('x');
        createMelodicColumn(grid, grid.dataset.type, newColumnIndex);
        const newColumn = grid.querySelector(`.column:nth-child(${newColumnIndex + 1})`);
        const newCell = newColumn.querySelector('.cell');
        const deleteBtn = newCell.querySelector('.delete-cell-btn');
        if (deleteBtn) newCell.removeChild(deleteBtn);
        newCell.textContent = originalText;
        if (isX) {
          newCell.classList.add('x');
        } else {
          newCell.classList.remove('x');
          // Armazena o valor original (com 'S') no dataset
          newCell.dataset.originalValue = originalText.replace(/#/g, 'S');
        }
        if (deleteBtn) newCell.appendChild(deleteBtn);
      });
    });
    // BATERIA (este trecho est√° correto e pode permanecer)
    state.drumBlocks.forEach(block => {
      const drumWrapper = block.querySelector('.drum-wrapper');
      const grid = drumWrapper ? drumWrapper.querySelector('.columns-grid') : block.querySelector('.columns-grid');
      if (!grid) return;
      const originalColumn = grid.querySelector(`.column:nth-child(${i + 1})`);
      createDrumColumn(grid, newColumnIndex, block.dataset.blockIndex);
      const newColumn = grid.querySelector(`.column:nth-child(${newColumnIndex + 1})`);
      DRUM_SAMPLES.forEach((drum, drumIndex) => {
        const originalCell = originalColumn.querySelector(`.drum-cell[data-instr="${drum.key}"]`);
        const newCell = newColumn.querySelector(`.drum-cell[data-instr="${drum.key}"]`);
        if (originalCell.classList.contains('active')) {
          newCell.classList.add('active');
          // Carregar o sample da bateria aqui √© aceit√°vel porque √© um evento simples e o sistema de playback da bateria √© menos complexo.
          loadSample('drum', drum.key, '');
        } else {
          newCell.classList.remove('active');
        }
      });
    });
    state.totalSteps += 1;
  }
  updateStatus(`Composi√ß√£o duplicada. Total: ${state.totalSteps} passos.`, 'ready');
  updateEditMap();
}
function updateEditMap() {
  const mapContent = document.getElementById('editMapContent');
  mapContent.innerHTML = '';

  if (state.totalSteps === 0) return;

  const totalMeasures = Math.ceil(state.totalSteps / 4);

  for (let measureIndex = 0; measureIndex < totalMeasures; measureIndex++) {
    const item = document.createElement('div');
    item.className = 'edit-map-item';
    item.dataset.measureIndex = measureIndex;

    const numberSpan = document.createElement('span');
    numberSpan.className = 'edit-map-number';
    numberSpan.textContent = measureIndex + 1;

    const cellsContainer = document.createElement('div');
    cellsContainer.className = 'edit-map-cells';

    // Adiciona 4 c√©lulas representando as 4 semicolcheias do compasso
    for (let i = 0; i < 4; i++) {
      const cellIndex = measureIndex * 4 + i;
      if (cellIndex >= state.totalSteps) break;

      const cellSpan = document.createElement('span');
      cellSpan.className = 'edit-map-cell';

      // Verifica se h√° conte√∫do em pelo menos um instrumento nesta coluna
      let hasContent = false;

      // Verifica Harmonia 1, 2, 3
      for (let containerIndex = 0; containerIndex < 3; containerIndex++) {
        state.harmonyBlocks[containerIndex].forEach(hb => {
          const grid = hb.grid;
          const column = grid.querySelector(`.column:nth-child(${cellIndex + 1})`);
          if (column) {
            const cell = column.querySelector('.cell');
            if (cell && !cell.classList.contains('x')) {
              hasContent = true;
            }
          }
        });
      }

      // Verifica Baixo, Melodia 1, Melodia 2
      [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach(blocks => {
        blocks.forEach(wrapper => {
          const grid = wrapper.querySelector('.columns-grid');
          const column = grid.querySelector(`.column:nth-child(${cellIndex + 1})`);
          if (column) {
            const cell = column.querySelector('.cell');
            if (cell && !cell.classList.contains('x')) {
              hasContent = true;
            }
          }
        });
      });

      // Verifica Bateria
      state.drumBlocks.forEach(block => {
        const drumWrapper = block.querySelector('.drum-wrapper');
        const grid = drumWrapper ? drumWrapper.querySelector('.columns-grid') : block.querySelector('.columns-grid');
        if (grid) {
          const column = grid.querySelector(`.column:nth-child(${cellIndex + 1})`);
          if (column) {
            DRUM_SAMPLES.forEach(drum => {
              const drumCell = column.querySelector(`.drum-cell[data-instr="${drum.key}"]`);
              if (drumCell && drumCell.classList.contains('active')) {
                hasContent = true;
              }
            });
          }
        }
      });

      if (hasContent) {
        cellSpan.classList.add('filled');
      } else {
        cellSpan.classList.add('x');
      }

      cellsContainer.appendChild(cellSpan);
    }

    item.appendChild(numberSpan);
    item.appendChild(cellsContainer);
    mapContent.appendChild(item);

    // Adiciona evento de clique
    item.addEventListener('click', function() {
      const clickedMeasureIndex = parseInt(this.dataset.measureIndex);
      const targetColumnIndex = clickedMeasureIndex * 4;

      // Remove classe 'active' de todos os itens
      document.querySelectorAll('.edit-map-item').forEach(el => el.classList.remove('active'));
      // Adiciona classe 'active' ao item clicado
      this.classList.add('active');

      // Rola todos os grids at√© a coluna de destino
      const allGrids = [
        ...state.harmonyBlocks[0].map(hb => hb.grid),
        ...state.harmonyBlocks[1].map(hb => hb.grid),
        ...state.harmonyBlocks[2].map(hb => hb.grid),
        ...state.bassBlocks.map(b => b.querySelector('.columns-grid')),
        ...state.melody1Blocks.map(m => m.querySelector('.columns-grid')),
        ...state.melody2Blocks.map(m => m.querySelector('.columns-grid')),
        ...state.drumBlocks.map(d => {
          const dw = d.querySelector('.drum-wrapper');
          return dw ? dw.querySelector('.columns-grid') : d.querySelector('.columns-grid');
        })
      ].filter(Boolean);

      allGrids.forEach(grid => {
        const targetColumn = grid.querySelector(`.column:nth-child(${targetColumnIndex + 1})`);
        if (targetColumn) {
          // Usa scrollIntoView com suavidade
          targetColumn.scrollIntoView({
            behavior: 'smooth',
            block: 'nearest',
            inline: 'start'
          });
        }
      });
    });
  }
}
// ===== FUN√á√ÉO AUXILIAR: Obt√©m o valor da nota ou acorde da c√©lula =====
function getCellNoteValue(cellElement) {
  // Usa o valor original armazenado no dataset, se dispon√≠vel
  if (cellElement.dataset.originalValue) {
    return cellElement.dataset.originalValue;
  }
  // L√™ o primeiro n√≥ de texto da c√©lula, ignorando o bot√£o
  for (let node of cellElement.childNodes) {
    if (node.nodeType === Node.TEXT_NODE) {
      return node.textContent.trim();
    }
  }
  return 'X'; // valor padr√£o de fallback
}

// ===== PLAYBACK =====
function buildPlaybackPlan() {
  const plan = {
    harmony1: [],
    harmony2: [],
    harmony3: [],
    bass: [],
    melody1: [],
    melody2: [],
    drums: {}
  };
  
  // Inicializa os arrays de cada pe√ßa de bateria
  DRUM_SAMPLES.forEach(d => plan.drums[d.key] = []);
  
  // --- HARMONIA 1 ---
  state.harmonyBlocks[0].forEach(harmonyBlock => {
    const grid = harmonyBlock.grid;
    const instrument = harmonyBlock.instrumentSelect.value;
    const columns = grid.querySelectorAll('.column');
    columns.forEach(column => {
      const cell = column.querySelector('.cell');
      const chordValue = getCellNoteValue(cell);
      if (chordValue !== 'X') {
        plan.harmony1.push({ chord: chordValue, instrument });
      } else {
        plan.harmony1.push(null);
      }
    });
  });
  
  // --- HARMONIA 2 ---
  state.harmonyBlocks[1].forEach(harmonyBlock => {
    const grid = harmonyBlock.grid;
    const instrument = harmonyBlock.instrumentSelect.value;
    const columns = grid.querySelectorAll('.column');
    columns.forEach(column => {
      const cell = column.querySelector('.cell');
      const chordValue = getCellNoteValue(cell);
      if (chordValue !== 'X') {
        plan.harmony2.push({ chord: chordValue, instrument });
      } else {
        plan.harmony2.push(null);
      }
    });
  });
  
  // --- HARMONIA 3 ---
  state.harmonyBlocks[2].forEach(harmonyBlock => {
    const grid = harmonyBlock.grid;
    const instrument = harmonyBlock.instrumentSelect.value;
    const columns = grid.querySelectorAll('.column');
    columns.forEach(column => {
      const cell = column.querySelector('.cell');
      const chordValue = getCellNoteValue(cell);
      if (chordValue !== 'X') {
        plan.harmony3.push({ chord: chordValue, instrument });
      } else {
        plan.harmony3.push(null);
      }
    });
  });
  
  // Coleta todas as colunas dos instrumentos mel√≥dicos (Baixo, Melodia 1, Melodia 2)
  [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach((blocks, idx) => {
    const type = ['bass', 'melody1', 'melody2'][idx];
    blocks.forEach(wrapper => {
      const block = wrapper.querySelector('.instrument-block');
      const grid = block.querySelector('.columns-grid');
      const columns = grid.querySelectorAll('.column');
      // O seletor de instrumento est√° no wrapper pai
      const instrumentSelect = wrapper.querySelector('.instrument-select');
      const instrument = instrumentSelect ? instrumentSelect.value : 'piano';
      columns.forEach(column => {
        const cell = column.querySelector('.cell');
        const noteValue = getCellNoteValue(cell);
        if (noteValue === 'X') {
          plan[type].push(null);
        } else {
          plan[type].push({ note: noteValue, instrument: instrument });
        }
      });
    });
  });
  
  // Coleta as c√©lulas da bateria
  state.drumBlocks.forEach(block => {
    // Navega at√© o .columns-grid dentro do .drum-wrapper, se existir
    const drumWrapper = block.querySelector('.drum-wrapper');
    const grid = drumWrapper ? drumWrapper.querySelector('.columns-grid') : block.querySelector('.columns-grid');
    if (!grid) return;
    const columns = grid.querySelectorAll('.column');
    columns.forEach((column, stepIndex) => {
      DRUM_SAMPLES.forEach(drum => {
        const cell = column.querySelector(`.drum-cell[data-instr="${drum.key}"]`);
        if (cell) {
          plan.drums[drum.key].push(cell.classList.contains('active'));
        }
      });
    });
  });
  
  // Armazena o plano de playback no estado global
  state.playbackPlan = plan;
  state.stepIndex = 0;
  state.lastNoteTime = 0;
  return plan;
}

function scheduleStep(time) {
  const idx = state.stepIndex;
  const plan = state.playbackPlan;
  if (!plan) return;
  
  // HARMONIA 1
  if (idx < plan.harmony1.length && plan.harmony1[idx]) {
    const item = plan.harmony1[idx];
    if (item && item.chord !== 'X') {
      if (state.currentlyPlaying.harmony1 !== null) {
        state.currentlyPlaying.harmony1 = null;
      }
      playChord(item.instrument, item.chord, time, state.harmonicGain, 1.0);
      state.currentlyPlaying.harmony1 = item.chord;
    }
  }
  
  // HARMONIA 2
  if (idx < plan.harmony2.length && plan.harmony2[idx]) {
    const item = plan.harmony2[idx];
    if (item && item.chord !== 'X') {
      if (state.currentlyPlaying.harmony2 !== null) {
        state.currentlyPlaying.harmony2 = null;
      }
      playChord(item.instrument, item.chord, time, state.harmonicGain, 1.0);
      state.currentlyPlaying.harmony2 = item.chord;
    }
  }
  
  // HARMONIA 3
  if (idx < plan.harmony3.length && plan.harmony3[idx]) {
    const item = plan.harmony3[idx];
    if (item && item.chord !== 'X') {
      if (state.currentlyPlaying.harmony3 !== null) {
        state.currentlyPlaying.harmony3 = null;
      }
      playChord(item.instrument, item.chord, time, state.harmonicGain, 1.0);
      state.currentlyPlaying.harmony3 = item.chord;
    }
  }
  
  // BAIXO
  if (idx < plan.bass.length && plan.bass[idx]) {
    const item = plan.bass[idx];
    if (item && item.note) {
      if (state.currentlyPlaying.bass !== null) {
        state.currentlyPlaying.bass = null;
      }
      playNote(item.instrument, item.note, time, state.bassGain, 0.7);
      state.currentlyPlaying.bass = item.note;
    }
  }
  
  // MELODIA 1
  if (idx < plan.melody1.length && plan.melody1[idx]) {
    const item = plan.melody1[idx];
    if (item && item.note) {
      if (state.currentlyPlaying.melody1 !== null) {
        state.currentlyPlaying.melody1 = null;
      }
      playNote(item.instrument, item.note, time, state.melodyGain, 0.6);
      state.currentlyPlaying.melody1 = item.note;
    }
  }
  
  // MELODIA 2
  if (idx < plan.melody2.length && plan.melody2[idx]) {
    const item = plan.melody2[idx];
    if (item && item.note) {
      if (state.currentlyPlaying.melody2 !== null) {
        state.currentlyPlaying.melody2 = null;
      }
      playNote(item.instrument, item.note, time, state.melodyGain, 0.6);
      state.currentlyPlaying.melody2 = item.note;
    }
  }
  
  // BATERIA: N√ÉO MUTA ‚Äî PERMITE SOBREPOSI√á√ÉO NATURAL
  Object.keys(plan.drums).forEach(key => {
    if (idx < plan.drums[key].length && plan.drums[key][idx]) {
      playDrum(key, time, state.drumGain, 1.0); // ‚Üë Ganho aumentado
    }
  });
  
  state.stepIndex = (state.stepIndex + 1) % state.totalSteps;
}

function playNote(instrumentKey, note, time, gainNode, volume = 1.0) {
  if (!state.audioCtx) return;
  const bufferKey = `melodic-${instrumentKey}-${note}`;
  const buffer = state.buffers.melodic[bufferKey];
  if (!buffer) {
    console.warn(`Sample n√£o encontrado: ${instrumentKey}/${note}`);
    return;
  }
  const source = state.audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(gainNode);
  source.start(time);
  source.stop(time + 0.5); // Semicolcheia = 0.5s
}

function playChord(instrumentKey, chord, time, gainNode, volume = 1.0) {
  if (!state.audioCtx) return;
  if (chord === 'X') return;
  let root;
  if (chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(chord.slice(0, 2))) {
    root = chord.slice(0, 2);
  } else {
    root = chord[0];
  }
  // CORRE√á√ÉO FINAL: Monta o caminho exato do arquivo e usa como chave
  const filePath = HARMONIC_INSTRUMENTS[instrumentKey] + root + '/' + chord + '.mp3';
  const buffer = state.buffers.harmonic[filePath]; // ‚Üê BUSCA PELO CAMINHO COMPLETO
  if (!buffer) {
    console.warn(`Acorde n√£o encontrado: ${filePath}`);
    return;
  }
  const source = state.audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(gainNode);
  source.start(time);
  source.stop(time + 1.0); // Sem√≠nima = 1.0s
}

function playDrum(drumKey, time, gainNode, volume = 1.0) {
  if (!state.audioCtx) return;
  const buffer = state.buffers.drums[drumKey];
  if (!buffer) {
    console.warn(`Sample de bateria n√£o encontrado: ${drumKey}`);
    return;
  }
  const source = state.audioCtx.createBufferSource();
  source.buffer = buffer;
  const gain = state.audioCtx.createGain();
  gain.gain.setValueAtTime(volume, time);
  source.connect(gain);
  gain.connect(gainNode);
  source.start(time);
  // ‚ùå n√£o corta em 0.2s, deixa o sample tocar at√© o fim
}

function startScheduler() {
  state.isPlaying = true;
  ui.btnPlay.textContent = '‚è∏ Pause';
  ui.btnStop.disabled = false;
  function tick() {
    if (!state.isPlaying) return;
    const now = state.audioCtx.currentTime;
    const stepDuration = 60 / state.bpm / 4; // semicolcheia
    const nextStep = state.lastNoteTime + stepDuration;
    if (now >= nextStep) {
      scheduleStep(nextStep);
      state.lastNoteTime = nextStep;
      updatePlaybackProgress(); // Atualiza o progresso visual
    }
    requestAnimationFrame(tick);
  }
  state.lastNoteTime = state.audioCtx.currentTime;
  tick();
}

// ===== FUN√á√ÉO PARA ATUALIZAR PROGRESSO VISUAL =====
function updatePlaybackProgress() {
  // Limpa destaque anterior
  document.querySelectorAll('.cell, .drum-cell').forEach(cell => {
    cell.style.boxShadow = 'none';
  });
  // Destaca a c√©lula atual
  const currentStep = state.stepIndex;
  document.querySelectorAll(`.column:nth-child(${currentStep + 1}) .cell`).forEach(cell => {
    cell.style.boxShadow = '0 0 5px 2px #5eead4';
  });
  document.querySelectorAll(`.column:nth-child(${currentStep + 1}) .drum-cell`).forEach(cell => {
    cell.style.boxShadow = '0 0 5px 2px #5eead4';
  });
}

// ===== PLAY COM CONTAGEM REGRESSIVA DE 4 COMPASSOS =====
function onPlay() {
  if (!state.audioCtx) {
    updateStatus('Erro: Audio Context n√£o inicializado', 'error');
    return;
  }
  if (state.isPlaying) {
    state.isPlaying = false;
    ui.btnPlay.textContent = '‚ñ∂ Play';
    ui.btnStop.disabled = true;
    return;
  }
  try {
    if (state.audioCtx.state === 'suspended') {
      state.audioCtx.resume();
    }
    buildPlaybackPlan();
    const samplesToLoad = new Set();
    
    // Harmonia 1
    state.playbackPlan.harmony1.forEach(item => {
      if (item && item.chord !== 'X') {
        let root;
        if (item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))) {
          root = item.chord.slice(0, 2);
        } else {
          root = item.chord[0];
        }
        const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
        samplesToLoad.add(filePath);
      }
    });
    
    // Harmonia 2
    state.playbackPlan.harmony2.forEach(item => {
      if (item && item.chord !== 'X') {
        let root;
        if (item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))) {
          root = item.chord.slice(0, 2);
        } else {
          root = item.chord[0];
        }
        const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
        samplesToLoad.add(filePath);
      }
    });
    
    // Harmonia 3
    state.playbackPlan.harmony3.forEach(item => {
      if (item && item.chord !== 'X') {
        let root;
        if (item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))) {
          root = item.chord.slice(0, 2);
        } else {
          root = item.chord[0];
        }
        const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
        samplesToLoad.add(filePath);
      }
    });
    
    // Mel√≥dicas
    ['bass', 'melody1', 'melody2'].forEach(type => {
      state.playbackPlan[type].forEach(item => {
        if (item && item.note) {
          const bufferKey = `melodic-${item.instrument}-${item.note}`;
          samplesToLoad.add(bufferKey);
        }
      });
    });
    
    // Bateria ‚Äî usa o key direto (ex: 'ataque'), sem prefixo
    Object.keys(state.playbackPlan.drums).forEach(key => {
      if (state.playbackPlan.drums[key].some(active => active)) {
        samplesToLoad.add(key);
      }
    });
    
    updateStatus('Carregando amostras... Por favor, aguarde.', 'loading');
    ui.btnSaveWAV.disabled = true;
    ui.countdown.style.display = 'block';
    const promises = Array.from(samplesToLoad).map(bufferKey => {
      if (bufferKey.includes('melodic-')) {
        const parts = bufferKey.split('-');
        const instrumentKey = parts[1];
        const noteOrChord = parts.slice(2).join('-');
        return loadSample('melodic', instrumentKey, noteOrChord);
      } else if (bufferKey.includes('guitarra') || bufferKey.includes('PianoStringChord')) {
        let instrumentKey = '';
        let chord = '';
        if (bufferKey.startsWith('guitarraDistorcao/')) {
          instrumentKey = 'distorted-guitar';
          chord = bufferKey.replace('guitarraDistorcao/', '').replace('.mp3', '').split('/').pop();
        } else if (bufferKey.startsWith('guitarraLimpa/')) {
          instrumentKey = 'clean-guitar';
          chord = bufferKey.replace('guitarraLimpa/', '').replace('.mp3', '').split('/').pop();
        } else if (bufferKey.startsWith('assets/PianoStringChord/')) {
          instrumentKey = 'piano-chord';
          chord = bufferKey.replace('assets/PianoStringChord/', '').replace('.mp3', '').split('/').pop();
        }
        if (instrumentKey && chord) {
          return loadSample('harmonic', instrumentKey, chord);
        } else {
          console.warn('Caminho de acorde inv√°lido:', bufferKey);
          return Promise.resolve();
        }
      } else {
        return loadSample('drum', bufferKey, '');
      }
    });
    
     Promise.all(promises).then(() => {
      // >>>>> ADICIONE ESTA LINHA ABAIXO <<<<<
      ui.btnSaveWAV.disabled = false;
      startCountdown();
    }).catch(err => {
      console.error('Erro ao carregar amostras:', err);
      updateStatus('Erro ao carregar amostras. Verifique a conex√£o.', 'error');
    });
  } catch (error) {
    console.error('Erro ao iniciar reprodu√ß√£o:', error);
    updateStatus('Erro ao iniciar: ' + error.message, 'error');
  }
}

function startCountdown() {
  state.countdownActive = true;
  state.countdownValue = 4;
  ui.countdown.textContent = state.countdownValue;
  const sixteenthDur = 60 / state.bpm / 4;
  const beatDuration = sixteenthDur * 4;
  const interval = setInterval(() => {
    state.countdownValue--;
    ui.countdown.textContent = state.countdownValue;
    if (state.countdownValue <= 0) {
      clearInterval(interval);
      ui.countdown.style.display = 'none';
      state.countdownActive = false;
      startScheduler();
      updateStatus('Reproduzindo...', 'ready');
    }
  }, beatDuration * 1000);
}

function onStop() {
  state.isPlaying = false;
  state.stepIndex = 0;
  ui.btnPlay.textContent = '‚ñ∂ Play';
  ui.countdown.style.display = 'none';
  ui.btnStop.disabled = true;
  updateStatus('Reprodu√ß√£o parada', 'ready');
}

// ===== GRAVA√á√ÉO WAV COM BARRA DE PROGRESSO =====
async function renderAndDownloadWAV() {
  if (!state.playbackPlan) {
    alert('Crie alguma m√∫sica primeiro.');
    return;
  }
  updateStatus('Renderizando √°udio...', 'loading');
  ui.btnSaveWAV.disabled = true;
  ui.btnSaveWAV.textContent = '‚è≥ Renderizando...';
  ui.progressContainer.style.display = 'block';
  try {
    const sampleRate = 44100;
    const sixteenthDur = 60 / state.bpm / 4;
    // --- C√ÅLCULO CORRIGIDO DA DURA√á√ÉO ---
    // O √∫ltimo evento significativo termina 1 segundo ap√≥s o √∫ltimo passo (dura√ß√£o do acorde).
    const lastEventTime = (state.totalSteps - 1) * sixteenthDur + 1.0;
    // Adiciona 2 segundos de margem de seguran√ßa total.
    const safeDuration = lastEventTime + 2.0;
    const totalSamples = Math.ceil(safeDuration * sampleRate);
    // --- FIM DO C√ÅLCULO CORRIGIDO ---
    const offlineCtx = new OfflineAudioContext(2, totalSamples, sampleRate);
    const master = offlineCtx.createGain();
    const drumGain = offlineCtx.createGain();
    const bassGain = offlineCtx.createGain();
    const melodyGain = offlineCtx.createGain();
    const harmonicGain = offlineCtx.createGain();
    master.connect(offlineCtx.destination);
    drumGain.connect(master);
    bassGain.connect(master);
    melodyGain.connect(master);
    harmonicGain.connect(master);
    master.gain.value = 0.8;
    drumGain.gain.value = 1.0;
    bassGain.gain.value = 0.5;
    melodyGain.gain.value = 0.5;
    harmonicGain.gain.value = 0.5;
    const totalSteps = state.totalSteps;
    // Fun√ß√£o para atualizar a barra de progresso
    const updateProgress = (currentStep) => {
      const percent = Math.round((currentStep / totalSteps) * 100);
      ui.progressBar.style.width = `${percent}%`;
      ui.progressText.textContent = `${percent}%`;
    };
    for (let step = 0; step < totalSteps; step++) {
      const time = step * sixteenthDur;
      if (step % 10 === 0) {
        updateProgress(step);
      }
      
      // Harmonia 1 (dura 1.0s)
      if (step < state.playbackPlan.harmony1.length && state.playbackPlan.harmony1[step]) {
        const item = state.playbackPlan.harmony1[step];
        if (item && item.chord !== 'X') {
          let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))
            ? item.chord.slice(0, 2)
            : item.chord[0];
          const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
          const buffer = state.buffers.harmonic[filePath];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(harmonicGain);
            source.start(time);
            source.stop(time + 1.0); // Para no final da sem√≠nima
          }
        }
      }
      
      // Harmonia 2 (dura 1.0s)
      if (step < state.playbackPlan.harmony2.length && state.playbackPlan.harmony2[step]) {
        const item = state.playbackPlan.harmony2[step];
        if (item && item.chord !== 'X') {
          let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))
            ? item.chord.slice(0, 2)
            : item.chord[0];
          const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
          const buffer = state.buffers.harmonic[filePath];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(harmonicGain);
            source.start(time);
            source.stop(time + 1.0); // Para no final da sem√≠nima
          }
        }
      }
      
      // Harmonia 3 (dura 1.0s)
      if (step < state.playbackPlan.harmony3.length && state.playbackPlan.harmony3[step]) {
        const item = state.playbackPlan.harmony3[step];
        if (item && item.chord !== 'X') {
          let root = item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))
            ? item.chord.slice(0, 2)
            : item.chord[0];
          const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
          const buffer = state.buffers.harmonic[filePath];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(harmonicGain);
            source.start(time);
            source.stop(time + 1.0); // Para no final da sem√≠nima
          }
        }
      }
      
      // Baixo (dura 0.5s)
      if (step < state.playbackPlan.bass.length && state.playbackPlan.bass[step]) {
        const item = state.playbackPlan.bass[step];
        if (item && item.note) {
          const bufferKey = `melodic-${item.instrument}-${item.note}`;
          const buffer = state.buffers.melodic[bufferKey];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(bassGain);
            source.start(time);
            source.stop(time + 0.5); // Para no final da semicolcheia
          }
        }
      }
      
      // Melodia 1 & 2 (duram 0.5s)
      [[state.playbackPlan.melody1, melodyGain], [state.playbackPlan.melody2, melodyGain]].forEach(([melody, gain]) => {
        if (step < melody.length && melody[step]) {
          const item = melody[step];
          if (item && item.note) {
            const bufferKey = `melodic-${item.instrument}-${item.note}`;
            const buffer = state.buffers.melodic[bufferKey];
            if (buffer) {
              const source = offlineCtx.createBufferSource();
              source.buffer = buffer;
              source.connect(gain);
              source.start(time);
              source.stop(time + 0.5);
            }
          }
        }
      });
      
      // Bateria (n√£o para, deixa tocar at√© o fim)
      Object.keys(state.playbackPlan.drums).forEach(key => {
        if (step < state.playbackPlan.drums[key].length && state.playbackPlan.drums[key][step]) {
          const buffer = state.buffers.drums[key];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(drumGain);
            source.start(time);
            // N√£o chamamos source.stop() para permitir o sample tocar naturalmente.
          }
        }
      });
    }
    updateProgress(totalSteps);
    const renderedBuffer = await offlineCtx.startRendering();
    const wavBlob = audioBufferToWav(renderedBuffer);
    const fileName = `jam-on-${new Date().toISOString().slice(0,10)}-${Math.floor(Math.random()*1000)}.wav`;
    downloadBlob(wavBlob, fileName);
    updateStatus('Renderiza√ß√£o conclu√≠da!', 'ready');
  } catch (error) {
    console.error('Erro ao renderizar WAV:', error);
    updateStatus('Erro ao renderizar: ' + error.message, 'error');
  } finally {
    ui.btnSaveWAV.textContent = 'üíæ Salvar como WAV';
    ui.btnSaveWAV.disabled = false;
    ui.progressContainer.style.display = 'none';
  }
}

function audioBufferToWav(buffer) {
  const numOfChan = buffer.numberOfChannels;
  const length = buffer.length * numOfChan * 2 + 44;
  const arrayBuffer = new ArrayBuffer(length);
  const view = new DataView(arrayBuffer);
  const channels = [];
  let i, sample, offset = 0;
  function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }
  writeString(view, 0, 'RIFF');
  view.setUint32(4, length - 8, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numOfChan, true);
  view.setUint32(24, 44100, true);
  view.setUint32(28, 44100 * 2 * numOfChan, true);
  view.setUint16(32, 2 * numOfChan, true);
  view.setUint16(34, 16, true);
  writeString(view, 36, 'data');
  view.setUint32(40, length - 44, true);
  for (i = 0; i < buffer.numberOfChannels; i++) {
    channels.push(buffer.getChannelData(i));
  }
  offset = 44;
  for (i = 0; i < buffer.length; i++) {
    for (let channel = 0; channel < numOfChan; channel++) {
      sample = Math.max(-1, Math.min(1, channels[channel][i]));
      sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF);
      view.setInt16(offset, sample, true);
      offset += 2;
    }
  }
  return new Blob([view], { type: 'audio/wav' });
}

function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.style.display = 'none';
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 100);
}

// ===== INICIALIZAR =====
window.addEventListener('load', initializeApp);
</script>
<!-- MAPA DE EDI√á√ÉO -->
<div id="editMapContainer" class="edit-map-container">
  <div class="edit-map-title">Mapa de Edi√ß√£o</div>
  <div id="editMapContent">
    <!-- Os itens ser√£o gerados dinamicamente aqui -->
  </div>
</div>
</body>
</html>
