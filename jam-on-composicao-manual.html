<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jam On ‚Äì Composi√ß√£o Manual</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      background: #121212;
      color: #e0e0e0;
      margin: 0;
      padding: 20px;
    }
    header {
      text-align: center;
      margin-bottom: 20px;
    }
    h1 {
      color: #5eead4;
      font-size: 1.8em;
      margin: 0;
    }
    .pill {
      display: inline-block;
      background: #333;
      color: #aaa;
      font-size: 0.75em;
      padding: 4px 10px;
      border-radius: 12px;
    }
    .card {
      max-width: 1200px;
      margin: 0 auto;
      background: #1e1e1e;
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      overflow: hidden;
      padding: 20px;
      text-align: left;
    }
    .section {
      margin: 25px 0;
      padding: 15px;
      border: 1px solid #333;
      border-radius: 10px;
      background: #222;
    }
    .section h3 {
      color: #5eead4;
      margin-top: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .add-btn {
      background: #4CAF50;
      color: white;
      font-size: 1.2em;
      padding: 6px 10px;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    .instrument-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin: 15px 0;
    }
    .instrument-block {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      min-width: 220px;
    }
    .bass-block { border-left: 4px solid #ffcc00; }
    .melody1-block { border-left: 4px solid #ff6b6b; }
    .melody2-block { border-left: 4px solid #4ecdc4; }
    .drum-block { border-left: 4px solid #8e44ad; }
    .harmony-block { border-left: 4px solid #9b59b6; }
    /* ===== ESTILO DO GRID DE COLUNAS ===== */
    .columns-grid {
      display: flex;
      gap: 2px;
      margin: 10px 0;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding: 5px 0;
    }
    .column {
      display: flex;
      flex-direction: column;
      gap: 2px;
      align-items: center;
    }
    .cell {
      width: 45px;
      height: 45px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7em;
      cursor: pointer;
      color: #ccc;
      user-select: none;
      transition: background 0.2s;
      position: relative; /* Para posicionar o bot√£o de delete */
    }
    .cell:hover {
      background: #444;
    }
    .cell.x {
      background: #555;
      color: #888;
      font-weight: bold;
    }
    /* Bot√£o de Excluir Coluna - CORRIGIDO: Adicionado z-index */
    .delete-column-btn {
      position: absolute;
      top: -8px;
      right: -8px;
      background: #f44336;
      color: white;
      border: none;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      font-size: 0.6em;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      z-index: 10; /* ‚Üê Garante que o bot√£o fique acima da c√©lula */
    }
    .delete-column-btn:hover {
      background: #d32f2f;
    }
    .drum-grid {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin: 10px 0;
    }
    .drum-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .drum-label {
      width: 120px;
      padding: 5px;
      background: #2a2a2a;
      border: 1px solid #444;
      text-align: right;
      font-size: 0.8em;
      color: #ccc;
      border-radius: 4px;
    }
    .drum-cell {
      width: 45px;
      height: 45px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7em;
      cursor: pointer;
      color: #ccc;
      transition: background 0.2s;
    }
    .drum-cell.active {
      background: #5eead4;
      color: #121212;
    }
    .drum-cell:hover {
      background: #444;
    }
    .instrument-select, .chord-select {
      margin: 10px 0;
      padding: 8px;
      background: #333;
      border: 1px solid #555;
      border-radius: 4px;
      color: white;
      width: 100%;
    }
    .bpm-control {
      text-align: center;
      margin: 15px 0;
    }
    .bpm-display {
      font-size: 1.5em;
      font-weight: bold;
      color: #5eead4;
      margin: 10px 0;
    }
    .bpm-slider {
      width: 80%;
      margin: 10px auto;
    }
    .btn-row {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
    }
    button {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      font-size: 1em;
      transition: opacity 0.2s;
    }
    button.primary {
      background: #5eead4;
      color: #121212;
    }
    button.danger {
      background: #f44336;
      color: white;
    }
    button:hover:not(:disabled) {
      opacity: 0.9;
    }
    .loading {
      text-align: center;
      padding: 20px;
      color: #5eead4;
    }
    .status-indicator {
      text-align: center;
      padding: 10px;
      margin: 10px 0;
      border-radius: 6px;
    }
    .status-ready {
      background: #2a4d2a;
      color: #8eff8e;
    }
    .status-loading {
      background: #4d462a;
      color: #ffe08e;
    }
    .status-error {
      background: #4d2a2a;
      color: #ff8e8e;
    }
    .instructions {
      font-size: 0.85em;
      color: #aaa;
      margin-top: 8px;
      text-align: center;
    }
    .countdown {
      font-size: 2em;
      color: #ffcc00;
      text-align: center;
      margin: 20px 0;
      font-weight: bold;
    }
    /* ===== ESTILO DO MODAL ===== */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    .modal {
      background: #2a2a2a;
      border: 2px solid #5eead4;
      border-radius: 12px;
      padding: 20px;
      max-width: 90%;
      max-height: 90%;
      overflow-y: auto;
      box-shadow: 0 0 30px rgba(94, 234, 212, 0.5);
    }
    .modal h2 {
      color: #5eead4;
      margin-top: 0;
      text-align: center;
    }
    .modal-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 8px;
      margin-top: 20px;
    }
    .modal-option {
      padding: 10px;
      background: #333;
      border: 1px solid #555;
      border-radius: 6px;
      text-align: center;
      cursor: pointer;
      transition: background 0.2s;
    }
    .modal-option:hover {
      background: #444;
    }
    .modal-option.x {
      background: #555;
      color: #888;
    }
    /* ===== ESTILO DA BARRA DE PROGRESSO ===== */
    .progress-container {
      width: 100%;
      background: #333;
      border-radius: 4px;
      margin: 10px 0;
      height: 10px;
    }
    .progress-bar {
      height: 100%;
      background: #5eead4;
      border-radius: 4px;
      width: 0%;
      transition: width 0.3s ease;
    }
    @media (max-width: 768px) {
      .cell, .drum-cell { 
        width: 35px;
        height: 35px;
        font-size: 0.6em;
      }
      .drum-label { 
        width: 80px;
        font-size: 0.7em; 
        padding: 4px;
      }
      button { padding: 10px 15px; }
      .add-btn { width: 25px; height: 25px; font-size: 1em; }
      .instrument-block { min-width: 160px; }
      .delete-column-btn {
        width: 14px;
        height: 14px;
        font-size: 0.5em;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Jam On ‚Äì Composi√ß√£o Manual</h1>
    <div class="pill">Cada c√©lula = semicolcheia (1/4 da sem√≠nima)</div>
  </header>
  <div class="card">
    <div id="statusIndicator" class="status-indicator status-loading">
      Carregando... Clique 8 vezes para preparar o som.
    </div>
    <div class="countdown" id="countdown"></div>
    <div class="section">
      <h3>üéõÔ∏è Controle de BPM</h3>
      <div class="bpm-control">
        <div class="bpm-display" id="bpmDisplay">100 BPM</div>
        <input type="range" id="bpmSlider" class="bpm-slider" min="60" max="180" value="100" step="1">
      </div>
    </div>
    <!-- √öNICO BOT√ÉO "+" QUE ADICIONA COMPASSO EM TODOS OS INSTRUMENTOS -->
    <div style="text-align: center; margin: 20px 0;">
      <button id="addCompassoBtn" class="add-btn">+</button>
      <span style="color: #aaa; margin-left: 10px;">Adicionar compasso em todos os instrumentos</span>
    </div>
    <!-- HARMONIA (4 c√©lulas por instrumento = 1 compasso) -->
    <div class="section">
      <h3>üé∏ Harmonia</h3>
      <div id="harmonyContainer" class="instrument-container"></div>
    </div>
    <!-- BAIXO (4 c√©lulas = 1 compasso) -->
    <div class="section">
      <h3>üé∏ Baixo</h3>
      <div id="bassContainer" class="instrument-container"></div>
    </div>
    <!-- MELODIA 1 (4 c√©lulas = 1 compasso) -->
    <div class="section">
      <h3>üéπ Melodia 1</h3>
      <div id="melody1Container" class="instrument-container"></div>
    </div>
    <!-- MELODIA 2 (4 c√©lulas = 1 compasso) -->
    <div class="section">
      <h3>üé∑ Melodia 2</h3>
      <div id="melody2Container" class="instrument-container"></div>
    </div>
    <!-- BATERIA (4 c√©lulas = 1 compasso) -->
    <div class="section">
      <h3>ü•Å Bateria</h3>
      <div id="drumContainer" class="instrument-container"></div>
    </div>
    <div class="btn-row">
      <button id="btnPlay" class="primary" disabled>‚ñ∂ Play</button>
      <button id="btnStop" class="danger" disabled>‚èπ Stop</button>
      <button id="btnSaveWAV" class="primary" disabled>üíæ Salvar como WAV</button>
    </div>
    <div class="instructions">
      Clique em uma c√©lula para escolher uma nota ou acorde.<br>
      Use "+" para adicionar uma coluna em todos os instrumentos.<br>
      <strong>Clique 8 vezes em qualquer c√©lula para preparar os sons.</strong>
    </div>
  </div>
  <!-- MODAL (inicialmente oculto) -->
  <div id="selectionModal" class="modal-overlay" style="display: none;">
    <div class="modal">
      <h2 id="modalTitle">Selecione uma op√ß√£o</h2>
      <div id="modalGrid" class="modal-grid">
        <!-- As op√ß√µes ser√£o inseridas aqui dinamicamente -->
      </div>
    </div>
  </div>
  <!-- CONTAINER DA BARRA DE PROGRESSO (inicialmente oculto) -->
  <div id="progressContainer" style="display: none; text-align: center; margin: 20px 0;">
    <div>Renderizando...</div>
    <div class="progress-container">
      <div id="progressBar" class="progress-bar"></div>
    </div>
    <div id="progressText">0%</div>
  </div>
 <script>
// ===== CONSTANTES =====
const AVAILABLE_CHORDS = [
  'X', // ‚Üê OP√á√ÉO EM BRANCO ADICIONADA
  // Acordes em A
  'A', 'A11', 'A13', 'A4', 'A45+', 'A5', 'A5+', 'A6', 'A7', 'A75+', 'A9', 'A95+', 'Adim', 
  'Am', 'Am4', 'Am5', 'Am5+', 'Am6', 'Am7', 'Am75+', 'Am79', 'Am9',
  // Acordes em AS (A#)
  'AS', 'AS11', 'AS13', 'AS4', 'AS45+', 'AS5', 'AS5+', 'AS6', 'AS7', 'AS75+', 'AS9', 'AS95+',
  'ASdim', 'ASm', 'ASm4', 'ASm5', 'ASm5+', 'ASm6', 'ASm7', 'ASm75+', 'ASm79', 'ASm9',
  // Acordes em B
  'B', 'B11', 'B13', 'B4', 'B45+', 'B5', 'B5+', 'B6', 'B7', 'B75+', 'B9', 'B95+', 'Bdim',
  'Bm', 'Bm4', 'Bm5', 'Bm5+', 'Bm6', 'Bm7', 'Bm75+', 'Bm79', 'Bm9',
  // Acordes em C
  'C', 'C11', 'C13', 'C4', 'C45+', 'C5', 'C5+', 'C6', 'C7', 'C75+', 'C9', 'C95+', 'Cdim',
  'Cm', 'Cm4', 'Cm5', 'Cm5+', 'Cm6', 'Cm7', 'Cm75+', 'Cm79', 'Cm9',
  // Acordes em CS (C#)
  'CS', 'CS11', 'CS13', 'CS4', 'CS45+', 'CS5', 'CS5+', 'CS6', 'CS7', 'CS75+', 'CS9', 'CS95+',
  'CSdim', 'CSm', 'CSm4', 'CSm5', 'CSm5+', 'CSm6', 'CSm7', 'CSm75+', 'CSm79', 'CSm9',
  // Acordes em D
  'D', 'D11', 'D13', 'D4', 'D45+', 'D5', 'D5+', 'D6', 'D7', 'D75+', 'D9', 'D95+', 'Ddim',
  'Dm', 'Dm4', 'Dm5', 'Dm5+', 'Dm6', 'Dm7', 'Dm75+', 'Dm79', 'Dm9',
  // Acordes em E
  'E', 'E11', 'E13', 'E4', 'E45+', 'E5', 'E5+', 'E6', 'E7', 'E75+', 'E9', 'E95+', 'Edim',
  'Em', 'Em4', 'Em5', 'Em5+', 'Em6', 'Em7', 'Em75+', 'Em79', 'Em9',
  // Acordes em DS (D#)
  'DS', 'DS11', 'DS13', 'DS4', 'DS45+', 'DS5', 'DS5+', 'DS6', 'DS7', 'DS75+', 'DS9', 'DS95+',
  'DSdim', 'DSm', 'DSm4', 'DSm5', 'DSm5+', 'DSm6', 'DSm7', 'DSm75+', 'DSm79', 'DSm9',
  // Acordes em F
  'F', 'F11', 'F13', 'F4', 'F45+', 'F5', 'F5+', 'F6', 'F7', 'F75+', 'F9', 'F95+', 'Fdim',
  'Fm', 'Fm4', 'Fm5', 'Fm5+', 'Fm6', 'Fm7', 'Fm75+', 'Fm79', 'Fm9',
  // Acordes em FS (F#)
  'FS', 'FS11', 'FS13', 'FS4', 'FS45+', 'FS5', 'FS5+', 'FS6', 'FS7', 'FS75+', 'FS9', 'FS95+',
  'FSdim', 'FSm', 'FSm4', 'FSm5', 'FSm5+', 'FSm6', 'FSm7', 'FSm75+', 'FSm79', 'FSm9',
  // Acordes em G
  'G', 'G11', 'G13', 'G4', 'G45+', 'G5', 'G5+', 'G6', 'G7', 'G75+', 'G9', 'G95+', 'Gdim',
  'Gm', 'Gm4', 'Gm5', 'Gm5+', 'Gm6', 'Gm7', 'Gm75+', 'Gm79', 'Gm9',
  // Acordes em GS (G#)
  'GS', 'GS11', 'GS13', 'GS4', 'GS45+', 'GS5', 'GS5+', 'GS6', 'GS7', 'GS75+', 'GS9', 'GS95+',
  'GSdim', 'GSm', 'GSm4', 'GSm5', 'GSm5+', 'GSm6', 'GSm7', 'GSm75+', 'GSm79', 'GSm9'
];
const NOTE_NAMES = [
  'X', // ‚Üê OP√á√ÉO EM BRANCO ADICIONADA
  '10CS.mp3', '11D.mp3', '12DS.mp3', '13E.mp3', '14F.mp3', '15FS.mp3', '16G.mp3', '17GS.mp3', 
  '18A.mp3', '19AS.mp3', '1E.mp3', '20B.mp3', '21C.mp3', '22CS.mp3', '23D.mp3', '24DS.mp3', 
  '25E.mp3', '26F.mp3', '27FS.mp3', '28G.mp3', '29GS.mp3', '2F.mp3', '30A.mp3', '31AS.mp3', 
  '32B.mp3', '33C.mp3', '34CS.mp3', '35D.mp3', '36DS.mp3', '37E.mp3', '38F.mp3', '39FS.mp3', 
  '3FS.mp3', '40G.mp3', '41GS.mp3', '42A.mp3', '43AS.mp3', '44B.mp3', '45C.mp3', '46CS.mp3', 
  '47D.mp3', '48DS.mp3', '49E.mp3', '4G.mp3', '5GS.mp3', '6A.mp3', '7AS.mp3', '8B.mp3', '9C.mp3'
];
const ALL_NOTES = NOTE_NAMES.map(name => name.replace('.mp3', ''));
const NOTE_FREQ = {
  'C': 261.63, 'CS': 277.18, 'D': 293.66, 'DS': 311.13, 'E': 329.63, 'F': 349.23,
  'FS': 369.99, 'G': 392.00, 'GS': 415.30, 'A': 440.00, 'AS': 466.16, 'B': 493.88
};
const MELODIC_INSTRUMENTS = {
  'acordeon': 'assets/AcordeonMelodia/',
  'bass': 'assets/BaixoMelodia/',
  'strings': 'assets/Cordas/',
  'piano': 'assets/PianoString/',
  'sax': 'assets/SaxMelodia/',
  'acoustic-guitar': 'assets/ViolaoAcoMelodia/',
  'nylon-guitar': 'assets/ViolaoNylonMelodia/'
};
const HARMONIC_INSTRUMENTS = {
  'distorted-guitar': 'guitarraDistorcao/',   // ‚Üê CORRETO: termina com /
  'clean-guitar': 'guitarraLimpa/',          // ‚Üê CORRETO: termina com /
  'piano-chord': 'assets/PianoStringChord/'  // ‚Üê CORRETO: termina com /
};
const DRUM_SAMPLES = [
  { key: 'ataque', label: 'Prato De Ataque', path: 'assets/ataque.mp3' },
  { key: 'bumbo', label: 'Bumbo', path: 'assets/bumbo.mp3' },
  { key: 'caixa', label: 'Caixa', path: 'assets/caixa.mp3' },
  { key: 'chimbal', label: 'Chimbal Fechado', path: 'assets/chimbal.mp3' },
  { key: 'chimbal-aberto', label: 'Chimbal Aberto', path: 'assets/chimbal-aberto.mp3' },
  { key: 'conducao', label: 'Condu√ß√£o', path: 'assets/conducao.mp3' },
  { key: 'conducao-centro', label: 'Condu√ß√£o Centro', path: 'assets/conducao-centro.mp3' },
  { key: 'surdo', label: 'Surdo', path: 'assets/surdo.mp3' },
  { key: 'tom-1', label: 'Tom 1', path: 'assets/tom-1.mp3' },
  { key: 'tom-2', label: 'Tom 2', path: 'assets/tom-2.mp3' }
];
// ===== ESTADO =====
const state = {
  running: false,
  paused: false,
  bpm: 100,
  stepIndex: 0,
  totalSteps: 4,
  buffers: {
    drums: {},
    melodic: {},
    harmonic: {}
  },
  loadedSamples: new Set(),
  activeInput: null,
  schedulerTimer: null,
  harmonyBlocks: [],
  bassBlocks: [],
  melody1Blocks: [],
  melody2Blocks: [],
  drumBlocks: [],
  lastNoteTime: 0,
  recordedChunks: [],
  audioCtx: null,
  isPlaying: false,
  isRendering: false,
  countdownActive: false,
  countdownValue: 4,
  currentlyPlaying: { 
    bass: null,
    melody1: null,
    melody2: null,
    harmony: null
  },
  playbackPlan: null,
  // Estado do Modal
  modal: {
    targetCell: null,
    type: null, // 'harmony' ou 'melodic'
    instrumentKey: null
  }
};
// ===== ELEMENTOS =====
const ui = {
  statusIndicator: document.getElementById('statusIndicator'),
  countdown: document.getElementById('countdown'),
  bpmSlider: document.getElementById('bpmSlider'),
  bpmDisplay: document.getElementById('bpmDisplay'),
  btnPlay: document.getElementById('btnPlay'),
  btnStop: document.getElementById('btnStop'),
  btnSaveWAV: document.getElementById('btnSaveWAV'),
  addCompassoBtn: document.getElementById('addCompassoBtn'),
  harmonyContainer: document.getElementById('harmonyContainer'),
  bassContainer: document.getElementById('bassContainer'),
  melody1Container: document.getElementById('melody1Container'),
  melody2Container: document.getElementById('melody2Container'),
  drumContainer: document.getElementById('drumContainer'),
  selectionModal: document.getElementById('selectionModal'),
  modalTitle: document.getElementById('modalTitle'),
  modalGrid: document.getElementById('modalGrid'),
  progressContainer: document.getElementById('progressContainer'),
  progressBar: document.getElementById('progressBar'),
  progressText: document.getElementById('progressText')
};
// ===== INICIALIZA√á√ÉO =====
async function initializeApp() {
  updateStatus('Pronto para compor. Clique nas c√©lulas para criar sua m√∫sica.', 'ready');
  try {
    state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    state.masterGain = state.audioCtx.createGain();
    state.drumGain = state.audioCtx.createGain();
    state.bassGain = state.audioCtx.createGain();
    state.melodyGain = state.audioCtx.createGain();
    state.harmonicGain = state.audioCtx.createGain();
    state.masterGain.connect(state.audioCtx.destination);
    state.drumGain.connect(state.masterGain);
    state.bassGain.connect(state.masterGain);
    state.melodyGain.connect(state.masterGain);
    state.harmonicGain.connect(state.masterGain);
    state.masterGain.gain.value = 0.8;
    state.drumGain.gain.value = 1.0; // ‚Üë Para evitar abafamento
    state.bassGain.gain.value = 0.5;
    state.melodyGain.gain.value = 0.5;
    state.harmonicGain.gain.value = 0.5;
    setupEventListeners();
    // Inicia com 1 bloco de cada tipo
    addHarmonyBlock(); // 4 c√©lulas (1 compasso)
    addBassBlock();    // 4 c√©lulas (1 compasso)
    addMelody1Block(); // 4 c√©lulas (1 compasso)
    addMelody2Block(); // 4 c√©lulas (1 compasso)
    addDrumBlock();    // 4 c√©lulas (1 compasso)
    ui.btnPlay.disabled = false;
    ui.btnSaveWAV.disabled = true;
    ui.btnStop.disabled = true;
    updateStatus('Componha sua m√∫sica. Clique em Play para iniciar com contagem de 4 compassos.', 'ready');
  } catch (error) {
    console.error('Erro ao inicializar:', error);
    updateStatus('Erro ao inicializar: ' + error.message, 'error');
  }
}
function setupEventListeners() {
  updateBPMDisplay();
  ui.bpmSlider.addEventListener('input', handleBPMChange);
  ui.addCompassoBtn.addEventListener('click', addCompasso);
  ui.btnPlay.addEventListener('click', onPlay);
  ui.btnStop.addEventListener('click', onStop);
  ui.btnSaveWAV.addEventListener('click', () => renderAndDownloadWAV()); // Sem dura√ß√£o fixa
  document.addEventListener('click', function(e) {
    if (e.target.classList.contains('cell') || e.target.classList.contains('drum-cell')) {
      if (e.target.classList.contains('cell')) {
        const instrument = e.target.parentElement.parentElement.querySelector('.instrument-select').value;
        const type = e.target.parentElement.dataset.type;
        const noteOrChord = e.target.textContent;
        if (type === 'harmony') {
          loadSample('harmonic', instrument, noteOrChord);
        } else {
          loadSample('melodic', instrument, noteOrChord);
        }
      } else if (e.target.classList.contains('drum-cell')) {
        const drumKey = e.target.dataset.instr;
        loadSample('drum', drumKey, '');
      }
    }
  });
  // Evento para fechar o modal ao clicar fora dele
  ui.selectionModal.addEventListener('click', function(e) {
    if (e.target === this) {
      closeModal();
    }
  });
}
function handleBPMChange() {
  state.bpm = parseInt(ui.bpmSlider.value);
  updateBPMDisplay();
}
function updateBPMDisplay() {
  ui.bpmDisplay.textContent = `${state.bpm} BPM`;
}
function updateStatus(message, type) {
  ui.statusIndicator.textContent = message;
  ui.statusIndicator.className = 'status-indicator status-' + type;
}
// ===== CARREGAMENTO SOB DEMANDA (CORRIGIDO) =====
async function loadSample(instrumentType, key, noteOrChord) {
  let filePath;
  let bufferKey;
  if (instrumentType === 'drum') {
    const sample = DRUM_SAMPLES.find(d => d.key === key);
    if (!sample) return;
    filePath = sample.path;
    bufferKey = key;
  } else if (instrumentType === 'melodic') {
    if (noteOrChord === 'X') return; // Ignora 'X'
    filePath = MELODIC_INSTRUMENTS[key] + noteOrChord + '.mp3';
    bufferKey = `melodic-${key}-${noteOrChord}`; // ‚Üê CORRE√á√ÉO: Usa 'key', n√£o 'MELODIC_INSTRUMENTS[key]'
  } else if (instrumentType === 'harmonic') {
    if (noteOrChord === 'X') return; // Ignora 'X'
    let root;
    if (noteOrChord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(noteOrChord.slice(0, 2))) {
      root = noteOrChord.slice(0, 2);
    } else {
      root = noteOrChord[0];
    }
    filePath = HARMONIC_INSTRUMENTS[key] + root + '/' + noteOrChord + '.mp3';
    // CORRE√á√ÉO FINAL: A chave do buffer √© o caminho do arquivo em si
    bufferKey = filePath;
  }
  if (!filePath) return;
  if (state.loadedSamples.has(bufferKey)) return;
  try {
    const response = await fetch(filePath);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const arrayBuffer = await response.arrayBuffer();
    const buffer = await state.audioCtx.decodeAudioData(arrayBuffer);
    if (instrumentType === 'drum') {
      state.buffers.drums[bufferKey] = buffer;
    } else if (instrumentType === 'melodic') {
      state.buffers.melodic[bufferKey] = buffer;
    } else if (instrumentType === 'harmonic') {
      state.buffers.harmonic[bufferKey] = buffer;
    }
    state.loadedSamples.add(bufferKey);
    console.log(`‚úÖ Carregado: ${filePath} ‚Üí chave: ${bufferKey}`);
  } catch (err) {
    console.warn(`‚ö†Ô∏è N√£o encontrado: ${filePath}`);
  }
}
// ===== MODAL DE SELE√á√ÉO =====
function openModal(type, options, targetCell, instrumentKey) {
  state.modal.type = type;
  state.modal.targetCell = targetCell;
  state.modal.instrumentKey = instrumentKey;
  // CORRE√á√ÉO: Usa 'type' para definir o t√≠tulo corretamente
  ui.modalTitle.textContent = type === 'harmony' ? 'Selecione um Acorde' : 'Selecione uma Nota';
  // Limpa o grid
  ui.modalGrid.innerHTML = '';
  // Preenche o grid com as op√ß√µes
  options.forEach(option => {
    const div = document.createElement('div');
    div.className = 'modal-option';
    if (option === 'X') {
      div.classList.add('x');
    }
    div.textContent = option;
    div.addEventListener('click', function() {
      targetCell.textContent = option;
      if (option === 'X') {
        targetCell.classList.add('x');
      } else {
        targetCell.classList.remove('x');
      }
      // Muta o som anterior
      const category = type === 'harmony' ? 'harmony' : targetCell.parentElement.parentElement.dataset.type.replace('Block', '').toLowerCase();
      if (state.currentlyPlaying[category] !== null) {
        state.currentlyPlaying[category] = null;
      }
      // Carrega a amostra
      if (type === 'harmony') {
        loadSample('harmonic', instrumentKey, option);
      } else {
        loadSample('melodic', instrumentKey, option);
      }
      closeModal();
    });
    ui.modalGrid.appendChild(div);
  });
  ui.selectionModal.style.display = 'flex';
}
function closeModal() {
  ui.selectionModal.style.display = 'none';
  state.modal = {
    targetCell: null,
    type: null,
    instrumentKey: null
  };
}
// ===== BLOCOS DE INSTRUMENTOS =====
function addHarmonyBlock() {
  const blockIndex = state.harmonyBlocks.length;
  const block = document.createElement('div');
  block.className = 'instrument-block harmony-block';
  block.dataset.blockIndex = blockIndex;
  // Remove o t√≠tulo "Bloco X"
  // Adiciona o seletor de instrumento
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.innerHTML = `
    <option value="distorted-guitar">Guitarra Distorcida</option>
    <option value="clean-guitar">Guitarra Limpa</option>
    <option value="piano-chord">Piano</option>
  `;
  block.appendChild(instrumentSelect);
  const grid = document.createElement('div');
  grid.className = 'columns-grid';
  grid.dataset.type = 'harmony';
  grid.dataset.blockIndex = blockIndex;
  for (let i = 0; i < 4; i++) { // ‚Üê 4 c√©lulas por instrumento (1 compasso)
    createHarmonyColumn(grid, i);
  }
  block.appendChild(grid);
  ui.harmonyContainer.appendChild(block);
  state.harmonyBlocks.push(block);
  return block;
}
function createHarmonyColumn(parentGrid, columnIndex) {
  const column = document.createElement('div');
  column.className = 'column';
  column.dataset.columnIndex = columnIndex;
  const cell = document.createElement('div');
  cell.className = 'cell x';
  cell.textContent = 'X';
  cell.addEventListener('click', function(e) {
    e.stopPropagation();
    const instrumentKey = this.closest('.instrument-block').querySelector('.instrument-select').value;
    openModal('harmony', AVAILABLE_CHORDS, this, instrumentKey);
  });
  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'delete-column-btn';
  deleteBtn.textContent = 'üóëÔ∏è';
  deleteBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    deleteColumn(columnIndex);
  });
  column.appendChild(cell);
  column.appendChild(deleteBtn);
  parentGrid.appendChild(column);
}
function addBassBlock() {
  const blockIndex = state.bassBlocks.length;
  const block = document.createElement('div');
  block.className = 'instrument-block bass-block';
  block.dataset.blockIndex = blockIndex;
  // Remove o t√≠tulo "Bloco X"
  // Adiciona o seletor de instrumento
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.innerHTML = `
    <option value="bass">Baixo</option>
    <option value="acoustic-guitar">Viol√£o A√ßo</option>
    <option value="nylon-guitar">Viol√£o Nylon</option>
    <option value="strings">Cordas</option>
  `;
  block.appendChild(instrumentSelect);
  const grid = createMelodicGrid('bass', blockIndex, 4);
  block.appendChild(grid);
  ui.bassContainer.appendChild(block);
  state.bassBlocks.push(block);
  return block;
}
function addMelody1Block() {
  const blockIndex = state.melody1Blocks.length;
  const block = document.createElement('div');
  block.className = 'instrument-block melody1-block';
  block.dataset.blockIndex = blockIndex;
  // Remove o t√≠tulo "Bloco X"
  // Adiciona o seletor de instrumento
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.innerHTML = `
    <option value="piano">Piano</option>
    <option value="sax">Saxofone</option>
    <option value="acordeon">Acordeon</option>
    <option value="strings">Cordas</option>
    <option value="acoustic-guitar">Viol√£o A√ßo</option>
    <option value="nylon-guitar">Viol√£o Nylon</option>
  `;
  block.appendChild(instrumentSelect);
  const grid = createMelodicGrid('melody1', blockIndex, 4);
  block.appendChild(grid);
  ui.melody1Container.appendChild(block);
  state.melody1Blocks.push(block);
  return block;
}
function addMelody2Block() {
  const blockIndex = state.melody2Blocks.length;
  const block = document.createElement('div');
  block.className = 'instrument-block melody2-block';
  block.dataset.blockIndex = blockIndex;
  // Remove o t√≠tulo "Bloco X"
  // Adiciona o seletor de instrumento
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.innerHTML = `
    <option value="sax">Saxofone</option>
    <option value="piano">Piano</option>
    <option value="acordeon">Acordeon</option>
    <option value="strings">Cordas</option>
    <option value="acoustic-guitar">Viol√£o A√ßo</option>
    <option value="nylon-guitar">Viol√£o Nylon</option>
  `;
  block.appendChild(instrumentSelect);
  const grid = createMelodicGrid('melody2', blockIndex, 4);
  block.appendChild(grid);
  ui.melody2Container.appendChild(block);
  state.melody2Blocks.push(block);
  return block;
}
function addDrumBlock() {
  const blockIndex = state.drumBlocks.length;
  const block = document.createElement('div');
  block.className = 'instrument-block drum-block';
  block.dataset.blockIndex = blockIndex;
  // Remove o t√≠tulo "Bloco X"
  const drumGrid = document.createElement('div');
  drumGrid.className = 'drum-grid';
  DRUM_SAMPLES.forEach(drum => {
    const row = document.createElement('div');
    row.className = 'drum-row';
    const label = document.createElement('div');
    label.className = 'drum-label';
    label.textContent = drum.label;
    row.appendChild(label);
    for (let i = 0; i < 4; i++) { // 4 c√©lulas (1 compasso)
      const cell = document.createElement('div');
      cell.className = 'drum-cell';
      cell.dataset.step = i;
      cell.dataset.instr = drum.key;
      cell.dataset.block = blockIndex;
      cell.addEventListener('click', function() {
        this.classList.toggle('active');
        loadSample('drum', drum.key, '');
      });
      row.appendChild(cell);
    }
    drumGrid.appendChild(row);
  });
  block.appendChild(drumGrid);
  ui.drumContainer.appendChild(block);
  state.drumBlocks.push(block);
  return block;
}
function createMelodicGrid(type, blockIndex, numColumns) {
  const grid = document.createElement('div');
  grid.className = 'columns-grid';
  grid.dataset.type = type;
  grid.dataset.blockIndex = blockIndex;
  for (let i = 0; i < numColumns; i++) {
    createMelodicColumn(grid, type, i);
  }
  return grid;
}
function createMelodicColumn(parentGrid, type, columnIndex) {
  const column = document.createElement('div');
  column.className = 'column';
  column.dataset.columnIndex = columnIndex;
  const cell = document.createElement('div');
  cell.className = 'cell x';
  cell.textContent = 'X';
  cell.addEventListener('click', function(e) {
    e.stopPropagation();
    const instrumentKey = this.closest('.instrument-block').querySelector('.instrument-select').value;
    openModal('melodic', ALL_NOTES, this, instrumentKey);
  });
  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'delete-column-btn';
  deleteBtn.textContent = 'üóëÔ∏è';
  deleteBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    deleteColumn(columnIndex);
  });
  column.appendChild(cell);
  column.appendChild(deleteBtn);
  parentGrid.appendChild(column);
}
// ===== FUN√á√ÉO PARA EXCLUIR COLUNA =====
function deleteColumn(columnIndex) {
  if (confirm('Tem certeza que deseja excluir esta coluna de todos os instrumentos?')) {
    // Remove coluna da Harmonia
    state.harmonyBlocks.forEach(block => {
      const grid = block.querySelector('.columns-grid');
      const column = grid.querySelector(`.column[data-column-index="${columnIndex}"]`);
      if (column) {
        grid.removeChild(column);
      }
    });
    // Remove coluna do Baixo, Melodia 1 e Melodia 2
    [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach(blocks => {
      blocks.forEach(block => {
        const grid = block.querySelector('.columns-grid');
        const column = grid.querySelector(`.column[data-column-index="${columnIndex}"]`);
        if (column) {
          grid.removeChild(column);
        }
      });
    });
    // Remove coluna da Bateria
    state.drumBlocks.forEach(block => {
      const drumGrid = block.querySelector('.drum-grid');
      DRUM_SAMPLES.forEach(drum => {
        const row = Array.from(drumGrid.children).find(r => r.querySelector('.drum-label')?.textContent === drum.label);
        if (row && row.children[columnIndex + 1]) { // +1 por causa do label
          row.removeChild(row.children[columnIndex + 1]);
        }
      });
    });
    // Atualiza o total de passos
    state.totalSteps -= 1;
    updateStatus(`Coluna exclu√≠da. Total: ${state.totalSteps} passos.`, 'ready');
  }
}
// ===== ADICIONAR COMPASSO EM TODOS OS INSTRUMENTOS =====
function addCompasso() {
  // Harmonia: +1 coluna (4 c√©lulas = 1 compasso)
  state.harmonyBlocks.forEach(block => {
    const grid = block.querySelector('.columns-grid');
    if (!grid) return;
    createHarmonyColumn(grid, grid.children.length);
  });
  // Baixo, Melodia 1, Melodia 2: +1 coluna cada (4 c√©lulas = 1 compasso)
  [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach(blocks => {
    blocks.forEach(block => {
      const grid = block.querySelector('.columns-grid');
      if (!grid) return;
      const type = block.querySelector('.columns-grid').dataset.type;
      createMelodicColumn(grid, type, grid.children.length);
    });
  });
  // BATERIA: ADICIONA 1 COLUNA POR PE√áA
  state.drumBlocks.forEach(block => {
    const drumGrid = block.querySelector('.drum-grid');
    if (!drumGrid) return;
    DRUM_SAMPLES.forEach(drum => {
      const row = Array.from(drumGrid.children).find(r => r.querySelector('.drum-label')?.textContent === drum.label);
      if (!row) return;
      const cell = document.createElement('div');
      cell.className = 'drum-cell';
      cell.dataset.step = row.children.length - 1;
      cell.dataset.instr = drum.key;
      cell.dataset.block = block.dataset.blockIndex;
      cell.addEventListener('click', function() {
        this.classList.toggle('active');
        loadSample('drum', drum.key, '');
      });
      row.appendChild(cell);
    });
  });
  state.totalSteps += 1;
  updateStatus(`Compasso adicionado. Total: ${state.totalSteps} passos.`, 'ready');
}
// ===== PLAYBACK =====
function buildPlaybackPlan() {
  const plan = {
    harmony: [],
    bass: [],
    melody1: [],
    melody2: [],
    drums: {}
  };
  DRUM_SAMPLES.forEach(d => plan.drums[d.key] = []);
  // Coleta todas as colunas da Harmonia
  state.harmonyBlocks.forEach(block => {
    const grid = block.querySelector('.columns-grid');
    const columns = grid.querySelectorAll('.column');
    const instrumentSelect = block.querySelector('.instrument-select');
    const instrument = instrumentSelect ? instrumentSelect.value : 'distorted-guitar';
    columns.forEach(column => {
      const cell = column.querySelector('.cell');
      if (cell.textContent !== 'X') {
        plan.harmony.push({
          chord: cell.textContent,
          instrument: instrument
        });
      } else {
        plan.harmony.push(null);
      }
    });
  });
  // Coleta todas as colunas dos instrumentos mel√≥dicos
  [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach((blocks, idx) => {
    const type = ['bass', 'melody1', 'melody2'][idx];
    blocks.forEach(block => {
      const grid = block.querySelector('.columns-grid');
      const columns = grid.querySelectorAll('.column');
      const instrumentSelect = block.querySelector('.instrument-select');
      const instrument = instrumentSelect ? instrumentSelect.value : 'piano';
      columns.forEach(column => {
        const cell = column.querySelector('.cell');
        if (cell.textContent === 'X') {
          plan[type].push(null);
        } else {
          plan[type].push({ note: cell.textContent, instrument: instrument });
        }
      });
    });
  });
  // Coleta as c√©lulas da bateria
  state.drumBlocks.forEach(block => {
    const drumGrid = block.querySelector('.drum-grid');
    DRUM_SAMPLES.forEach(drum => {
      const row = Array.from(drumGrid.children).find(r => r.querySelector('.drum-label')?.textContent === drum.label);
      if (!row) return;
      for (let i = 1; i < row.children.length; i++) { // Come√ßa em 1 para pular o label
        const cell = row.children[i];
        plan.drums[drum.key].push(cell.classList.contains('active'));
      }
    });
  });
  state.playbackPlan = plan;
  state.stepIndex = 0;
  state.lastNoteTime = 0;
  return plan;
}
function scheduleStep(time) {
  const idx = state.stepIndex;
  const plan = state.playbackPlan;
  if (!plan) return;
  // HARMONIA: MUTE ANTERIOR E TOCA NOVO
  if (idx < plan.harmony.length && plan.harmony[idx]) {
    const item = plan.harmony[idx];
    if (item && item.chord !== 'X') {
      if (state.currentlyPlaying.harmony !== null) {
        state.currentlyPlaying.harmony = null;
      }
      playChord(item.instrument, item.chord, time, state.harmonicGain, 1.0); // ‚Üê DURA√á√ÉO DE 1.0s (sem√≠nima)
      state.currentlyPlaying.harmony = item.chord;
    }
  }
  // BAIXO
  if (idx < plan.bass.length && plan.bass[idx]) {
    const item = plan.bass[idx];
    if (item && item.note) {
      if (state.currentlyPlaying.bass !== null) {
        state.currentlyPlaying.bass = null;
      }
      playNote(item.instrument, item.note, time, state.bassGain, 0.7);
      state.currentlyPlaying.bass = item.note;
    }
  }
  // MELODIA 1
  if (idx < plan.melody1.length && plan.melody1[idx]) {
    const item = plan.melody1[idx];
    if (item && item.note) {
      if (state.currentlyPlaying.melody1 !== null) {
        state.currentlyPlaying.melody1 = null;
      }
      playNote(item.instrument, item.note, time, state.melodyGain, 0.6);
      state.currentlyPlaying.melody1 = item.note;
    }
  }
  // MELODIA 2
  if (idx < plan.melody2.length && plan.melody2[idx]) {
    const item = plan.melody2[idx];
    if (item && item.note) {
      if (state.currentlyPlaying.melody2 !== null) {
        state.currentlyPlaying.melody2 = null;
      }
      playNote(item.instrument, item.note, time, state.melodyGain, 0.6);
      state.currentlyPlaying.melody2 = item.note;
    }
  }
  // BATERIA: N√ÉO MUTA ‚Äî PERMITE SOBREPOSI√á√ÉO NATURAL
  Object.keys(plan.drums).forEach(key => {
    if (idx < plan.drums[key].length && plan.drums[key][idx]) {
      playDrum(key, time, state.drumGain, 1.0); // ‚Üë Ganho aumentado
    }
  });
  state.stepIndex = (state.stepIndex + 1) % state.totalSteps;
}
function playNote(instrumentKey, note, time, gainNode, volume = 1.0) {
  if (!state.audioCtx) return;
  const bufferKey = `melodic-${instrumentKey}-${note}`;
  const buffer = state.buffers.melodic[bufferKey];
  if (!buffer) {
    console.warn(`Sample n√£o encontrado: ${instrumentKey}/${note}`);
    return;
  }
  const source = state.audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(gainNode);
  source.start(time);
  source.stop(time + 0.5); // Semicolcheia = 0.5s
}
function playChord(instrumentKey, chord, time, gainNode, volume = 1.0) {
  if (!state.audioCtx) return;
  if (chord === 'X') return;
  let root;
  if (chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(chord.slice(0, 2))) {
    root = chord.slice(0, 2);
  } else {
    root = chord[0];
  }
  // CORRE√á√ÉO FINAL: Monta o caminho exato do arquivo e usa como chave
  const filePath = HARMONIC_INSTRUMENTS[instrumentKey] + root + '/' + chord + '.mp3';
  const buffer = state.buffers.harmonic[filePath]; // ‚Üê BUSCA PELO CAMINHO COMPLETO
  if (!buffer) {
    console.warn(`Acorde n√£o encontrado: ${filePath}`);
    return;
  }
  const source = state.audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(gainNode);
  source.start(time);
  source.stop(time + 1.0); // Sem√≠nima = 1.0s
}
function playDrum(drumKey, time, gainNode, volume = 1.0) {
  if (!state.audioCtx) return;
  const buffer = state.buffers.drums[drumKey];
  if (!buffer) {
    console.warn(`Sample de bateria n√£o encontrado: ${drumKey}`);
    return;
  }
  const source = state.audioCtx.createBufferSource();
  source.buffer = buffer;
  const gain = state.audioCtx.createGain();
  gain.gain.setValueAtTime(volume, time);
  source.connect(gain);
  gain.connect(gainNode);
  source.start(time);
  // ‚ùå n√£o corta em 0.2s, deixa o sample tocar at√© o fim
}
function startScheduler() {
  state.isPlaying = true;
  ui.btnPlay.textContent = '‚è∏ Pause';
  ui.btnStop.disabled = false;
  function tick() {
    if (!state.isPlaying) return;
    const now = state.audioCtx.currentTime;
    const stepDuration = 60 / state.bpm / 4; // semicolcheia
    const nextStep = state.lastNoteTime + stepDuration;
    if (now >= nextStep) {
      scheduleStep(nextStep);
      state.lastNoteTime = nextStep;
    }
    requestAnimationFrame(tick);
  }
  state.lastNoteTime = state.audioCtx.currentTime;
  tick();
}
// ===== PLAY COM CONTAGEM REGRESSIVA DE 4 COMPASSOS =====
function onPlay() {
  if (!state.audioCtx) {
    updateStatus('Erro: Audio Context n√£o inicializado', 'error');
    return;
  }
  if (state.isPlaying) {
    state.isPlaying = false;
    ui.btnPlay.textContent = '‚ñ∂ Play';
    ui.btnStop.disabled = true;
    return;
  }
  try {
    if (state.audioCtx.state === 'suspended') {
      state.audioCtx.resume();
    }
    buildPlaybackPlan();
    const samplesToLoad = new Set();
    // Harmonia
    state.playbackPlan.harmony.forEach(item => {
      if (item && item.chord !== 'X') {
        let root;
        if (item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))) {
          root = item.chord.slice(0, 2);
        } else {
          root = item.chord[0];
        }
        const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
        samplesToLoad.add(filePath);
      }
    });
    // Mel√≥dicas
    ['bass', 'melody1', 'melody2'].forEach(type => {
      state.playbackPlan[type].forEach(item => {
        if (item && item.note) {
          const bufferKey = `melodic-${item.instrument}-${item.note}`;
          samplesToLoad.add(bufferKey);
        }
      });
    });
    // Bateria ‚Äî usa o key direto (ex: 'ataque'), sem prefixo
    Object.keys(state.playbackPlan.drums).forEach(key => {
      if (state.playbackPlan.drums[key].some(active => active)) {
        samplesToLoad.add(key);
      }
    });
    updateStatus('Carregando amostras... Por favor, aguarde.', 'loading');
    ui.btnSaveWAV.disabled = true;
    ui.countdown.style.display = 'block';
    const promises = Array.from(samplesToLoad).map(bufferKey => {
      if (bufferKey.includes('melodic-')) {
        const parts = bufferKey.split('-');
        const instrumentKey = parts[1];
        const noteOrChord = parts.slice(2).join('-');
        return loadSample('melodic', instrumentKey, noteOrChord);
      } else if (bufferKey.includes('guitarra') || bufferKey.includes('PianoStringChord')) {
        let instrumentKey = '';
        let chord = '';
        if (bufferKey.startsWith('guitarraDistorcao/')) {
          instrumentKey = 'distorted-guitar';
          chord = bufferKey.replace('guitarraDistorcao/', '').replace('.mp3', '').split('/').pop();
        } else if (bufferKey.startsWith('guitarraLimpa/')) {
          instrumentKey = 'clean-guitar';
          chord = bufferKey.replace('guitarraLimpa/', '').replace('.mp3', '').split('/').pop();
        } else if (bufferKey.startsWith('assets/PianoStringChord/')) {
          instrumentKey = 'piano-chord';
          chord = bufferKey.replace('assets/PianoStringChord/', '').replace('.mp3', '').split('/').pop();
        }
        if (instrumentKey && chord) {
          return loadSample('harmonic', instrumentKey, chord);
        } else {
          console.warn('Caminho de acorde inv√°lido:', bufferKey);
          return Promise.resolve();
        }
      } else {
        return loadSample('drum', bufferKey, '');
      }
    });
    Promise.all(promises).then(() => {
      startCountdown();
    }).catch(err => {
      console.error('Erro ao carregar amostras:', err);
      updateStatus('Erro ao carregar amostras. Verifique a conex√£o.', 'error');
    });
  } catch (error) {
    console.error('Erro ao iniciar reprodu√ß√£o:', error);
    updateStatus('Erro ao iniciar: ' + error.message, 'error');
  }
}
function startCountdown() {
  state.countdownActive = true;
  state.countdownValue = 4;
  ui.countdown.textContent = state.countdownValue;
  const sixteenthDur = 60 / state.bpm / 4;
  const beatDuration = sixteenthDur * 4;
  const interval = setInterval(() => {
    state.countdownValue--;
    ui.countdown.textContent = state.countdownValue;
    if (state.countdownValue <= 0) {
      clearInterval(interval);
      ui.countdown.style.display = 'none';
      state.countdownActive = false;
      startScheduler();
      updateStatus('Reproduzindo...', 'ready');
    }
  }, beatDuration * 1000);
}
function onStop() {
  state.isPlaying = false;
  state.stepIndex = 0;
  ui.btnPlay.textContent = '‚ñ∂ Play';
  ui.countdown.style.display = 'none';
  ui.btnStop.disabled = true;
  updateStatus('Reprodu√ß√£o parada', 'ready');
}
// ===== GRAVA√á√ÉO WAV COM BARRA DE PROGRESSO =====
async function renderAndDownloadWAV() {
  if (!state.playbackPlan) {
    alert('Crie alguma m√∫sica primeiro.');
    return;
  }
  updateStatus('Renderizando √°udio...', 'loading');
  ui.btnSaveWAV.disabled = true;
  ui.btnSaveWAV.textContent = '‚è≥ Renderizando...';
  ui.progressContainer.style.display = 'block';
  try {
    const sampleRate = 44100;
    // Calcula a dura√ß√£o total baseada no n√∫mero de passos
    const durationInSeconds = (state.totalSteps * 60) / (state.bpm * 4);
    const totalSamples = Math.ceil(durationInSeconds * sampleRate);
    const offlineCtx = new OfflineAudioContext(2, totalSamples, sampleRate);
    const master = offlineCtx.createGain();
    const drumGain = offlineCtx.createGain();
    const bassGain = offlineCtx.createGain();
    const melodyGain = offlineCtx.createGain();
    const harmonicGain = offlineCtx.createGain();
    master.connect(offlineCtx.destination);
    drumGain.connect(master);
    bassGain.connect(master);
    melodyGain.connect(master);
    harmonicGain.connect(master);
    master.gain.value = 0.8;
    drumGain.gain.value = 1.0;
    bassGain.gain.value = 0.5;
    melodyGain.gain.value = 0.5;
    harmonicGain.gain.value = 0.5;
    const sixteenthDur = 60 / state.bpm / 4;
    const totalSteps = state.totalSteps;
    // Fun√ß√£o para atualizar a barra de progresso
    const updateProgress = (currentStep) => {
      const percent = Math.round((currentStep / totalSteps) * 100);
      ui.progressBar.style.width = `${percent}%`;
      ui.progressText.textContent = `${percent}%`;
    };
    for (let step = 0; step < totalSteps; step++) {
      const time = step * sixteenthDur;
      // Atualiza a barra de progresso a cada 10 passos para melhor desempenho
      if (step % 10 === 0) {
        updateProgress(step);
      }
      // Harmonia
      if (step < state.playbackPlan.harmony.length && state.playbackPlan.harmony[step]) {
        const item = state.playbackPlan.harmony[step];
        if (item && item.chord !== 'X') {
          let root;
          if (item.chord.length >= 2 && ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2))) {
            root = item.chord.slice(0, 2);
          } else {
            root = item.chord[0];
          }
          const filePath = HARMONIC_INSTRUMENTS[item.instrument] + root + '/' + item.chord + '.mp3';
          const buffer = state.buffers.harmonic[filePath];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(harmonicGain);
            source.start(time);
            source.stop(time + 1.0);
          }
        }
      }
      // Baixo
      if (step < state.playbackPlan.bass.length && state.playbackPlan.bass[step]) {
        const item = state.playbackPlan.bass[step];
        if (item && item.note) {
          const bufferKey = `melodic-${item.instrument}-${item.note}`;
          const buffer = state.buffers.melodic[bufferKey];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(bassGain);
            source.start(time);
            source.stop(time + 0.5);
          }
        }
      }
      // Melodia 1 & 2
      [[state.playbackPlan.melody1, melodyGain], [state.playbackPlan.melody2, melodyGain]].forEach(([melody, gain]) => {
        if (step < melody.length && melody[step]) {
          const item = melody[step];
          if (item && item.note) {
            const bufferKey = `melodic-${item.instrument}-${item.note}`;
            const buffer = state.buffers.melodic[bufferKey];
            if (buffer) {
              const source = offlineCtx.createBufferSource();
              source.buffer = buffer;
              source.connect(gain);
              source.start(time);
              source.stop(time + 0.5);
            }
          }
        }
      });
      // Bateria
      Object.keys(state.playbackPlan.drums).forEach(key => {
        if (step < state.playbackPlan.drums[key].length && state.playbackPlan.drums[key][step]) {
          const buffer = state.buffers.drums[key];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(drumGain);
            source.start(time);
          }
        }
      });
    }
    // Atualiza progresso para 100% ao finalizar o loop
    updateProgress(totalSteps);
    const renderedBuffer = await offlineCtx.startRendering();
    const wavBlob = audioBufferToWav(renderedBuffer);
    const fileName = `jam-on-${new Date().toISOString().slice(0,10)}-${Math.floor(Math.random()*1000)}.wav`;
    downloadBlob(wavBlob, fileName);
    updateStatus('Renderiza√ß√£o conclu√≠da!', 'ready');
  } catch (error) {
    console.error('Erro ao renderizar WAV:', error);
    updateStatus('Erro ao renderizar: ' + error.message, 'error');
  } finally {
    ui.btnSaveWAV.textContent = 'üíæ Salvar como WAV';
    ui.btnSaveWAV.disabled = false;
    ui.progressContainer.style.display = 'none';
  }
}
function audioBufferToWav(buffer) {
  const numOfChan = buffer.numberOfChannels;
  const length = buffer.length * numOfChan * 2 + 44;
  const arrayBuffer = new ArrayBuffer(length);
  const view = new DataView(arrayBuffer);
  const channels = [];
  let i, sample, offset = 0;
  function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }
  writeString(view, 0, 'RIFF');
  view.setUint32(4, length - 8, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numOfChan, true);
  view.setUint32(24, 44100, true);
  view.setUint32(28, 44100 * 2 * numOfChan, true);
  view.setUint16(32, 2 * numOfChan, true);
  view.setUint16(34, 16, true);
  writeString(view, 36, 'data');
  view.setUint32(40, length - 44, true);
  for (i = 0; i < buffer.numberOfChannels; i++) {
    channels.push(buffer.getChannelData(i));
  }
  offset = 44;
  for (i = 0; i < buffer.length; i++) {
    for (let channel = 0; channel < numOfChan; channel++) {
      sample = Math.max(-1, Math.min(1, channels[channel][i]));
      sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF);
      view.setInt16(offset, sample, true);
      offset += 2;
    }
  }
  return new Blob([view], { type: 'audio/wav' });
}
function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.style.display = 'none';
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 100);
}
// ===== INICIALIZAR =====
window.addEventListener('load', initializeApp);
</script>
</body>
</html>
