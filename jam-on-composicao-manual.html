// ===== CONSTANTES =====
const AVAILABLE_CHORDS = [
  'A', 'A11', 'A13', 'A4', 'A45+', 'A5', 'A5+', 'A6', 'A7', 'A75+', 'A9', 'A95+', 'Adim', 
  'Am', 'Am4', 'Am5', 'Am5+', 'Am6', 'Am7', 'Am75+', 'Am79', 'Am9',
  'AS', 'AS11', 'AS13', 'AS4', 'AS45+', 'AS5', 'AS5+', 'AS6', 'AS7', 'AS75+', 'AS9', 'AS95+',
  'ASdim', 'ASm', 'ASm4', 'ASm5', 'ASm5+', 'ASm6', 'ASm7', 'ASm75+', 'ASm79', 'ASm9',
  'B', 'B11', 'B13', 'B4', 'B45+', 'B5', 'B5+', 'B6', 'B7', 'B75+', 'B9', 'B95+', 'Bdim',
  'Bm', 'Bm4', 'Bm5', 'Bm5+', 'Bm6', 'Bm7', 'Bm75+', 'Bm79', 'Bm9',
  'C', 'C11', 'C13', 'C4', 'C45+', 'C5', 'C5+', 'C6', 'C7', 'C75+', 'C9', 'C95+', 'Cdim',
  'Cm', 'Cm4', 'Cm5', 'Cm5+', 'Cm6', 'Cm7', 'Cm75+', 'Cm79', 'Cm9',
  'CS', 'CS11', 'CS13', 'CS4', 'CS45+', 'CS5', 'CS5+', 'CS6', 'CS7', 'CS75+', 'CS9', 'CS95+',
  'CSdim', 'CSm', 'CSm4', 'CSm5', 'CSm5+', 'CSm6', 'CSm7', 'CSm75+', 'CSm79', 'CSm9',
  'D', 'D11', 'D13', 'D4', 'D45+', 'D5', 'D5+', 'D6', 'D7', 'D75+', 'D9', 'D95+', 'Ddim',
  'Dm', 'Dm4', 'Dm5', 'Dm5+', 'Dm6', 'Dm7', 'Dm75+', 'Dm79', 'Dm9',
  'E', 'E11', 'E13', 'E4', 'E45+', 'E5', 'E5+', 'E6', 'E7', 'E75+', 'E9', 'E95+', 'Edim',
  'Em', 'Em4', 'Em5', 'Em5+', 'Em6', 'Em7', 'Em75+', 'Em79', 'Em9',
  'DS', 'DS11', 'DS13', 'DS4', 'DS45+', 'DS5', 'DS5+', 'DS6', 'DS7', 'DS75+', 'DS9', 'DS95+',
  'DSdim', 'DSm', 'DSm4', 'DSm5', 'DSm5+', 'DSm6', 'DSm7', 'DSm75+', 'DSm79', 'DSm9',
  'F', 'F11', 'F13', 'F4', 'F45+', 'F5', 'F5+', 'F6', 'F7', 'F75+', 'F9', 'F95+', 'Fdim',
  'Fm', 'Fm4', 'Fm5', 'Fm5+', 'Fm6', 'Fm7', 'Fm75+', 'Fm79', 'Fm9',
  'FS', 'FS11', 'FS13', 'FS4', 'FS45+', 'FS5', 'FS5+', 'FS6', 'FS7', 'FS75+', 'FS9', 'FS95+',
  'FSdim', 'FSm', 'FSm4', 'FSm5', 'FSm5+', 'FSm6', 'FSm7', 'FSm75+', 'FSm79', 'FSm9',
  'G', 'G11', 'G13', 'G4', 'G45+', 'G5', 'G5+', 'G6', 'G7', 'G75+', 'G9', 'G95+', 'Gdim',
  'Gm', 'Gm4', 'Gm5', 'Gm5+', 'Gm6', 'Gm7', 'Gm75+', 'Gm79', 'Gm9',
  'GS', 'GS11', 'GS13', 'GS4', 'GS45+', 'GS5', 'GS5+', 'GS6', 'GS7', 'GS75+', 'GS9', 'GS95+',
  'GSdim', 'GSm', 'GSm4', 'GSm5', 'GSm5+', 'GSm6', 'GSm7', 'GSm75+', 'GSm79', 'GSm9'
];
const NOTE_NAMES = [
  '10CS.mp3', '11D.mp3', '12DS.mp3', '13E.mp3', '14F.mp3', '15FS.mp3', '16G.mp3', '17GS.mp3', 
  '18A.mp3', '19AS.mp3', '1E.mp3', '20B.mp3', '21C.mp3', '22CS.mp3', '23D.mp3', '24DS.mp3', 
  '25E.mp3', '26F.mp3', '27FS.mp3', '28G.mp3', '29GS.mp3', '2F.mp3', '30A.mp3', '31AS.mp3', 
  '32B.mp3', '33C.mp3', '34CS.mp3', '35D.mp3', '36DS.mp3', '37E.mp3', '38F.mp3', '39FS.mp3', 
  '3FS.mp3', '40G.mp3', '41GS.mp3', '42A.mp3', '43AS.mp3', '44B.mp3', '45C.mp3', '46CS.mp3', 
  '47D.mp3', '48DS.mp3', '49E.mp3', '4G.mp3', '5GS.mp3', '6A.mp3', '7AS.mp3', '8B.mp3', '9C.mp3'
];
const ALL_NOTES = NOTE_NAMES.map(name => name.replace('.mp3', ''));
const NOTE_FREQ = {
  'C': 261.63, 'CS': 277.18, 'D': 293.66, 'DS': 311.13, 'E': 329.63, 'F': 349.23,
  'FS': 369.99, 'G': 392.00, 'GS': 415.30, 'A': 440.00, 'AS': 466.16, 'B': 493.88
};
const MELODIC_INSTRUMENTS = {
  'acordeon': 'assets/AcordeonMelodia/',
  'bass': 'assets/BaixoMelodia/',
  'strings': 'assets/Cordas/',
  'piano': 'assets/PianoString/',
  'sax': 'assets/SaxMelodia/',
  'acoustic-guitar': 'assets/ViolaoAcoMelodia/',
  'nylon-guitar': 'assets/ViolaoNylonMelodia/'
};
const HARMONIC_INSTRUMENTS = {
  'distorted-guitar': 'guitarraDistorcao/',
  'clean-guitar': 'guitarraLimpa/',
  'piano-chord': 'assets/PianoStringChord/'
};
const DRUM_SAMPLES = [
  { key: 'ataque', label: 'Caixa', path: 'assets/ataque.mp3' },
  { key: 'bumbo', label: 'Bumbo', path: 'assets/bumbo.mp3' },
  { key: 'chimbal', label: 'Chimbal Fechado', path: 'assets/chimbal.mp3' },
  { key: 'chimbal-aberto', label: 'Chimbal Aberto', path: 'assets/chimbal-aberto.mp3' },
  { key: 'conducao', label: 'Prato de Ataque', path: 'assets/conducao.mp3' },
  { key: 'surdo', label: 'Surdo', path: 'assets/surdo.mp3' },
  { key: 'tom-1', label: 'Tom 1', path: 'assets/tom-1.mp3' },
  { key: 'tom-2', label: 'Tom 2', path: 'assets/tom-2.mp3' }
];

// ===== ESTADO =====
const state = {
  running: false,
  paused: false,
  bpm: 100,
  stepIndex: 0,
  totalSteps: 4,
  buffers: {
    drums: {},
    melodic: {},
    harmonic: {}
  },
  activeInput: null,
  schedulerTimer: null,
  harmonyBlocks: [],
  bassBlocks: [],
  melody1Blocks: [],
  melody2Blocks: [],
  drumBlocks: [],
  lastNoteTime: 0,
  recordedChunks: [],
  audioCtx: null,
  isLoaded: false,
  isPlaying: false,
  isRendering: false,
  countdownActive: false,
  countdownValue: 4,
  currentlyPlaying: { 
    bass: null,
    melody1: null,
    melody2: null,
    harmony: null
  }
};

// ===== ELEMENTOS =====
const ui = {
  statusIndicator: document.getElementById('statusIndicator'),
  countdown: document.getElementById('countdown'),
  bpmSlider: document.getElementById('bpmSlider'),
  bpmDisplay: document.getElementById('bpmDisplay'),
  btnPlay: document.getElementById('btnPlay'),
  btnStop: document.getElementById('btnStop'),
  btnSaveWAV: document.getElementById('btnSaveWAV'),
  addCompassoBtn: document.getElementById('addCompassoBtn'),
  harmonyContainer: document.getElementById('harmonyContainer'),
  bassContainer: document.getElementById('bassContainer'),
  melody1Container: document.getElementById('melody1Container'),
  melody2Container: document.getElementById('melody2Container'),
  drumContainer: document.getElementById('drumContainer')
};

// ===== INICIALIZAÇÃO =====
async function initializeApp() {
  updateStatus('Inicializando... Aguarde.', 'loading');
  try {
    state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    state.masterGain = state.audioCtx.createGain();
    state.drumGain = state.audioCtx.createGain();
    state.bassGain = state.audioCtx.createGain();
    state.melodyGain = state.audioCtx.createGain();
    state.harmonicGain = state.audioCtx.createGain();
    state.masterGain.connect(state.audioCtx.destination);
    state.drumGain.connect(state.masterGain);
    state.bassGain.connect(state.masterGain);
    state.melodyGain.connect(state.masterGain);
    state.harmonicGain.connect(state.masterGain);
    state.masterGain.gain.value = 0.8;
    state.drumGain.gain.value = 0.6;
    state.bassGain.gain.value = 0.5;
    state.melodyGain.gain.value = 0.5;
    state.harmonicGain.gain.value = 0.5;

    setupEventListeners();

    // Inicia com 1 bloco de cada tipo
    addHarmonyBlock(); // 2 células
    addBassBlock();    // 4 células
    addMelody1Block(); // 4 células
    addMelody2Block(); // 4 células
    addDrumBlock();    // 4 células

    updateStatus('Pronto para compor. Clique em Play para iniciar com contagem de 4 compassos.', 'ready');
    ui.btnPlay.disabled = false;
    ui.btnSaveWAV.disabled = true; // Ainda não pode salvar até ter algo criado
    ui.btnStop.disabled = true;
  } catch (error) {
    console.error('Erro ao inicializar:', error);
    updateStatus('Erro ao inicializar: ' + error.message, 'error');
  }
}

function setupEventListeners() {
  updateBPMDisplay();
  ui.bpmSlider.addEventListener('input', handleBPMChange);
  ui.addCompassoBtn.addEventListener('click', addCompasso);
  ui.btnPlay.addEventListener('click', onPlay);
  ui.btnStop.addEventListener('click', onStop);
  ui.btnSaveWAV.addEventListener('click', () => renderAndDownloadWAV(16));
}

function handleBPMChange() {
  state.bpm = parseInt(ui.bpmSlider.value);
  updateBPMDisplay();
}

function updateBPMDisplay() {
  ui.bpmDisplay.textContent = `${state.bpm} BPM`;
}

function updateStatus(message, type) {
  ui.statusIndicator.textContent = message;
  ui.statusIndicator.className = 'status-indicator status-' + type;
}

// ===== CARREGAMENTO SOB DEMANDA (mantido, mas usado de forma proativa) =====
async function loadSample(instrumentType, key, noteOrChord) {
  let filePath;
  if (instrumentType === 'drum') {
    const sample = DRUM_SAMPLES.find(d => d.key === key);
    if (!sample) return;
    filePath = sample.path;
  } else if (instrumentType === 'melodic') {
    filePath = MELODIC_INSTRUMENTS[key] + noteOrChord + '.mp3';
  } else if (instrumentType === 'harmonic') {
    let root = ['AS','CS','DS','FS','GS'].includes(noteOrChord.slice(0, 2)) ? noteOrChord.slice(0, 2) : noteOrChord[0];
    filePath = HARMONIC_INSTRUMENTS[key] + root + '/' + noteOrChord + '.mp3';
  }
  if (!filePath) return;

  const bufferKey = `${instrumentType}-${key}-${noteOrChord}`;
  if (state.buffers[instrumentType === 'drum' ? 'drums' : instrumentType === 'melodic' ? 'melodic' : 'harmonic'][bufferKey]) {
    return;
  }

  try {
    const response = await fetch(filePath);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const arrayBuffer = await response.arrayBuffer();
    const buffer = await state.audioCtx.decodeAudioData(arrayBuffer);
    state.buffers[instrumentType === 'drum' ? 'drums' : instrumentType === 'melodic' ? 'melodic' : 'harmonic'][bufferKey] = buffer;
    console.log(`✅ Carregado: ${filePath}`);
  } catch (err) {
    console.warn(`⚠️ Não encontrado: ${filePath}`);
  }
}

// ===== BLOCOS DE INSTRUMENTOS =====
function addHarmonyBlock() {
  const blockIndex = state.harmonyBlocks.length;
  const block = document.createElement('div');
  block.className = 'instrument-block harmony-block';
  block.dataset.blockIndex = blockIndex;
  const title = document.createElement('div');
  title.textContent = `Bloco ${blockIndex + 1}`;
  title.style.fontWeight = 'bold';
  title.style.color = '#9b59b6';
  title.style.marginBottom = '10px';
  block.appendChild(title);
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.innerHTML = `
    <option value="distorted-guitar">Guitarra Distorcida</option>
    <option value="clean-guitar">Guitarra Limpa</option>
    <option value="piano-chord">Piano</option>
  `;
  block.appendChild(instrumentSelect);
  const grid = document.createElement('div');
  grid.className = 'note-grid';
  grid.dataset.type = 'harmony';
  grid.dataset.blockIndex = blockIndex;
  for (let i = 0; i < 2; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.step = i;
    cell.textContent = 'C';
    cell.addEventListener('click', function() {
      const currentIndex = AVAILABLE_CHORDS.indexOf(this.textContent);
      const nextIndex = (currentIndex + 1) % AVAILABLE_CHORDS.length;
      this.textContent = AVAILABLE_CHORDS[nextIndex];
      if (state.currentlyPlaying.harmony !== null) {
        state.currentlyPlaying.harmony = null;
      }
    });
    cell.addEventListener('dblclick', function() {
      if (this.textContent === 'X') {
        this.textContent = 'C';
        this.classList.remove('x');
      } else {
        this.textContent = 'X';
        this.classList.add('x');
      }
    });
    grid.appendChild(cell);
  }
  block.appendChild(grid);
  ui.harmonyContainer.appendChild(block);
  state.harmonyBlocks.push(block);
  return block;
}

function addBassBlock() {
  const blockIndex = state.bassBlocks.length;
  const block = document.createElement('div');
  block.className = 'instrument-block bass-block';
  block.dataset.blockIndex = blockIndex;
  const title = document.createElement('div');
  title.textContent = `Bloco ${blockIndex + 1}`;
  title.style.fontWeight = 'bold';
  title.style.color = '#ffcc00';
  title.style.marginBottom = '10px';
  block.appendChild(title);
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.innerHTML = `
    <option value="bass">Baixo</option>
    <option value="acoustic-guitar">Violão Aço</option>
    <option value="nylon-guitar">Violão Nylon</option>
    <option value="strings">Cordas</option>
  `;
  block.appendChild(instrumentSelect);
  const grid = createNoteGrid('bass', blockIndex, 4);
  block.appendChild(grid);
  ui.bassContainer.appendChild(block);
  state.bassBlocks.push(block);
  return block;
}

function addMelody1Block() {
  const blockIndex = state.melody1Blocks.length;
  const block = document.createElement('div');
  block.className = 'instrument-block melody1-block';
  block.dataset.blockIndex = blockIndex;
  const title = document.createElement('div');
  title.textContent = `Bloco ${blockIndex + 1}`;
  title.style.fontWeight = 'bold';
  title.style.color = '#ff6b6b';
  title.style.marginBottom = '10px';
  block.appendChild(title);
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.innerHTML = `
    <option value="piano">Piano</option>
    <option value="sax">Saxofone</option>
    <option value="acordeon">Acordeon</option>
    <option value="strings">Cordas</option>
    <option value="acoustic-guitar">Violão Aço</option>
    <option value="nylon-guitar">Violão Nylon</option>
  `;
  block.appendChild(instrumentSelect);
  const grid = createNoteGrid('melody1', blockIndex, 4);
  block.appendChild(grid);
  ui.melody1Container.appendChild(block);
  state.melody1Blocks.push(block);
  return block;
}

function addMelody2Block() {
  const blockIndex = state.melody2Blocks.length;
  const block = document.createElement('div');
  block.className = 'instrument-block melody2-block';
  block.dataset.blockIndex = blockIndex;
  const title = document.createElement('div');
  title.textContent = `Bloco ${blockIndex + 1}`;
  title.style.fontWeight = 'bold';
  title.style.color = '#4ecdc4';
  title.style.marginBottom = '10px';
  block.appendChild(title);
  const instrumentSelect = document.createElement('select');
  instrumentSelect.className = 'instrument-select';
  instrumentSelect.innerHTML = `
    <option value="sax">Saxofone</option>
    <option value="piano">Piano</option>
    <option value="acordeon">Acordeon</option>
    <option value="strings">Cordas</option>
    <option value="acoustic-guitar">Violão Aço</option>
    <option value="nylon-guitar">Violão Nylon</option>
  `;
  block.appendChild(instrumentSelect);
  const grid = createNoteGrid('melody2', blockIndex, 4);
  block.appendChild(grid);
  ui.melody2Container.appendChild(block);
  state.melody2Blocks.push(block);
  return block;
}

function addDrumBlock() {
  const blockIndex = state.drumBlocks.length;
  const block = document.createElement('div');
  block.className = 'instrument-block drum-block';
  block.dataset.blockIndex = blockIndex;
  const title = document.createElement('div');
  title.textContent = `Bloco ${blockIndex + 1}`;
  title.style.fontWeight = 'bold';
  title.style.color = '#8e44ad';
  title.style.marginBottom = '10px';
  block.appendChild(title);
  const drumGrid = document.createElement('div');
  drumGrid.className = 'drum-grid';
  DRUM_SAMPLES.forEach(drum => {
    const row = document.createElement('div');
    row.className = 'drum-row';
    const label = document.createElement('div');
    label.className = 'drum-label';
    label.textContent = drum.label;
    row.appendChild(label);
    for (let i = 0; i < 4; i++) {
      const cell = document.createElement('div');
      cell.className = 'drum-cell';
      cell.dataset.step = i;
      cell.dataset.instr = drum.key;
      cell.dataset.block = blockIndex;
      cell.addEventListener('click', function() {
        this.classList.toggle('active');
      });
      row.appendChild(cell);
    }
    drumGrid.appendChild(row);
  });
  block.appendChild(drumGrid);
  ui.drumContainer.appendChild(block);
  state.drumBlocks.push(block);
  return block;
}

function createNoteGrid(type, blockIndex, numCells) {
  const grid = document.createElement('div');
  grid.className = 'note-grid';
  grid.dataset.type = type;
  grid.dataset.blockIndex = blockIndex;
  for (let i = 0; i < numCells; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.step = i;
    cell.textContent = ALL_NOTES[0];
    cell.addEventListener('click', function(e) {
      const rect = this.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const centerX = rect.width / 2;
      let currentText = this.textContent;
      let currentIndex = ALL_NOTES.indexOf(currentText);
      if (clickX < centerX) {
        currentIndex = (currentIndex - 1 + ALL_NOTES.length) % ALL_NOTES.length;
      } else {
        currentIndex = (currentIndex + 1) % ALL_NOTES.length;
      }
      const newNote = ALL_NOTES[currentIndex];
      this.textContent = newNote;
      const instrument = this.parentElement.parentElement.querySelector('.instrument-select').value;
      const category = type.replace('Block', '').toLowerCase();
      if (state.currentlyPlaying[category] !== null) {
        state.currentlyPlaying[category] = null;
      }
    });
    cell.addEventListener('dblclick', function() {
      if (this.textContent === 'X') {
        this.textContent = ALL_NOTES[0];
        this.classList.remove('x');
      } else {
        this.textContent = 'X';
        this.classList.add('x');
      }
    });
    grid.appendChild(cell);
  }
  return grid;
}

// ===== ADICIONAR COMPASSO EM TODOS OS INSTRUMENTOS =====
function addCompasso() {
  state.harmonyBlocks.forEach(block => {
    const grid = block.querySelector('.note-grid');
    if (!grid) return;
    for (let i = 0; i < 2; i++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.step = grid.children.length;
      cell.textContent = 'C';
      cell.addEventListener('click', function() {
        const currentIndex = AVAILABLE_CHORDS.indexOf(this.textContent);
        const nextIndex = (currentIndex + 1) % AVAILABLE_CHORDS.length;
        this.textContent = AVAILABLE_CHORDS[nextIndex];
        if (state.currentlyPlaying.harmony !== null) {
          state.currentlyPlaying.harmony = null;
        }
      });
      cell.addEventListener('dblclick', function() {
        if (this.textContent === 'X') {
          this.textContent = 'C';
          this.classList.remove('x');
        } else {
          this.textContent = 'X';
          this.classList.add('x');
        }
      });
      grid.appendChild(cell);
    }
  });

  [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach(blocks => {
    blocks.forEach(block => {
      const grid = block.querySelector('.note-grid');
      if (!grid) return;
      for (let i = 0; i < 4; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.step = grid.children.length;
        cell.textContent = ALL_NOTES[0];
        cell.addEventListener('click', function(e) {
          const rect = this.getBoundingClientRect();
          const clickX = e.clientX - rect.left;
          const centerX = rect.width / 2;
          let currentText = this.textContent;
          let currentIndex = ALL_NOTES.indexOf(currentText);
          if (clickX < centerX) {
            currentIndex = (currentIndex - 1 + ALL_NOTES.length) % ALL_NOTES.length;
          } else {
            currentIndex = (currentIndex + 1) % ALL_NOTES.length;
          }
          const newNote = ALL_NOTES[currentIndex];
          this.textContent = newNote;
          const instrument = this.parentElement.parentElement.querySelector('.instrument-select').value;
          const category = 'bass'; // ou 'melody1'/'melody2'
          if (state.currentlyPlaying[category] !== null) {
            state.currentlyPlaying[category] = null;
          }
        });
        cell.addEventListener('dblclick', function() {
          if (this.textContent === 'X') {
            this.textContent = ALL_NOTES[0];
            this.classList.remove('x');
          } else {
            this.textContent = 'X';
            this.classList.add('x');
          }
        });
        grid.appendChild(cell);
      }
    });
  });

  state.drumBlocks.forEach(block => {
    const drumGrid = block.querySelector('.drum-grid');
    if (!drumGrid) return;
    DRUM_SAMPLES.forEach(drum => {
      const row = Array.from(drumGrid.children).find(r => r.querySelector('.drum-label')?.textContent === drum.label);
      if (!row) return;
      for (let i = 0; i < 4; i++) {
        const cell = document.createElement('div');
        cell.className = 'drum-cell';
        cell.dataset.step = row.children.length - 1;
        cell.dataset.instr = drum.key;
        cell.dataset.block = block.dataset.blockIndex;
        cell.addEventListener('click', function() {
          this.classList.toggle('active');
        });
        row.appendChild(cell);
      }
    });
  });

  state.totalSteps += 4;
  updateStatus(`Compasso adicionado. Total: ${state.totalSteps} passos.`, 'ready');
}

// ===== NOVA LÓGICA: CONTAGEM REGRESSIVA DE 4 COMPASSOS AO TOCAR =====
function startCountdown() {
  state.countdownActive = true;
  state.countdownValue = 4;
  ui.countdown.textContent = state.countdownValue;
  ui.countdown.style.display = 'block';

  const sixteenthDur = 60 / state.bpm / 4; // duração de uma semicolcheia
  const beatDuration = sixteenthDur * 4;   // duração de um compasso (4 semicolcheias)
  const totalDuration = beatDuration * 4;  // 4 compassos

  let remaining = state.countdownValue;
  const interval = setInterval(() => {
    remaining--;
    ui.countdown.textContent = remaining;
    if (remaining <= 0) {
      clearInterval(interval);
      ui.countdown.style.display = 'none';
      state.countdownActive = false;
      startPlayback(); // Inicia a reprodução real após a contagem
    }
  }, beatDuration * 1000); // Converte segundos para ms
}

function startPlayback() {
  state.isPlaying = true;
  ui.btnPlay.textContent = '⏸ Pause';
  updateStatus('Reproduzindo...', 'ready');

  function tick() {
    if (!state.isPlaying) return;
    const now = state.audioCtx.currentTime;
    const stepDuration = 60 / state.bpm / 4;
    const nextStep = state.lastNoteTime + stepDuration;
    if (now >= nextStep) {
      scheduleStep(nextStep);
      state.lastNoteTime = nextStep;
    }
    requestAnimationFrame(tick);
  }

  state.lastNoteTime = state.audioCtx.currentTime;
  tick();
}

function buildPlaybackPlan() {
  const plan = {
    harmony: [],
    bass: [],
    melody1: [],
    melody2: [],
    drums: {}
  };
  DRUM_SAMPLES.forEach(d => plan.drums[d.key] = []);

  // Coleta todas as notas e acordes usados nos blocos
  state.harmonyBlocks.forEach(block => {
    const grid = block.querySelector('.note-grid');
    const cells = grid.querySelectorAll('.cell');
    const instrument = block.querySelector('.instrument-select').value;
    cells.forEach(cell => {
      plan.harmony.push({
        chord: cell.textContent,
        instrument: instrument
      });
    });
  });

  [state.bassBlocks, state.melody1Blocks, state.melody2Blocks].forEach((blocks, idx) => {
    const type = ['bass', 'melody1', 'melody2'][idx];
    blocks.forEach(block => {
      const grid = block.querySelector('.note-grid');
      const cells = grid.querySelectorAll('.cell');
      const instrument = block.querySelector('.instrument-select').value;
      cells.forEach(cell => {
        const val = cell.textContent;
        if (val === 'X') {
          plan[type].push(null);
        } else {
          plan[type].push({ note: val, instrument: instrument });
        }
      });
    });
  });

  state.drumBlocks.forEach(block => {
    DRUM_SAMPLES.forEach(drum => {
      const cells = block.querySelectorAll(`.drum-cell[data-instr="${drum.key}"]`);
      cells.forEach(cell => {
        plan.drums[drum.key].push(cell.classList.contains('active'));
      });
    });
  });

  state.playbackPlan = plan;
  state.stepIndex = 0;
  state.lastNoteTime = 0;
  return plan;
}

// ===== FUNÇÃO CHAVE: CARREGAR TODOS OS SAMPLES USADOS NA PRÓXIMA REPRODUÇÃO =====
async function preloadAllSamplesForPlayback() {
  updateStatus('Carregando amostras... Por favor, aguarde.', 'loading');
  ui.btnSaveWAV.disabled = true;

  const plan = buildPlaybackPlan();
  const promises = [];

  // Carregar acordes da harmonia
  plan.harmony.forEach(item => {
    if (item && item.chord !== 'X' && item.chord !== 'C') {
      const key = item.instrument;
      const chord = item.chord;
      promises.push(loadSample('harmonic', key, chord));
    }
  });

  // Carregar notas da baixa, melodia 1 e 2
  ['bass', 'melody1', 'melody2'].forEach(type => {
    plan[type].forEach(item => {
      if (item && item.note) {
        const key = item.instrument;
        const note = item.note;
        promises.push(loadSample('melodic', key, note));
      }
    });
  });

  // Carregar samples de bateria ativos
  Object.keys(plan.drums).forEach(key => {
    if (plan.drums[key].some(active => active)) {
      promises.push(loadSample('drum', key, ''));
    }
  });

  // Espera todos os carregamentos
  await Promise.all(promises);

  updateStatus('Amostras carregadas! Iniciando contagem regressiva...', 'ready');
  ui.btnSaveWAV.disabled = false;
}

function onPlay() {
  if (!state.audioCtx) {
    updateStatus('Erro: Audio Context não inicializado', 'error');
    return;
  }

  if (state.isPlaying) {
    state.isPlaying = false;
    ui.btnPlay.textContent = '▶ Play';
    return;
  }

  try {
    if (state.audioCtx.state === 'suspended') {
      state.audioCtx.resume();
    }

    // Passo 1: Carregar todos os samples usados na composição atual
    preloadAllSamplesForPlayback().then(() => {
      // Passo 2: Iniciar contagem regressiva de 4 compassos
      startCountdown();
    }).catch(err => {
      console.error('Erro ao carregar amostras:', err);
      updateStatus('Erro ao carregar amostras. Verifique a conexão.', 'error');
    });

  } catch (error) {
    console.error('Erro ao iniciar reprodução:', error);
    updateStatus('Erro ao iniciar: ' + error.message, 'error');
  }
}

function onStop() {
  state.isPlaying = false;
  state.stepIndex = 0;
  ui.btnPlay.textContent = '▶ Play';
  ui.countdown.style.display = 'none';
  updateStatus('Reprodução parada', 'ready');
}

// ===== GRAVAÇÃO WAV =====
async function renderAndDownloadWAV(durationInSeconds) {
  if (!state.isLoaded && !state.preparing) {
    alert('Clique em Play para gerar os sons primeiro.');
    return;
  }
  updateStatus('Renderizando áudio...', 'loading');
  ui.btnSaveWAV.disabled = true;
  ui.btnSaveWAV.textContent = '⏳ Renderizando...';

  try {
    const sampleRate = 44100;
    const totalSamples = Math.ceil(durationInSeconds * sampleRate);
    const offlineCtx = new OfflineAudioContext(2, totalSamples, sampleRate);
    const master = offlineCtx.createGain();
    const drumGain = offlineCtx.createGain();
    const bassGain = offlineCtx.createGain();
    const melodyGain = offlineCtx.createGain();
    const harmonicGain = offlineCtx.createGain();
    master.connect(offlineCtx.destination);
    drumGain.connect(master);
    bassGain.connect(master);
    melodyGain.connect(master);
    harmonicGain.connect(master);
    master.gain.value = 0.8;
    drumGain.gain.value = 0.6;
    bassGain.gain.value = 0.5;
    melodyGain.gain.value = 0.5;
    harmonicGain.gain.value = 0.5;

    buildPlaybackPlan();
    const sixteenthDur = 60 / state.bpm / 4;
    const totalSteps = Math.min(state.totalSteps, Math.ceil(durationInSeconds / sixteenthDur));

    for (let step = 0; step < totalSteps; step++) {
      const time = step * sixteenthDur;

      if (step < state.playbackPlan.harmony.length) {
        const item = state.playbackPlan.harmony[step];
        if (item && item.chord !== 'X' && item.chord !== 'C') {
          let root = ['AS','CS','DS','FS','GS'].includes(item.chord.slice(0, 2)) ? item.chord.slice(0, 2) : item.chord[0];
          const bufferKey = `harmonic-${item.instrument}-${item.chord}`;
          const buffer = state.buffers.harmonic[bufferKey];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(harmonicGain);
            source.start(time);
            source.stop(time + 0.8);
          }
        }
      }

      if (step < state.playbackPlan.bass.length) {
        const item = state.playbackPlan.bass[step];
        if (item && item.note) {
          const bufferKey = `melodic-${item.instrument}-${item.note}`;
          const buffer = state.buffers.melodic[bufferKey];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(bassGain);
            source.start(time);
            source.stop(time + 0.5);
          }
        }
      }

      [[state.playbackPlan.melody1, melodyGain], [state.playbackPlan.melody2, melodyGain]].forEach(([melody, gain]) => {
        if (step < melody.length) {
          const item = melody[step];
          if (item && item.note) {
            const bufferKey = `melodic-${item.instrument}-${item.note}`;
            const buffer = state.buffers.melodic[bufferKey];
            if (buffer) {
              const source = offlineCtx.createBufferSource();
              source.buffer = buffer;
              source.connect(gain);
              source.start(time);
              source.stop(time + 0.5);
            }
          }
        }
      });

      Object.keys(state.playbackPlan.drums).forEach(key => {
        if (step < state.playbackPlan.drums[key].length && state.playbackPlan.drums[key][step]) {
          const buffer = state.buffers.drums[key];
          if (buffer) {
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(drumGain);
            source.start(time);
            source.stop(time + 0.2);
          }
        }
      });
    }

    const renderedBuffer = await offlineCtx.startRendering();
    const wavBlob = audioBufferToWav(renderedBuffer);
    const fileName = `jam-on-${new Date().toISOString().slice(0,10)}-${Math.floor(Math.random()*1000)}.wav`;
    downloadBlob(wavBlob, fileName);
    updateStatus('Renderização concluída!', 'ready');
  } catch (error) {
    console.error('Erro ao renderizar WAV:', error);
    updateStatus('Erro ao renderizar: ' + error.message, 'error');
  }
  ui.btnSaveWAV.textContent = '💾 Salvar como WAV';
  ui.btnSaveWAV.disabled = false;
}

function audioBufferToWav(buffer) {
  const numOfChan = buffer.numberOfChannels;
  const length = buffer.length * numOfChan * 2 + 44;
  const arrayBuffer = new ArrayBuffer(length);
  const view = new DataView(arrayBuffer);
  const channels = [];
  let i, sample, offset = 0;
  function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }
  writeString(view, 0, 'RIFF');
  view.setUint32(4, length - 8, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numOfChan, true);
  view.setUint32(24, 44100, true);
  view.setUint32(28, 44100 * 2 * numOfChan, true);
  view.setUint16(32, 2 * numOfChan, true);
  view.setUint16(34, 16, true);
  writeString(view, 36, 'data');
  view.setUint32(40, length - 44, true);
  for (i = 0; i < buffer.numberOfChannels; i++) {
    channels.push(buffer.getChannelData(i));
  }
  offset = 44;
  for (i = 0; i < buffer.length; i++) {
    for (let channel = 0; channel < numOfChan; channel++) {
      sample = Math.max(-1, Math.min(1, channels[channel][i]));
      sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF);
      view.setInt16(offset, sample, true);
      offset += 2;
    }
  }
  return new Blob([view], { type: 'audio/wav' });
}

function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.style.display = 'none';
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 100);
}

// ===== INICIALIZAR =====
window.addEventListener('load', initializeApp);
