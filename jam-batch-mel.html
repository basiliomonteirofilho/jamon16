<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jam Batch ‚Äì Gerador de Dataset</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #121212;
      color: #e0e0e0;
      margin: 0;
      padding: 20px;
      text-align: center;
    }
    h1 {
      color: #5eead4;
      margin-bottom: 20px;
    }
    .card {
      max-width: 600px;
      margin: 0 auto;
      background: #1e1e1e;
      border-radius: 16px;
      padding: 25px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    .btn-group {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
      margin: 20px 0;
    }
    button {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      background: #5eead4;
      color: #121212;
      font-size: 1em;
    }
    button:hover:not(:disabled) {
      opacity: 0.9;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .status {
      margin-top: 20px;
      padding: 12px;
      border-radius: 8px;
      background: #2a2a2a;
      font-family: monospace;
    }
    .instructions {
      color: #aaa;
      font-size: 0.9em;
      margin-top: 15px;
    }
  </style>
</head>
<body>
  <h1>üéµ Jam Batch ‚Äì Gerador de Dataset Musical</h1>
  <div class="card">
    <p>Este gerador usa a l√≥gica completa do Jam On para criar m√∫sicas variadas.</p>
    <p>Cada m√∫sica tem <strong>30 segundos</strong>, com metadados em JSON.</p>

    <div class="btn-group">
      <button data-count="5">Gerar 5 m√∫sicas</button>
      <button data-count="10">Gerar 10 m√∫sicas</button>
      <button data-count="100">Gerar 100 m√∫sicas</button>
      <button data-count="500">Gerar 500 m√∫sicas</button>
      <button data-count="1000">Gerar 1000 m√∫sicas</button>
    </div>

    <div class="instructions">
      ‚ö†Ô∏è Seu navegador deve estar configurado para <strong>"Perguntar onde salvar arquivos"</strong> (recomendado).
    </div>

    <div class="status" id="status">Pronto para gerar.</div>
  </div>

  <script>
    // === COPIA DAS CONSTANTES E L√ìGICAS DO SEU JAM ON ===
    const PITCHES = ['A','AS','B','C','CS','D','DS','E','F','FS','G','GS'];
    const DEGREE_TO_ROOT = { 1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11 };
    const CHORD_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    const STYLE_PROGRESSIONS = {
      Rock: [[1,4,5,1], [1,5,6,4]],
      Blues: [[1,4,5,1]],
      Samba: [[2,5,1,1]],
      Metal: [[1,3,5,6]],
      Jazz: [[2,5,1,4]]
    };
    const ALL_GROOVES = [
      { name: "Rock", meter: "4/4", bassScale: [1,3,5,8] },
      { name: "Blues", meter: "4/4", bassScale: [1,3,5,6,8] },
      { name: "Samba", meter: "2/4", bassScale: [8,5] },
      { name: "Metal", meter: "4/4", bassScale: [1,3,5,8] },
      { name: "Jazz", meter: "4/4", bassScale: "chromatic" }
    ];

    function meterToBeats(meter) {
      return Number(meter.split('/')[0]) || 4;
    }

    function randomChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function buildBassAndChordPlan(bpm, meter, key, quality, durationSec = 30) {
      const sixteenthDur = 60 / bpm / 4;
      const beats = meterToBeats(meter);
      const stepsPerBar = beats * 4;
      const totalSteps = Math.ceil(durationSec / sixteenthDur);

      // Escolhe groove
      const groove = randomChoice(ALL_GROOVES);
      const styleKey = groove.name.split('_')[0].replace(/\d+/g, '');
      const progressions = STYLE_PROGRESSIONS[styleKey] || STYLE_PROGRESSIONS.Rock;
      const prog = randomChoice(progressions);
      const chordPlan = prog.map(degree => {
        const rootIdx = (PITCHES.indexOf(key) + DEGREE_TO_ROOT[degree]) % 12;
        const rootNote = PITCHES[rootIdx];
        let type = '';
        if (degree === 7) type = 'dim';
        else if ([2,3,6].includes(degree) && quality === 'maj') type = 'm';
        return { note: rootNote, type, display: CHORD_NAMES[rootIdx] + type, rootNote: CHORD_NAMES[rootIdx] };
      });

      // Monta plano de baixo (simplificado)
      const bassPlan = [];
      for (let step = 0; step < totalSteps; step++) {
        const bar = Math.floor(step / stepsPerBar);
        const chord = chordPlan[bar % chordPlan.length];
        const rootIdx = PITCHES.indexOf(chord.note);
        const scale = groove.bassScale === "chromatic"
          ? Array(12).fill().map((_, i) => PITCHES[(rootIdx + i) % 12])
          : groove.bassScale.map(i => {
              const offset = quality === 'min' && ![1,4,5].includes(prog[bar % prog.length])
                ? {1:0,2:2,3:3,4:5,5:7,6:8,7:10,8:12}[i] || 0
                : {1:0,2:2,3:4,4:5,5:7,6:9,7:11,8:12}[i] || 0;
              return PITCHES[(rootIdx + offset) % 12];
            });
        const note = scale[Math.floor(step / stepsPerBar) % scale.length];
        bassPlan.push(note);
      }

      return { chordPlan, bassPlan, groove, sixteenthDur, stepsPerBar, totalSteps };
    }

    function generateMetadata(bpm, meter, key, quality, chordPlan, sixteenthDur, stepsPerBar, durationSec = 30) {
      const chords = [];
      const totalSteps = Math.ceil(durationSec / sixteenthDur);
      for (let step = 0; step < totalSteps; step++) {
        const bar = Math.floor(step / stepsPerBar);
        const chord = chordPlan[bar % chordPlan.length];
        const start = step * sixteenthDur;
        const end = start + sixteenthDur;
        if (end > durationSec) break;
        chords.push({
          start: parseFloat(start.toFixed(3)),
          end: parseFloat(end.toFixed(3)),
          chord: chord.display,
          root: chord.rootNote,
          quality: chord.type || 'maj',
          bar,
          step
        });
      }
      return { bpm, meter, key: CHORD_NAMES[PITCHES.indexOf(key)], quality, style: chordPlan[0]?.display?.includes('m') ? 'Minor' : 'Major', duration: durationSec, chords };
    }

    // === FUN√á√ïES DE √ÅUDIO ===
    function audioBufferToWav(buffer) {
      const numOfChan = buffer.numberOfChannels;
      const length = buffer.length * numOfChan * 2 + 44;
      const arrayBuffer = new ArrayBuffer(length);
      const view = new DataView(arrayBuffer);
      function writeString(offset, str) {
        for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
      }
      writeString(0, 'RIFF');
      view.setUint32(4, length - 8, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numOfChan, true);
      view.setUint32(24, 44100, true);
      view.setUint32(28, 44100 * 2 * numOfChan, true);
      view.setUint16(32, 2 * numOfChan, true);
      view.setUint16(34, 16, true);
      writeString(36, 'data');
      view.setUint32(40, length - 44, true);
      const channels = [];
      for (let i = 0; i < numOfChan; i++) channels.push(buffer.getChannelData(i));
      let offset = 44;
      for (let i = 0; i < buffer.length; i++) {
        for (let ch = 0; ch < numOfChan; ch++) {
          const sample = Math.max(-1, Math.min(1, channels[ch][i]));
          const int16 = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
          view.setInt16(offset, int16, true);
          offset += 2;
        }
      }
      return new Blob([view], { type: 'audio/wav' });
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    async function renderOneMusic(index, durationSec = 30) {
      const bpm = Math.floor(Math.random() * 100) + 70;
      const groove = randomChoice(ALL_GROOVES);
      const meter = groove.meter;
      const key = randomChoice(PITCHES);
      const quality = Math.random() > 0.5 ? 'maj' : 'min';

      const { chordPlan, bassPlan, sixteenthDur, stepsPerBar, totalSteps } = buildBassAndChordPlan(bpm, meter, key, quality, durationSec);
      const metadata = generateMetadata(bpm, meter, key, quality, chordPlan, sixteenthDur, stepsPerBar, durationSec);

      // Render offline
      const sampleRate = 44100;
      const offlineCtx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(2, Math.ceil(durationSec * sampleRate), sampleRate);

      // Ganho master
      const master = offlineCtx.createGain();
      master.gain.value = 0.8;
      master.connect(offlineCtx.destination);

      // Instrumentos (todos ativos)
      const gains = {};
      ['bass', 'drums', 'clean', 'dist', 'piano', 'echo', 'cleanPicked', 'organ', 'melody'].forEach(name => {
        gains[name] = offlineCtx.createGain();
        gains[name].gain.value = 0.5;
        gains[name].connect(master);
      });

      // Simula√ß√£o de samples (substitua por loadBuffer() se quiser usar seus arquivos reais)
      function playDummy(time, duration, freq, gainNode) {
        if (time >= durationSec) return;
        const osc = offlineCtx.createOscillator();
        const g = offlineCtx.createGain();
        osc.type = 'sine';
        osc.frequency.value = freq;
        osc.connect(g);
        g.connect(gainNode);
        g.gain.setValueAtTime(0.2, time);
        g.gain.exponentialRampToValueAtTime(0.001, time + Math.min(duration, 0.5));
        osc.start(time);
        osc.stop(time + Math.min(duration, 0.5));
      }

      // Agenda eventos
      const lastSources = { bass: null, clean: null, dist: null, piano: null, echo: null, cleanPicked: null, organ: null, melody: null };
      function scheduleNote(time, duration, freq, gainNode, instrumentKey) {
        if (lastSources[instrumentKey]) {
          try { lastSources[instrumentKey].stop(time); } catch (e) {}
        }
        const osc = offlineCtx.createOscillator();
        const g = offlineCtx.createGain();
        osc.frequency.value = freq;
        osc.connect(g);
        g.connect(gainNode);
        g.gain.setValueAtTime(0.2, time);
        g.gain.exponentialRampToValueAtTime(0.001, time + Math.min(duration, 0.5));
        osc.start(time);
        osc.stop(time + Math.min(duration, 0.5));
        lastSources[instrumentKey] = osc;
      }

      for (let step = 0; step < totalSteps; step++) {
        const time = step * sixteenthDur;
        if (time >= durationSec) break;
        const bar = Math.floor(step / stepsPerBar);
        const chord = chordPlan[bar % chordPlan.length];
        const freqBase = 220 * Math.pow(2, (PITCHES.indexOf(chord.note) - 3) / 12);

        const isNewBar = (step % stepsPerBar) === 0;

        // Baixo (cada step)
        scheduleNote(time, 0.3, freqBase, gains.bass, 'bass');

        // Bateria (a cada 4 steps)
        if (step % 4 === 0) playDummy(time, 0.1, 60, gains.drums);

        // Harmonia (uma vez por compasso)
        if (isNewBar) {
          scheduleNote(time, 1.0, freqBase * 2, gains.clean, 'clean');
          scheduleNote(time, 1.0, freqBase * 2.5, gains.dist, 'dist');
          scheduleNote(time, 1.0, freqBase * 3, gains.piano, 'piano');
          scheduleNote(time, 1.0, freqBase * 2.2, gains.echo, 'echo');
          scheduleNote(time, 1.0, freqBase * 2.8, gains.cleanPicked, 'cleanPicked');
          scheduleNote(time, 1.0, freqBase * 3.5, gains.organ, 'organ');
        }

        // Melodia
        if (step % 8 === 0) {
          const melodyFreq = freqBase * [1, 1.25, 1.5, 2][Math.floor(Math.random() * 4)];
          scheduleNote(time, 0.4, melodyFreq, gains.melody, 'melody');
        }
      }

      const buffer = await offlineCtx.startRendering();
      const wavBlob = audioBufferToWav(buffer);
      const jsonBlob = new Blob([JSON.stringify(metadata, null, 2)], { type: 'application/json' });

      downloadBlob(wavBlob, `jam-${String(index).padStart(4, '0')}.wav`);
      downloadBlob(jsonBlob, `jam-${String(index).padStart(4, '0')}.json`);
    }

    // === CONTROLE DE BATCH ===
    let isGenerating = false;

    async function generateBatch(count) {
      if (isGenerating) return;
      isGenerating = true;
      const statusEl = document.getElementById('status');
      statusEl.textContent = `Iniciando gera√ß√£o de ${count} m√∫sicas...`;

      for (let i = 1; i <= count; i++) {
        statusEl.textContent = `Gerando m√∫sica ${i} de ${count}...`;
        try {
          await renderOneMusic(i, 30);
          // Pequena pausa para n√£o sobrecarregar o navegador
          await new Promise(r => setTimeout(r, 100));
        } catch (e) {
          console.error('Erro na m√∫sica', i, e);
          alert(`Erro ao gerar m√∫sica ${i}. Verifique o console.`);
          break;
        }
      }

      statusEl.textContent = `‚úÖ ${count} m√∫sicas geradas!`;
      isGenerating = false;
    }

    // === EVENTOS ===
    document.querySelectorAll('button[data-count]').forEach(btn => {
      btn.addEventListener('click', () => {
        const count = Number(btn.dataset.count);
        if (confirm(`Deseja gerar ${count} m√∫sicas de 30s cada? Isso pode levar v√°rios minutos.`)) {
          generateBatch(count);
        }
      });
    });
  </script>
</body>
</html>
