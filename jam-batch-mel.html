<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Jam Batch — FINAL (wav + json + mel)</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;background:#071014;color:#e6f6f5;padding:20px}
  .card{max-width:980px;margin:0 auto;background:#071a1f;padding:18px;border-radius:10px}
  h1{color:#8ef0d4}
  label{display:block;margin-top:8px;color:#bcd}
  input,select,button{padding:8px;border-radius:8px;border:1px solid #123;background:#042024;color:#e6f6f5}
  button{cursor:pointer}
  .controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
  .progress{height:14px;background:#022227;border-radius:8px;margin-top:12px;overflow:hidden}
  .bar{height:100%;background:#8ef0d4;width:0%}
  pre{background:#021214;padding:10px;border-radius:6px;max-height:360px;overflow:auto}
</style>
</head>
<body>
  <div class="card">
    <h1>Jam Batch — FINAL (wav + json + mel)</h1>
    <p>Use na pasta do seu projeto (mesmos assets). Teste com 5 faixas antes de rodar 1000.</p>

    <label>Quantidade</label>
    <input id="count" type="number" value="5" min="1" max="5000">

    <label>Duração (segundos)</label>
    <input id="duration" type="number" value="30" min="1" max="600">

    <label>BPM (0 = aleatório)</label>
    <input id="bpm" type="number" value="100" min="0" max="300">

    <label>Mel params (frameSize / hopSize)</label>
    <input id="frameSize" type="number" value="1024" min="256" max="8192" step="256">
    <input id="hopSize" type="number" value="512" min="64" max="4096" step="64">

    <div class="controls">
      <button id="pickFolder">Escolher pasta (File System API)</button>
      <button id="start" style="background:#8ef0d4;color:#002">▶ Gerar</button>
      <button id="stop" disabled>■ Parar</button>
    </div>

    <div class="progress"><div id="bar" class="bar"></div></div>
    <div style="margin-top:12px"><pre id="log">Aguardando...</pre></div>
  </div>

<script>
/* Jam Batch FINAL
   - Normaliza tokens de bateria (aceita "caixa", "caixa-chimbal", "ca", etc.)
   - Muting por peça: 'drum-bu', 'drum-ca', 'bass-F', 'chord-clean-C', ...
   - Resolve arquivos de baixo tentando variantes (16S, S, sem S)
   - Gera WAV, JSON e MEL-PNG
*/

/* ------------------ Config (ajuste caminhos se necessário) ------------------ */
const DRUMS = { // tokens -> files (token keys are normalized short keys)
  bu: 'assets/bumbo.mp3',
  ca: 'assets/caixa.mp3',
  ch: 'assets/chimbal.mp3',
  bch: 'assets/bumbo-chimbal.mp3',
  ba: 'assets/bumbo-ataque.mp3',
  su: 'assets/surdo.mp3',
  co: 'assets/conducao.mp3',
  cch: 'assets/caixa-chimbal.mp3',
  bco: 'assets/bumbo-conducao.mp3',
  cco: 'assets/caixa-conducao.mp3',
  to1: 'assets/tom-1.mp3',
  to2: 'assets/tom-2.mp3'
};

// bass sample pattern: assets/bass-<NAME>.mp3
const PITCHES = ['A','AS','B','C','CS','D','DS','E','F','FS','G','GS'];
const BASS_SAMPLES = {}; for (const p of PITCHES) BASS_SAMPLES[p] = `assets/bass-${p}.mp3`;
BASS_SAMPLES['x'] = 'assets/bass-muted.mp3';

// sample grooves (extend if you have your ALL_GROOVES)
const ALL_GROOVES = [
  { name:'Rock', meter:'4/4', drumPattern:['bu - ca - (ch ch cch ch)'], bassRhythm:['x - x - x - x -']},
  { name:'Blues', meter:'4/4', drumPattern:['bu - ca - (ch ch cch ch)'], bassRhythm:['x - x - -']},
  { name:'Samba', meter:'2/4', drumPattern:['bu co ch -'], bassRhythm:['x - - -']},
  { name:'Forró', meter:'2/4', drumPattern:['bu - co -'], bassRhythm:['x -']},
  { name:'Metal', meter:'4/4', drumPattern:['bch bch bch bch'], bassRhythm:['x x x x']}
];

/* ------------------ Small DSP utils (WAV, STFT, mel) ------------------ */
function interleave(L, R){ const out=new Float32Array(L.length+R.length); let i=0,j=0; while(i<L.length){ out[j++]=L[i]; out[j++]=R[i]; i++; } return out; }
function writeWav(samples, sr){ const buffer=new ArrayBuffer(44 + samples.length*2); const view=new DataView(buffer);
  function wstr(off, s){ for(let i=0;i<s.length;i++) view.setUint8(off+i,s.charCodeAt(i)); }
  wstr(0,'RIFF'); view.setUint32(4,36 + samples.length*2,true); wstr(8,'WAVE'); wstr(12,'fmt ');
  view.setUint32(16,16,true); view.setUint16(20,1,true); view.setUint16(22,2,true); view.setUint32(24,sr,true);
  view.setUint32(28,sr*4,true); view.setUint16(32,4,true); view.setUint16(34,16,true); wstr(36,'data');
  view.setUint32(40,samples.length*2,true);
  let off=44;
  for(let i=0;i<samples.length;i++,off+=2){ const s=Math.max(-1,Math.min(1,samples[i])); view.setInt16(off, s<0? s*0x8000 : s*0x7fff, true); }
  return new Blob([view], {type:'audio/wav'}); 
}

/* FFT/STFT/Mel (compact but functional) */
function hann(N){ const w=new Float32Array(N); for(let n=0;n<N;n++) w[n]=0.5*(1-Math.cos(2*Math.PI*n/(N-1))); return w; }
function nextPow2(n){ let p=1; while(p<n) p<<=1; return p; }
// iterative radix-2 FFT
function fft(real, imag){ const n=real.length; if(n===0) return; const levels=Math.floor(Math.log2(n)); if((1<<levels)!==n) throw 'FFT size must be power of two';
  for(let i=0;i<n;i++){ let j=0,x=i; for(let k=0;k<levels;k++){ j=(j<<1)|(x&1); x>>=1; } if(j>i){ [real[i],real[j]]=[real[j],real[i]]; [imag[i],imag[j]]=[imag[j],imag[i]]; } }
  for(let size=2; size<=n; size<<=1){
    const half=size>>1; const tableStep=n/size;
    for(let i=0;i<n;i+=size){ for(let j=0;j<half;j++){
      const k=j*tableStep; const theta=-2*Math.PI*k/n; const wr=Math.cos(theta), wi=Math.sin(theta);
      const idx1=i+j, idx2=i+j+half; const tr = wr*real[idx2] - wi*imag[idx2]; const ti = wr*imag[idx2] + wi*real[idx2];
      real[idx2]=real[idx1]-tr; imag[idx2]=imag[idx1]-ti; real[idx1]+=tr; imag[idx1]+=ti;
    } }
  }
}
function stftMagnitude(signal, frameSize, hop){
  const w=hann(frameSize); const fftSize=nextPow2(frameSize); const half=fftSize/2;
  const nFrames=Math.max(0, Math.floor((signal.length-frameSize)/hop) + 1);
  const mags=[]; const re=new Float32Array(fftSize), im=new Float32Array(fftSize);
  for(let f=0; f<nFrames; f++){
    const off=f*hop; for(let i=0;i<frameSize;i++){ re[i]=(signal[off+i]||0)*w[i]; im[i]=0; } for(let i=frameSize;i<fftSize;i++){ re[i]=0; im[i]=0; }
    fft(re,im); const mag = new Float32Array(half); for(let k=0;k<half;k++) mag[k]=Math.hypot(re[k], im[k]); mags.push(mag);
  }
  return {mags, fftSize, half};
}
function hzToMel(h){ return 2595 * Math.log10(1 + h / 700); }
function melToHz(m){ return 700 * (Math.pow(10, m / 2595) - 1); }
function melFilterBank(nFilters, fftSize, sr, fmin=0, fmax=null){
  fmax = fmax || sr/2; const melMin = hzToMel(fmin), melMax = hzToMel(fmax);
  const melPoints = new Float32Array(nFilters+2); for(let i=0;i<melPoints.length;i++) melPoints[i] = melMin + (i/(nFilters+1))*(melMax-melMin);
  const hzPoints = new Float32Array(melPoints.length); for(let i=0;i<hzPoints.length;i++) hzPoints[i] = melToHz(melPoints[i]);
  const binPoints = new Int32Array(hzPoints.length); for(let i=0;i<hzPoints.length;i++) binPoints[i] = Math.floor((fftSize+1) * hzPoints[i] / sr);
  const filters = [];
  for(let m=1;m<=nFilters;m++){
    const f_m_minus = binPoints[m-1], f_m = binPoints[m], f_m_plus = binPoints[m+1];
    const filter = new Float32Array(fftSize/2);
    for(let k=0;k<filter.length;k++){
      if(k < f_m_minus) filter[k]=0;
      else if(k <= f_m) filter[k] = (k - f_m_minus) / (f_m - f_m_minus || 1);
      else if(k <= f_m_plus) filter[k] = (f_m_plus - k) / (f_m_plus - f_m || 1);
      else filter[k] = 0;
    }
    filters.push(filter);
  }
  return filters;
}
function computeMelSpectrogram(signal, sr, frameSize, hop, nMels=128){
  const {mags, fftSize, half} = stftMagnitude(signal, frameSize, hop);
  const filters = melFilterBank(nMels, fftSize, sr, 0, sr/2);
  const T = mags.length, M = filters.length; const mel = new Array(T);
  for(let t=0;t<T;t++){ const mag=mags[t]; const row=new Float32Array(M); for(let m=0;m<M;m++){ let s=0; const f=filters[m]; for(let k=0;k<half;k++) s += mag[k]*f[k]; row[m]=s; } mel[t]=row; }
  let maxv=1e-12; for(let t=0;t<T;t++) for(let m=0;m<mel[t].length;m++) if(mel[t][m]>maxv) maxv = mel[t][m];
  for(let t=0;t<T;t++) for(let m=0;m<mel[t].length;m++) mel[t][m] = 20 * Math.log10((mel[t][m]/maxv) + 1e-10);
  return {mel, nMels: filters.length, nFrames: mel.length};
}
async function melToPngBlob(melObj){
  const {mel, nMels, nFrames} = melObj;
  const canvas=document.createElement('canvas'); canvas.width = nFrames; canvas.height = nMels;
  const ctx = canvas.getContext('2d'); const img = ctx.createImageData(canvas.width, canvas.height);
  let min=Infinity, max=-Infinity;
  for(let t=0;t<nFrames;t++) for(let m=0;m<nMels;m++){ const v=mel[t][m]; if(v<min) min=v; if(v>max) max=v; }
  if(!isFinite(min)){ min=-80; max=0; }
  const range = max - min || 1;
  for(let x=0;x<nFrames;x++) for(let y=0;y<nMels;y++){
    const v = mel[x][y]; const norm = Math.max(0, Math.min(255, Math.round(255*(v-min)/range)));
    const idx = ((nMels-1-y)*nFrames + x)*4;
    img.data[idx]=norm; img.data[idx+1]=norm; img.data[idx+2]=norm; img.data[idx+3]=255;
  }
  ctx.putImageData(img,0,0);
  return new Promise(res => canvas.toBlob(b => res(b), 'image/png'));
}

/* ------------------ Rhythm parse/expand ------------------ */
function parsePattern(text){
  const r={intro:[],loop:[]};
  const im=text.match(/\[(.*?)\]/); const lm=text.match(/\((.*?)\)/);
  if(im) r.intro = im[1].trim().split(/\s+/).filter(Boolean);
  if(lm) r.loop = lm[1].trim().split(/\s+/).filter(Boolean);
  if(!im && !lm) r.loop = text.trim().split(/\s+/).filter(Boolean);
  if(!r.loop.length) r.loop = r.intro.slice();
  return r;
}
function expandRhythm(arr, total){
  const joined = arr.join(' ').replace(/\s+/g,' ').trim(); const tokens = joined.split(/\s+/).filter(Boolean);
  const out=[]; let safety=0;
  while(out.length<total && safety<5000){ for(const t of tokens){ if(out.length>=total) break; out.push(t); } safety++; }
  return out.slice(0, total);
}

/* ------------------ Helpers: normalize drum tokens & bass candidates ------------------ */
/* Map tokens/labels to normalized short keys that match DRUMS mapping */
function resolveDrumToken(token){
  if(!token) return null;
  const t = token.toString().toLowerCase();
  // use includes checks to accept "caixa", "ca", "caixa-chimbal", "caixa_chimbal", etc.
  if (['bu','bumbo'].some(x=>t.includes(x))) return 'bu';
  if (['ca','caixa'].some(x=>t.includes(x))) {
    // 'caixa-chimbal' should map to 'cch' rather than 'ca' if it contains both words
    if (t.includes('caixa') && (t.includes('chimbal') || t.includes('cch'))) return 'cch';
    return 'ca';
  }
  if (['ch','chimbal'].some(x=>t.includes(x))) return 'ch';
  if (['ba','bumbo-ataque'].some(x=>t.includes(x))) return 'ba';
  if (['cch','caixa-chimbal','caixa_chimbal'].some(x=>t.includes(x) || t===x)) return 'cch';
  if (['bco','bumbo-conducao','bumbo_conducao'].some(x=>t.includes(x) || t===x)) return 'bco';
  if (['co','conducao'].some(x=>t.includes(x))) return 'co';
  if (['cco','caixa-conducao','caixa_conducao'].some(x=>t.includes(x) || t===x)) return 'cco';
  if (['to1','tom-1'].some(x=>t.includes(x))) return 'to1';
  if (['to2','tom-2'].some(x=>t.includes(x))) return 'to2';
  if (['su','surdo'].some(x=>t.includes(x))) return 'su';
  if (['bch','bumbo-chimbal'].some(x=>t.includes(x) || t===x)) return 'bch';
  // fallback: return token shortened (first 3 letters) if matches key
  const short = token.slice(0,3).toLowerCase();
  return Object.keys(DRUMS).includes(short) ? short : null;
}

/* Create candidate filenames for bass, prefer 16S then S then plain.
   e.g. note='F' => bass-F16S.mp3, bass-FS.mp3, bass-F.mp3
   note might be like 'F#' or 'F' or 'Fs16' (we always map '#'->'S' and uppercase) */
function getBassCandidates(note){
  if(!note) return [];
  let n = note.toString().toUpperCase().replace('#','S');
  // if it's like 'F16S' user may pass full variant already -> include as-is
  const cands = [];
  if (!n.endsWith('16S') && n.length===2 && /[A-G]S?/.test(n)) {
    cands.push(`assets/bass-${n}16S.mp3`); // prefer 16S if present
    cands.push(`assets/bass-${n}S.mp3`);   // fallback with S (double S ok if already)
    cands.push(`assets/bass-${n}.mp3`);
  } else {
    // generic: try full, then remove trailing parts
    cands.push(`assets/bass-${n}.mp3`);
    // also try base (strip digits)
    const base = n.replace(/[0-9]/g,'');
    if (base !== n) {
      cands.push(`assets/bass-${base}.mp3`);
    }
    // try with S variant if missing
    if (!n.endsWith('S')) cands.push(`assets/bass-${n}S.mp3`);
  }
  // ensure unique order
  return [...new Set(cands)];
}

/* ------------------ chord filename helpers (folder & filename) ------------------ */
function noteToFolder(note){ if(!note) return 'C'; return note.toString().replace('#','S'); }
function chordFileNameObj(chord){
  const folder = noteToFolder(chord.note || 'C');
  const type = (chord.type||'').toString();
  const base = folder;
  if(!type || type === 'maj') return {folder, filename: `${base}.mp3`};
  return {folder, filename: `${base}${type}.mp3`};
}

/* ------------------ renderOne: load buffers and schedule with per-piece muting ------------------ */
async function renderOne(params){
  const {durationSec,bpm,groove,chordPlan,chordDurations,frameSize,hopSize} = params;
  const sampleRate = 44100;
  const frames = Math.ceil(durationSec * sampleRate);
  const offline = new OfflineAudioContext(2, frames, sampleRate);

  // gains
  const master = offline.createGain(); master.connect(offline.destination);
  const drumGain = offline.createGain(); drumGain.connect(master); drumGain.gain.value = 0.8;
  const bassGain = offline.createGain(); bassGain.connect(master); bassGain.gain.value = 0.7;
  const cleanGain = offline.createGain(); cleanGain.connect(master); cleanGain.gain.value = 0.6;
  const distGain = offline.createGain(); distGain.connect(master); distGain.gain.value = 0.5;
  const pianoGain = offline.createGain(); pianoGain.connect(master); pianoGain.gain.value = 0.55;
  const organGain = offline.createGain(); organGain.connect(master); organGain.gain.value = 0.45;

  const beats = Number((groove.meter||'4/4').split('/')[0])||4;
  const sixteenth = 60/bpm/4;
  const totalSteps = Math.floor(durationSec / sixteenth);

  // rhythms
  const bassRh = expandRhythm(groove.bassRhythm || ['x - x -'], totalSteps);
  const drumParsed = parsePattern((groove.drumPattern && groove.drumPattern.join(' ')) || 'bu - ca - ch -');
  const drumLoop = drumParsed.loop.length ? drumParsed.loop : drumParsed.intro;
  const drumSeq = expandRhythm(drumLoop, totalSteps);

  // collect candidate urls: chords + drum files + bass candidates
  const urls = new Set();
  for(const ch of chordPlan){
    const {folder, filename} = chordFileNameObj(ch);
    urls.add(`guitarraLimpa/${folder}/${filename}`);
    urls.add(`guitarraDistorcao/${folder}/${filename}`);
    urls.add(`assets/PianoStringChord/${folder}/${filename}`);
    urls.add(`Orgao/${folder}/${filename}`);
    urls.add(`GuitarraEcho/${folder}/${filename}`);
  }
  // drums (all known tokens)
  Object.values(DRUMS).forEach(u => urls.add(u));
  // bass: try all canonical pitch names and keep patterns (loader will fetch what exists)
  for(const p of PITCHES){
    urls.add(`assets/bass-${p}.mp3`);
    urls.add(`assets/bass-${p}16S.mp3`);
    urls.add(`assets/bass-${p}S.mp3`);
  }
  urls.add('assets/bass-muted.mp3');

  // load buffers (skip missing)
  const buffers = {};
  await Promise.all(Array.from(urls).map(async url => {
    try{
      const r = await fetch(url);
      if(!r.ok) { /*console.warn('404', url);*/ return; }
      const ab = await r.arrayBuffer();
      const buf = await offline.decodeAudioData(ab);
      if(buf) buffers[url] = buf;
    } catch(e){ /* ignore */ }
  }));
  // console report of missing drums if critical
  Object.keys(DRUMS).forEach(k => { if(!buffers[DRUMS[k]]) console.warn('Drum sample missing:', DRUMS[k]); });

  // last sources keyed per logical voice
  const lastSource = {};

  function schedule(buf, when, gainNode, key, maxLen=3.0, gainVal=1.0){
    if(!buf) return;
    // stop only same key (so kick doesn't stop snare)
    if(lastSource[key]){ try{ lastSource[key].stop(when); } catch(e){} lastSource[key] = null; }
    const src = offline.createBufferSource();
    const g = offline.createGain();
    src.buffer = buf; src.connect(g); g.connect(gainNode);
    g.gain.setValueAtTime(0, when); g.gain.linearRampToValueAtTime(gainVal, when + 0.01);
    src.start(when);
    const stopTime = Math.min(when + buf.duration, when + maxLen, durationSec);
    src.stop(stopTime);
    lastSource[key] = src;
  }

  // scheduling loop
  for(let step=0; step<totalSteps; step++){
    const t = step * sixteenth;

    // drums
    const rawTok = drumSeq[step];
    const dKey = resolveDrumToken(rawTok);
    if(dKey){
      const drumUrl = DRUMS[dKey];
      if(drumUrl && buffers[drumUrl]) schedule(buffers[drumUrl], t, drumGain, `drum-${dKey}`, 1.2, 0.95);
      else console.debug('Drum buffer not loaded for', dKey, drumUrl);
    }

    // bass
    const bTok = (bassRh[step]||'-').toString();
    if(bTok !== '-' && bTok !== 'x'){
      // normalize token like "F" or "Fs" or "FS" etc.
      let note = bTok.toUpperCase().replace('#','S'); // if user used '#' -> S
      // try candidate filenames
      const cands = getBassCandidates(note);
      let found = false;
      for(const cand of cands){
        if(buffers[cand]){ schedule(buffers[cand], t, bassGain, `bass-${note}`, 1.6, 1.0); found=true; break; }
      }
      if(!found) console.debug('Bass sample not found for', note, cands);
    } else if (bTok === 'x'){
      const muteUrl = 'assets/bass-muted.mp3';
      if(buffers[muteUrl]) schedule(buffers[muteUrl], t, bassGain, `bass-muted`, 1.6, 0.85);
    }

    // chords at bar start
    if((step % (beats*4)) === 0){
      const chordIdx = Math.floor(step / (beats*4)) % chordPlan.length;
      const chord = chordPlan[chordIdx];
      if(chord){
        const {folder, filename} = chordFileNameObj(chord);
        const tryList = [
          {url:`guitarraLimpa/${folder}/${filename}`, key:`chord-clean-${folder}`, gain:cleanGain},
          {url:`guitarraDistorcao/${folder}/${filename}`, key:`chord-dist-${folder}`, gain:distGain},
          {url:`assets/PianoStringChord/${folder}/${filename}`, key:`chord-piano-${folder}`, gain:pianoGain},
          {url:`Orgao/${folder}/${filename}`, key:`chord-organ-${folder}`, gain:organGain},
          {url:`GuitarraEcho/${folder}/${filename}`, key:`chord-echo-${folder}`, gain:cleanGain}
        ];
        tryList.forEach(item => { const buf = buffers[item.url]; if(buf) schedule(buf, t, item.gain, item.key, 3.0, 0.95); else console.debug('missing chord sample', item.url); });
      }
    }
  } // end scheduling

  // render
  const rendered = await offline.startRendering();
  const left = rendered.getChannelData(0), right = rendered.getChannelData(1);
  const inter = interleave(left, right);
  const wavBlob = writeWav(inter, rendered.sampleRate);

  // mel (mono)
  const mono = new Float32Array(left.length); for(let i=0;i<left.length;i++) mono[i] = 0.5 * (left[i] + right[i]);
  const melObj = computeMelSpectrogram(mono, rendered.sampleRate, frameSize||1024, hopSize||512, 128);
  const melPng = await melToPngBlob(melObj);

  return {wavBlob, melPng, chordPlan, chordDurations};
}

/* ------------------ UI & batch control ------------------ */
let running=false, stopRequested=false, dirHandle=null;
const logEl=document.getElementById('log'), barEl=document.getElementById('bar');
function log(msg, append=true){ if(!append) logEl.textContent=msg; else logEl.textContent += '\n'+msg; logEl.scrollTop=99999; }

async function maybeWriteFile(name, blob){
  if(dirHandle && dirHandle.getFileHandle){
    try{ const fh = await dirHandle.getFileHandle(name, {create:true}); const w = await fh.createWritable(); await w.write(blob); await w.close(); return true; }
    catch(e){ console.warn('FS write failed', e); }
  }
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = name; document.body.appendChild(a); a.click(); URL.revokeObjectURL(a.href); a.remove(); return false;
}

document.getElementById('pickFolder').addEventListener('click', async ()=>{
  try{ if(window.showDirectoryPicker){ dirHandle = await window.showDirectoryPicker(); log('Pasta escolhida: '+(dirHandle.name||''), false); } else { dirHandle=null; log('showDirectoryPicker não suportado — fallback para downloads', false); } }
  catch(e){ dirHandle=null; log('Cancelado/erro: '+e.message, false); }
});

document.getElementById('start').addEventListener('click', async ()=>{
  if(running) return; running=true; stopRequested=false; document.getElementById('stop').disabled=false;
  const count = Number(document.getElementById('count').value||100);
  const duration = Number(document.getElementById('duration').value||30);
  const bpmVal = Number(document.getElementById('bpm').value||100);
  const frameSize = Number(document.getElementById('frameSize').value||1024);
  const hopSize = Number(document.getElementById('hopSize').value||512);

  log(`Iniciando geração: ${count} faixas de ${duration}s (frame=${frameSize}, hop=${hopSize})`, false);
  const startAll = Date.now();

  for(let i=0;i<count;i++){
    if(stopRequested){ log('Parada solicitada — abortando.'); break; }
    const groove = ALL_GROOVES[Math.floor(Math.random()*ALL_GROOVES.length)];
    const bpm = (bpmVal>0)?bpmVal:(80 + Math.floor(Math.random()*80));
    const beatsPerBar = Number((groove.meter||'4/4').split('/')[0]) || 4;
    const bars = Math.ceil((duration / (60/bpm/4)) / (beatsPerBar*4));
    const chordPlan = [], chordDurations = [];
    const degToNote = {1:'C',2:'D',3:'E',4:'F',5:'G',6:'A',7:'B'};
    for(let b=0;b<bars;b++){ const degCandidates=[1,4,5,6]; const deg=degCandidates[Math.floor(Math.random()*degCandidates.length)];
      chordPlan.push({note: degToNote[deg], type:'', display:degToNote[deg]}); chordDurations.push(1);
    }

    log(`Renderizando ${i+1}/${count} — estilo=${groove.name} bpm=${bpm}`);
    try{
      const {wavBlob, melPng, chordPlan:cp, chordDurations:cd} = await renderOne({
        durationSec: duration, bpm, groove, chordPlan, chordDurations, frameSize, hopSize
      });

      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      const base = `jam-${groove.name}-${bpm}bpm-${duration}s-${String(i+1).padStart(4,'0')}-${ts}`;
      await maybeWriteFile(base + '.wav', wavBlob);
      await maybeWriteFile(base + '-mel.png', melPng);

      // metadata
      const sixteenthDur = 60/bpm/4;
      const chords = []; let step=0;
      for(let j=0;j<cp.length;j++){
        const start = +(step * sixteenthDur).toFixed(3);
        const end = +((step + (cd[j]||1) * beatsPerBar * 4) * sixteenthDur).toFixed(3);
        chords.push({start, end, chord: cp[j].display, root: cp[j].note, quality:'maj', bar:j, step});
        step += (cd[j]||1) * beatsPerBar * 4;
      }
      const meta = {bpm, meter:groove.meter||'4/4', key:'C', quality:'maj', style:groove.name, duration, chords};
      await maybeWriteFile(base + '.json', new Blob([JSON.stringify(meta,null,2)], {type:'application/json'}));

      const perc = Math.round(((i+1)/count)*100); barEl.style.width = perc + '%';
    } catch(e){
      console.error('Erro render:', e); log('Erro ao renderizar faixa '+(i+1)+': '+(e.message||e));
    }

    await new Promise(res => setTimeout(res, 80));
  }

  const elapsed = Math.round((Date.now()-startAll)/1000);
  log(`Concluído em ${elapsed}s.`);
  running=false; document.getElementById('stop').disabled=true;
});

document.getElementById('stop').addEventListener('click', ()=>{ stopRequested=true; document.getElementById('stop').disabled=true; });

</script>
</body>
</html>
