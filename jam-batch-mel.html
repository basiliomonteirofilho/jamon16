<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Gerador de Treinamento IA – Jam On</title>
</head>
<body>
  <h2>Gerador de Dataset Musical para IA</h2>
  <p>Clique para gerar 1 música de 30s + metadados JSON. Repita 1000x.</p>
  <button id="btnGenerate">🎵 Gerar Música #<span id="counter">1</span></button>
  <div id="status"></div>

  <script>
    // === CONFIGURAÇÕES ===
    const TOTAL_MUSICAS = 1000;
    const DURACAO = 30.0; // segundos
    let contador = 1;

    // --- Copiando partes essenciais do seu código ---
    const PITCHES = ['A','AS','B','C','CS','D','DS','E','F','FS','G','GS'];
    const CHORD_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    const DEGREE_TO_ROOT = { 1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11 };

    const STYLE_PROGRESSIONS = {
      Rock: [[1,4,5,1], [1,5,6,4]],
      Blues: [[1,4,5,1]],
      Samba: [[2,5,1,1]],
      Metal: [[1,3,5,6]],
      Jazz: [[2,5,1,4]]
    };

    const ALL_GROOVES = [
      { name: "Rock", meter: "4/4", bassScale: [1,3,5,8] },
      { name: "Blues", meter: "4/4", bassScale: [1,3,5,6,8] },
      { name: "Samba", meter: "2/4", bassScale: [8,5] },
      { name: "Metal", meter: "4/4", bassScale: [1,3,5,8] },
      { name: "Jazz", meter: "4/4", bassScale: "chromatic" }
    ];

    // === FUNÇÕES AUXILIARES ===
    function meterToBeats(meter) {
      return Number(meter.split('/')[0]) || 4;
    }

    function randomChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function generateMetadata(bpm, meter, key, quality, style, chordPlan, sixteenthDur) {
      const beats = meterToBeats(meter);
      const stepsPerBar = beats * 4;
      const totalSteps = Math.ceil(DURACAO / sixteenthDur);
      const chords = [];

      for (let step = 0; step < totalSteps; step++) {
        const bar = Math.floor(step / stepsPerBar);
        const chordIndex = bar % chordPlan.length;
        const chord = chordPlan[chordIndex];
        const start = step * sixteenthDur;
        const end = start + sixteenthDur;

        if (end > DURACAO) break;

        chords.push({
          start: parseFloat(start.toFixed(3)),
          end: parseFloat(end.toFixed(3)),
          chord: chord.display,
          root: chord.rootNote,
          quality: chord.type || 'maj',
          bar,
          step
        });
      }

      return {
        bpm,
        meter,
        key: CHORD_NAMES[PITCHES.indexOf(key)],
        quality,
        style,
        duration: DURACAO,
        chords
      };
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function audioBufferToWav(buffer) {
      const numOfChan = buffer.numberOfChannels;
      const length = buffer.length * numOfChan * 2 + 44;
      const arrayBuffer = new ArrayBuffer(length);
      const view = new DataView(arrayBuffer);

      const writeString = (offset, str) => {
        for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
      };

      writeString(0, 'RIFF');
      view.setUint32(4, length - 8, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numOfChan, true);
      view.setUint32(24, buffer.sampleRate, true);
      view.setUint32(28, buffer.sampleRate * 2 * numOfChan, true);
      view.setUint16(32, 2 * numOfChan, true);
      view.setUint16(34, 16, true);
      writeString(36, 'data');
      view.setUint32(40, length - 44, true);

      const channels = [];
      for (let i = 0; i < numOfChan; i++) channels.push(buffer.getChannelData(i));

      let offset = 44;
      for (let i = 0; i < buffer.length; i++) {
        for (let ch = 0; ch < numOfChan; ch++) {
          const sample = Math.max(-1, Math.min(1, channels[ch][i]));
          const int16 = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
          view.setInt16(offset, int16, true);
          offset += 2;
        }
      }
      return new Blob([view], { type: 'audio/wav' });
    }

    // === FUNÇÃO PRINCIPAL ===
    async function generateOneMusic() {
      if (contador > TOTAL_MUSICAS) {
        document.getElementById('status').textContent = '✅ Todas as 1000 músicas geradas!';
        return;
      }

      const statusEl = document.getElementById('status');
      statusEl.textContent = `⏳ Gerando música ${contador} de ${TOTAL_MUSICAS}...`;

      // --- Escolhe parâmetros aleatórios ---
      const groove = randomChoice(ALL_GROOVES);
      const style = groove.name.split('_')[0].replace(/[\d+]/g, '');
      const meter = groove.meter;
      const bpm = Math.floor(Math.random() * 100) + 70; // 70–170
      const key = randomChoice(PITCHES);
      const quality = Math.random() > 0.5 ? 'maj' : 'min';

      const sixteenthDur = 60 / bpm / 4;
      const beats = meterToBeats(meter);
      const bars = Math.ceil(DURACAO / (60 / bpm * beats));
      const totalSteps = bars * beats * 4;

      // --- Escolhe progressão ---
      const progressions = STYLE_PROGRESSIONS[style] || STYLE_PROGRESSIONS.Rock;
      const prog = randomChoice(progressions);
      const chordPlan = prog.map(degree => {
        const rootIdx = (PITCHES.indexOf(key) + DEGREE_TO_ROOT[degree]) % 12;
        const rootNote = PITCHES[rootIdx];
        let type = '';
        if (degree === 7) type = 'dim';
        else if ([2,3,6].includes(degree) && quality === 'maj') type = 'm';
        return { note: rootNote, type, display: CHORD_NAMES[rootIdx] + type, rootNote: CHORD_NAMES[rootIdx] };
      });

      // --- Metadados ---
      const metadata = generateMetadata(bpm, meter, key, quality, style, chordPlan, sixteenthDur);
      const jsonBlob = new Blob([JSON.stringify(metadata, null, 2)], { type: 'application/json' });
      downloadBlob(jsonBlob, `jam-${contador.toString().padStart(4, '0')}.json`);

      // --- Renderização offline ---
      const sampleRate = 44100;
      const offlineCtx = new OfflineAudioContext(2, Math.ceil(DURACAO * sampleRate), sampleRate);

      // Ganho master
      const master = offlineCtx.createGain();
      master.gain.value = 0.8;
      master.connect(offlineCtx.destination);

      // Instrumentos (todos ativos!)
      const gains = {};
      ['drums', 'bass', 'clean', 'dist', 'piano', 'echo', 'cleanPicked', 'organ', 'melody'].forEach(name => {
        gains[name] = offlineCtx.createGain();
        gains[name].gain.value = 0.5;
        gains[name].connect(master);
      });

      // Simulação simplificada de samples (sem carregar arquivos reais)
      // Na prática, você substituirá isso por buffers reais (como no seu código original)
      function playDummyNote(time, duration, freq, gainNode) {
        if (time >= DURACAO) return;
        const osc = offlineCtx.createOscillator();
        const g = offlineCtx.createGain();
        osc.frequency.value = freq;
        osc.connect(g);
        g.connect(gainNode);
        g.gain.setValueAtTime(0.2, time);
        g.gain.exponentialRampToValueAtTime(0.001, time + Math.min(duration, 0.5));
        osc.start(time);
        osc.stop(time + Math.min(duration, 0.5));
      }

      // Agenda eventos por step
      for (let step = 0; step < totalSteps; step++) {
        const time = step * sixteenthDur;
        if (time >= DURACAO) break;

        const bar = Math.floor(step / (beats * 4));
        const chord = chordPlan[bar % chordPlan.length];
        const freqBase = 220 * Math.pow(2, (PITCHES.indexOf(chord.note) - 3) / 12); // A=220

        // Baixo
        playDummyNote(time, 0.3, freqBase, gains.bass);

        // Bateria (a cada 4 steps)
        if (step % 4 === 0) playDummyNote(time, 0.1, 60, gains.drums);

        // Harmonia (a cada compasso)
        if (step % (beats * 4) === 0) {
          playDummyNote(time, 1.0, freqBase * 2, gains.clean);
          playDummyNote(time, 1.0, freqBase * 2.5, gains.dist);
          playDummyNote(time, 1.0, freqBase * 3, gains.piano);
          playDummyNote(time, 1.0, freqBase * 2.2, gains.echo);
          playDummyNote(time, 1.0, freqBase * 2.8, gains.cleanPicked);
          playDummyNote(time, 1.0, freqBase * 3.5, gains.organ);
        }

        // Melodia (notas aleatórias dentro do acorde)
        if (step % 8 === 0) {
          const melodyFreq = freqBase * [1, 1.25, 1.5, 2][Math.floor(Math.random() * 4)];
          playDummyNote(time, 0.4, melodyFreq, gains.melody);
        }
      }

      // Renderiza e salva
      const buffer = await offlineCtx.startRendering();
      const wavBlob = audioBufferToWav(buffer);
      downloadBlob(wavBlob, `jam-${contador.toString().padStart(4, '0')}.wav`);

      statusEl.textContent = `✅ Música ${contador} salva!`;
      contador++;
      document.getElementById('counter').textContent = contador;
    }

    // === INICIALIZAÇÃO ===
    document.getElementById('btnGenerate').addEventListener('click', generateOneMusic);
  </script>
</body>
</html>
