<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Jam On ‚Äì Baixista Animada (Op√ß√£o A)</title>
<style>
  body {
    margin: 0;
    padding: 0;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: #0b0b0f;
    color: #f3f3f3;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
  }

  header {
    padding: 12px 20px;
    background: #111827;
    border-bottom: 1px solid #1f2937;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  header h1 {
    margin: 0;
    font-size: 1.1rem;
    color: #a5f3fc;
  }

  .pill {
    font-size: 0.7rem;
    padding: 4px 10px;
    border-radius: 999px;
    background: #1f2937;
    color: #9ca3af;
  }

  main {
    flex: 1;
    display: grid;
    grid-template-columns: minmax(280px, 520px) minmax(320px, 1fr);
    gap: 16px;
    padding: 16px;
  }

  /* === √ÅREA DA ANIMA√á√ÉO === */
  .animacao-container {
    background: #020617;
    border-radius: 16px;
    border: 1px solid #1f2937;
    position: relative;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .animacao-inner {
    position: relative;
    width: 420px;
    height: 480px;
    transform-origin: 50% 80%;
  }

  .anim-layer {
    position: absolute;
    left: 0;
    top: 0;
    width: 420px;
    height: 480px;
    object-fit: contain;
    pointer-events: none;
  }

  #pernasLayer { z-index: 1; }
  #troncoLayer { z-index: 2; }
  #cabecaLayer { z-index: 3; }
  #antebracoLayer { z-index: 4; }
  #bracoDireitoLayer { z-index: 5; }

  .anim-info {
    position: absolute;
    left: 8px;
    bottom: 8px;
    font-size: 0.75rem;
    padding: 4px 8px;
    border-radius: 999px;
    background: rgba(15,23,42,0.9);
    color: #a5b4fc;
  }

  /* Contagem regressiva */
  #countdownOverlay {
    position: absolute;
    inset: 0;
    background: rgba(3,7,18,0.88);
    display: none;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    z-index: 50;
  }

  #countdownNumber {
    font-size: 4rem;
    font-weight: 800;
    color: #fbbf24;
    text-shadow: 0 0 16px rgba(250,204,21,0.6);
  }

  #countdownLabel {
    margin-top: 8px;
    font-size: 0.9rem;
    color: #e5e7eb;
  }

  /* === √ÅREA DE CONTROLES === */
  .painel {
    background: #020617;
    border-radius: 16px;
    border: 1px solid #1f2937;
    padding: 14px 16px 18px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .painel h2 {
    margin: 0;
    font-size: 1rem;
    color: #a5f3fc;
  }

  .sub {
    font-size: 0.8rem;
    color: #9ca3af;
    margin-bottom: 4px;
  }

  .linha {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 6px;
    flex-wrap: wrap;
  }

  .linha label {
    font-size: 0.8rem;
    width: 80px;
    color: #e5e7eb;
  }

  input[type="number"], input[type="text"], select {
    background: #020617;
    border: 1px solid #374151;
    border-radius: 8px;
    padding: 6px 8px;
    color: #e5e7eb;
    font-size: 0.8rem;
  }

  input[type="number"] {
    width: 70px;
  }

  input[type="text"] {
    flex: 1;
  }

  input[type="range"] {
    flex: 1;
  }

  .valor-range {
    font-size: 0.8rem;
    width: 36px;
    text-align: right;
    color: #9ca3af;
  }

  .botoes-row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 6px;
  }

  button {
    border: none;
    border-radius: 999px;
    padding: 7px 14px;
    font-size: 0.8rem;
    cursor: pointer;
    background: #1f2937;
    color: #e5e7eb;
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }

  button.primary {
    background: #22c55e;
    color: #022c22;
    font-weight: 600;
  }

  button.danger {
    background: #ef4444;
    color: #fee2e2;
  }

  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .tag {
    font-size: 0.75rem;
    padding: 2px 6px;
    border-radius: 999px;
    background: #111827;
    color: #9ca3af;
  }

  .status {
    font-size: 0.8rem;
    padding: 4px 8px;
    border-radius: 999px;
    background: #111827;
    color: #e5e7eb;
    align-self: flex-start;
  }

  .separador {
    border-top: 1px solid #1f2937;
    margin: 4px 0 8px;
  }

  .explicacao {
    font-size: 0.7rem;
    color: #6b7280;
  }
</style>
</head>
<body>
<header>
  <h1>Jam On ‚Äì Baixista Animada (Op√ß√£o A)</h1>
  <div class="pill">Playback aleat√≥rio + composi√ß√£o manual ‚Ä¢ Baixo & Bateria</div>
</header>

<main>
  <!-- COLUNA ESQUERDA ‚Äì ANIMA√á√ÉO -->
  <section class="animacao-container">
    <div id="countdownOverlay">
      <div id="countdownNumber">3</div>
      <div id="countdownLabel">Preparando notas & imagens‚Ä¶</div>
    </div>

    <div class="animacao-inner" id="animacaoInner">
      <img id="pernasLayer" class="anim-layer" src="animacao/pernas/Pernas.png" alt="pernas">
      <img id="troncoLayer" class="anim-layer" src="animacao/tronco_baixo/Pasta_1F/1E.png" alt="tronco e baixo">
      <img id="cabecaLayer" class="anim-layer" src="animacao/cabeca/cabeca0001.png" alt="cabe√ßa">
      <img id="antebracoLayer" class="anim-layer" src="animacao/antebraco/antebracoE.png" alt="antebra√ßo">
      <img id="bracoDireitoLayer" class="anim-layer" src="animacao/braco_direito/Corda_E1.png" alt="bra√ßo direito">
      <div class="anim-info" id="animInfo">Aguardando‚Ä¶</div>
    </div>
  </section>

  <!-- COLUNA DIREITA ‚Äì CONTROLES -->
  <section class="painel">
    <h2>Controle de Playback & Composi√ß√£o</h2>
    <div class="sub">A baixista acompanha o playback aleat√≥rio e a sequ√™ncia manual.</div>

    <div class="linha">
      <label for="bpmInput">BPM</label>
      <input type="number" id="bpmInput" min="40" max="220" value="100">
    </div>

    <div class="linha">
      <label>Volume Baixo</label>
      <input type="range" id="volBass" min="0" max="1" step="0.01" value="0.55">
      <span class="valor-range" id="volBassLabel">55%</span>
    </div>

    <div class="linha">
      <label>Volume Bateria</label>
      <input type="range" id="volDrums" min="0" max="1" step="0.01" value="0.65">
      <span class="valor-range" id="volDrumsLabel">65%</span>
    </div>

    <div class="linha">
      <span class="tag">Composi√ß√£o Manual ‚Äì Baixo</span>
    </div>
    <div class="linha">
      <label for="manualBassSeq">Notas</label>
      <input type="text" id="manualBassSeq"
             placeholder="Ex.: 1 4 6 8 x 9 11 x 13‚Ä¶ (1‚Äì43 ou x)">
    </div>
    <div class="explicacao">
      ‚Ä¢ Use n√∫meros de 1 a 43 para as notas (1E, 2F, 3FS, ‚Ä¶) e
      <strong>x</strong> como ghost note / pausa.  
      ‚Ä¢ A bateria manual, por enquanto, usa um padr√£o simples em 4/4.
    </div>

    <div class="separador"></div>

    <div class="linha">
      <span class="tag">Playback Aleat√≥rio ‚Äì Baixo & Bateria</span>
    </div>
    <div class="explicacao">
      O playback usa os grooves do Jam On (ALL_GROOVES) apenas para
      baixo e bateria. A baixista anima tudo em tempo real.
    </div>

    <div class="botoes-row">
      <button id="btnPlayRandom" class="primary">‚ñ∂ Play Playback Aleat√≥rio</button>
      <button id="btnPlayManual" class="primary">üéß Play Composi√ß√£o Manual</button>
      <button id="btnPause">‚è∏ Pausar</button>
      <button id="btnStop" class="danger">‚èπ Parar</button>
    </div>

    <div class="linha">
      <span class="tag">Mutes</span>
    </div>
    <div class="botoes-row">
      <button id="muteBass" data-mute="off">üé∏ Baixo ON</button>
      <button id="muteDrums" data-mute="off">ü•Å Bateria ON</button>
    </div>

    <div class="linha">
      <div class="status" id="statusLabel">Parado</div>
    </div>

    <div class="explicacao">
      ‚Ä¢ Antes de cada play h√° uma contagem regressiva (3-2-1) para
      pr√©-calcular as imagens mais pr√≥ximas e carregar os √°udios.  
      ‚Ä¢ As notas de baixo n√£o se sobrep√µem: quando uma come√ßa, a
      anterior √© parada (efeito de ‚Äúmute‚Äù).  
      ‚Ä¢ O sample <strong>x</strong> usa o arquivo
      <code>assets/bass-muted.mp3</code> (ghost note).
    </div>
  </section>
</main>

<script>
/* ============================================================
 *  CONFIGURA√á√ÉO MUSICAL B√ÅSICA
 * ============================================================ */

// Notas usadas no Jam On principal
const PITCHES = ['E','F','FS','G','GS','A','AS','B','C','CS','D','DS'];

// Grooves (copiado/simplificado do Index ‚Äì s√≥ o que interessa aqui)
const ALL_GROOVES = [
  { name: "Rock", meter: "4/4",
    drumPattern: ["bch - ch - cch - ch - bch - ch - cch - ch bu"],
    bassRhythm:  ["bo - bo - bo - bo - bo - bo - bo - bo -"] },
  { name: "Rock2", meter: "4/4",
    drumPattern: ["bch - ch - cch - ch - bch - ch - cch - ch -"],
    bassRhythm:  ["bo - bo - bo - bo - bo - bo - bo - bo -"] },
  { name: "Rock3", meter: "4/4",
    drumPattern: ["bch - ch bu cch bu ch - bch - ch - cch - ch -"],
    bassRhythm:  ["bo - - bo - - bo - bo - bo - bo - bo -"] },
  { name: "Blues", meter: "4/4",
    drumPattern: ["bch - ch ch cch - ch ch bch - ch ch cch - ch ch"],
    bassRhythm:  ["bo - bo - bo - bo - bo - bo - bo - bo -"] },
  { name: "Forr√≥", meter: "2/4",
    drumPattern: ["bch - co - ch - ca -"],
    bassRhythm:  ["bo - - - x - - -"] },
  { name: "Jazz", meter: "4/4",
    drumPattern: ["bch co co - co co co ca bch co co - bch co co cch"],
    bassRhythm:  ["bo - bo - bo - bo - bo - bo - bo - bo - bo - bo - bo - bo -"] }
];

// Map de baterias (mesmo esquema do Index)
const DRUMS = {
  bu: 'bumbo',
  ca: 'caixa',
  ch: 'chimbal',
  ba: 'bumbo-ataque',
  cch: 'caixa-chimbal',
  co: 'conducao',
  bco: 'bumbo-conducao',
  cco: 'caixa-conducao',
  to1: 'tom-1',
  to2: 'tom-2',
  su: 'surdo',
  bch: 'bumbo-chimbal'
};

// Bass samples (apenas para construir caminhos ‚Äì aqui usamos
// um sistema num√©rico para casar com seus 1E‚Ä¶43AS)
const BASS_SAMPLES = {};

// Ghost note
BASS_SAMPLES['x'] = 'assets/bass-muted.mp3';

// Mapeia nome da nota (E,FS,G, etc) para √≠ndice 1..12
const NOTE_TO_INDEX = {
  'E': 1, 'F': 2, 'FS': 3, 'G': 4, 'GS': 5,
  'A': 6, 'AS': 7, 'B': 8, 'C': 9, 'CS': 10,
  'D': 11, 'DS': 12
};

/**
 * Converte um "pitch" simples (E, FS, etc) para n√∫mero 1..24
 * (1‚Äì12 = registro grave, 13‚Äì24 = +12 semitons)
 */
function pitchToNumeric(pitch, octaveUp = false) {
  const base = pitch.replace('8','').replace('S','S'); // s√≥ pra garantir
  const idx = NOTE_TO_INDEX[base];
  if (!idx) return 1;
  return idx + (octaveUp ? 12 : 0);
}

/* ============================================================
 *  √ÅUDIO ‚Äì WEB AUDIO API
 * ============================================================ */

let audioCtx = null;
let masterGain, bassGain, drumGain;

// cache de buffers
const bufferCache = new Map();

async function ensureAudioCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 1.0;
    masterGain.connect(audioCtx.destination);

    bassGain = audioCtx.createGain();
    drumGain = audioCtx.createGain();
    bassGain.connect(masterGain);
    drumGain.connect(masterGain);

    atualizarVolumes();
  }
}

async function loadBuffer(url) {
  if (bufferCache.has(url)) return bufferCache.get(url);
  const res = await fetch(url);
  const arr = await res.arrayBuffer();
  const buf = await audioCtx.decodeAudioData(arr);
  bufferCache.set(url, buf);
  return buf;
}

// Nota de baixo atual (pra "mutar" quando entra outra)
let currentBassSource = null;

/**
 * Toca uma nota de baixo (num√©rica 1..43 ou 'x')
 * com dura√ß√£o em segundos.
 * Se outra nota estava tocando, ela √© parada (mute).
 */
async function playBassNote(nota, when, dur) {
  await ensureAudioCtx();

  // sempre para a nota anterior se existir
  if (currentBassSource) {
    try { currentBassSource.stop(when); } catch(e) {}
    currentBassSource = null;
  }

  let url;
  if (nota === 'x') {
    url = BASS_SAMPLES['x']; // ghost note
  } else {
    // aqui assumo que seus arquivos s√£o numerados: 1.mp3, 2.mp3, ...
    // ajuste o caminho se for "1E.mp3" ou similar
    url = `assets/bass-notas/${nota}.mp3`;
  }

  const buf = await loadBuffer(url);
  const src = audioCtx.createBufferSource();
  src.buffer = buf;
  src.connect(bassGain);
  src.start(when);
  // garante que termina antes da pr√≥xima
  src.stop(when + dur * 0.98);
  currentBassSource = src;
}

/**
 * Toca um som de bateria (token DRUMS) em certo instante.
 */
async function playDrumHit(token, when) {
  await ensureAudioCtx();
  const fileKey = DRUMS[token];
  if (!fileKey) return;
  const url = `assets/bateria/${fileKey}.mp3`;
  const buf = await loadBuffer(url);
  const src = audioCtx.createBufferSource();
  src.buffer = buf;
  src.connect(drumGain);
  src.start(when);
}

/* ============================================================
 *  SEQU√äNCIAS DE NOTAS
 * ============================================================ */

let baixoSeq = [];   // ex.: [1,4,6,'x',9,...]
let bateriaSeq = []; // ex.: ['bch', '-', 'cch', ...]
let passoDuracao = 0; // em segundos

function gerarPlaybackAleatorio() {
  const groove = ALL_GROOVES[Math.floor(Math.random() * ALL_GROOVES.length)];
  const drumTokens = groove.drumPattern[0].trim().split(/\s+/);
  const bassTokens = groove.bassRhythm[0].trim().split(/\s+/);

  // garantir mesmo tamanho
  const maxLen = Math.max(drumTokens.length, bassTokens.length);

  baixoSeq = [];
  bateriaSeq = [];

  for (let i = 0; i < maxLen; i++) {
    const bt = bassTokens[i] || '-';
    const dt = drumTokens[i] || '-';

    // baixo
    if (bt === 'bo') {
      // escolhe um pitch aleat√≥rio e converte para n√∫mero 1..24
      const pitch = PITCHES[Math.floor(Math.random() * PITCHES.length)];
      const octaveUp = Math.random() < 0.35; // de vez em quando sobe 1 oitava
      const num = pitchToNumeric(pitch, octaveUp);
      baixoSeq.push(num);
    } else if (bt === 'x') {
      baixoSeq.push('x'); // ghost note
    } else {
      baixoSeq.push('x'); // sil√™ncio
    }

    // bateria
    if (dt === '-' || !dt) {
      bateriaSeq.push('-');
    } else {
      bateriaSeq.push(dt);
    }
  }
}

/**
 * L√™ a string do campo manualBassSeq e monta baixoSeq.
 * Bateria manual, por enquanto, √© um padr√£o fixo de bumbo/caixa/chimbal.
 */
function lerComposicaoManual() {
  const inputStr = document.getElementById('manualBassSeq').value.trim();
  baixoSeq = [];
  if (!inputStr) return;
  const tokens = inputStr.split(/\s+/);
  for (const tk of tokens) {
    if (tk.toLowerCase() === 'x') {
      baixoSeq.push('x');
    } else {
      const n = parseInt(tk, 10);
      if (!isNaN(n) && n >= 1 && n <= 43) {
        baixoSeq.push(n);
      }
    }
  }

  // bateria: pattern simples do comprimento de baixoSeq
  bateriaSeq = [];
  for (let i = 0; i < baixoSeq.length; i++) {
    const pos = i % 8;
    if (pos === 0) bateriaSeq.push('bch');     // bumbo+chimbal
    else if (pos === 4) bateriaSeq.push('cch'); // caixa+chimbal
    else bateriaSeq.push('ch');                // s√≥ chimbal
  }
}

/* ============================================================
 *  ANIMA√á√ÉO DA BAIXISTA
 * ============================================================ */

const pernasLayer = document.getElementById('pernasLayer');
const troncoLayer = document.getElementById('troncoLayer');
const cabecaLayer = document.getElementById('cabecaLayer');
const antebracoLayer = document.getElementById('antebracoLayer');
const bracoDireitoLayer = document.getElementById('bracoDireitoLayer');
const animacaoInner = document.getElementById('animacaoInner');
const animInfo = document.getElementById('animInfo');

// estados de anima√ß√£o
let headFrame = 1;
const HEAD_MAX = 100; // voc√™ tem 809, mas 100 j√° d√° fluidez; ajuste se quiser
let globalSwingPhase = 0;

// bra√ßo direito ‚Äì 5 frames por nota
const RIGHT_ARM_FRAMES = 5;

// anima√ß√£o cont√≠nua (cabe√ßa + balan√ßo do corpo)
function loopAnimacaoLivre(timestamp) {
  requestAnimationFrame(loopAnimacaoLivre);

  // Balan√ßo suave
  globalSwingPhase += 0.02;
  const angle = Math.sin(globalSwingPhase) * 1.5; // graus
  animacaoInner.style.transform = `rotate(${angle}deg)`;

  // Cabe√ßa loop
  headFrame++;
  if (headFrame > HEAD_MAX) headFrame = 1;
  const headStr = headFrame.toString().padStart(4, '0');
  cabecaLayer.src = `animacao/cabeca/cabeca${headStr}.png`;
}
requestAnimationFrame(loopAnimacaoLivre);

/**
 * Escolhe a pasta de tronco/baixo para a transi√ß√£o
 * notaAtual -> proximaNota.
 *
 * Por enquanto retorna sempre "Pasta_1F" para simplificar.
 * Depois d√° pra implementar as regras:
 *  - Sol (E) -> L√° (G) usa Pasta_1F
 *  - D√≥ (G) -> D√≥# (G) usa Pasta_3G
 *  etc.
 */
function escolherPastaParaTransicao(notaAtual, proximaNota) {
  return "Pasta_1F";
}

/**
 * Atualiza a imagem de tronco+baixo para uma nota num√©rica.
 */
function atualizarTroncoParaNota(indexNota, idxSeq) {
  if (typeof indexNota !== 'number') return;
  const prox = baixoSeq[(idxSeq + 1) % baixoSeq.length] ?? null;
  const pasta = escolherPastaParaTransicao(indexNota, prox);
  // nome de arquivo: 1E.png, 2F.png, 3FS.png, ...
  // aqui assumo que o arquivo √© "N.png" (sem a letra),
  // se for "1E.png", basta trocar para `${indexNota}E.png` etc.
  troncoLayer.src = `animacao/tronco_baixo/${pasta}/${indexNota}.png`;
}

/**
 * Atualiza antebra√ßo (bra√ßo grande) pela corda.
 */
function atualizarAntebracoParaNota(indexNota) {
  if (typeof indexNota !== 'number') {
    return;
  }
  // heur√≠stica simples: 1‚Äì5 = corda E, 6‚Äì11 = A, 12‚Äì17 = D, 18+ = G
  let corda = 'E';
  if (indexNota >= 6 && indexNota <= 11) corda = 'A';
  else if (indexNota >= 12 && indexNota <= 17) corda = 'D';
  else if (indexNota >= 18) corda = 'G';

  antebracoLayer.src = `animacao/antebraco/antebraco${corda}.png`;
}

/**
 * Anima o bra√ßo direito (5 frames por nota) de acordo com a corda.
 */
function animarBracoDireito(indexNota, startTime, dur) {
  if (typeof indexNota !== 'number') {
    // ghost note / pausa pode usar corda E padr√£o
    indexNota = 1;
  }
  let corda = 'E';
  if (indexNota >= 6 && indexNota <= 11) corda = 'A';
  else if (indexNota >= 12 && indexNota <= 17) corda = 'D';
  else if (indexNota >= 18) corda = 'G';

  const frames = [];
  for (let i = 1; i <= RIGHT_ARM_FRAMES; i++) {
    frames.push(`animacao/braco_direito/Corda_${corda}${i}.png`);
  }

  const frameDur = (dur * 0.9) / RIGHT_ARM_FRAMES;
  frames.forEach((src, idx) => {
    const when = startTime + idx * frameDur;
    setTimeout(() => {
      bracoDireitoLayer.src = src;
    }, (when - audioCtx.currentTime) * 1000);
  });
}

/* ============================================================
 *  ENGINE DE PLAYBACK (BAIXO + BATERIA + ANIMA√á√ÉO)
 * ============================================================ */

let isPlaying = false;
let playStartTime = 0;
let scheduledTimeout = null;

const statusLabel = document.getElementById('statusLabel');
const countdownOverlay = document.getElementById('countdownOverlay');
const countdownNumber = document.getElementById('countdownNumber');

function atualizarStatus(texto) {
  statusLabel.textContent = texto;
}

/**
 * Contagem regressiva 3-2-1 antes do playback.
 */
function iniciarContagemRegressiva(callback) {
  countdownOverlay.style.display = 'flex';
  let count = 3;
  countdownNumber.textContent = count;

  const iv = setInterval(() => {
    count--;
    if (count <= 0) {
      clearInterval(iv);
      countdownOverlay.style.display = 'none';
      callback();
    } else {
      countdownNumber.textContent = count;
    }
  }, 1000);
}

/**
 * Pr√©-processa a sequ√™ncia para:
 *  - escolher pastas de tronco por passo
 *  - (futuramente) carregar imagens espec√≠ficas
 * Por enquanto a escolha de pasta √© feita on the fly, mas deixo
 * a fun√ß√£o preparada para evoluir.
 */
function preprocessarAnimacao() {
  // Aqui, s√≥ atualizamos o texto de debug
  animInfo.textContent = `Sequ√™ncia de ${baixoSeq.length} notas preparada.`;
}

/**
 * Agenda todo o playback (baixo + bateria + anima√ß√£o).
 */
async function iniciarPlayback() {
  if (!baixoSeq.length) {
    alert('N√£o h√° notas de baixo para tocar.');
    return;
  }
  await ensureAudioCtx();

  isPlaying = true;
  playStartTime = audioCtx.currentTime + 0.1;

  const bpm = parseInt(document.getElementById('bpmInput').value, 10) || 100;
  // passo = colcheia (por exemplo) ‚Äì ajuste como preferir
  passoDuracao = 60 / bpm / 2;

  atualizarStatus('Tocando‚Ä¶');

  const totalPassos = baixoSeq.length;
  const durTotal = totalPassos * passoDuracao;

  for (let i = 0; i < totalPassos; i++) {
    const t = playStartTime + i * passoDuracao;
    const nota = baixoSeq[i];
    const drumToken = bateriaSeq[i];

    // √°udio de baixo
    playBassNote(nota, t, passoDuracao);

    // √°udio de bateria
    if (drumToken && drumToken !== '-') {
      playDrumHit(drumToken, t);
    }

    // anima√ß√£o de tronco/antebra√ßo/bra√ßo direito
    atualizarTroncoParaNota(nota, i);
    atualizarAntebracoParaNota(nota);
    animarBracoDireito(nota, t, passoDuracao);
  }

  // ap√≥s terminar
  if (scheduledTimeout) clearTimeout(scheduledTimeout);
  scheduledTimeout = setTimeout(() => {
    isPlaying = false;
    atualizarStatus('Parado');
    animInfo.textContent = 'Playback conclu√≠do.';
  }, (durTotal + 0.5) * 1000);
}

function stopPlayback() {
  isPlaying = false;
  if (audioCtx) {
    try {
      audioCtx.close();
    } catch(e) {}
    audioCtx = null;
  }
  if (scheduledTimeout) clearTimeout(scheduledTimeout);
  scheduledTimeout = null;
  currentBassSource = null;
  atualizarStatus('Parado');
  animInfo.textContent = 'Parado.';
}

function pausePlayback() {
  if (!audioCtx) return;
  if (audioCtx.state === 'running') {
    audioCtx.suspend();
    atualizarStatus('Pausado');
  } else if (audioCtx.state === 'suspended') {
    audioCtx.resume();
    atualizarStatus('Tocando‚Ä¶');
  }
}

/* ============================================================
 *  UI ‚Äì EVENTOS DOS BOT√ïES E SLIDERS
 * ============================================================ */

const btnPlayRandom = document.getElementById('btnPlayRandom');
const btnPlayManual = document.getElementById('btnPlayManual');
const btnPause = document.getElementById('btnPause');
const btnStop = document.getElementById('btnStop');
const muteBassBtn = document.getElementById('muteBass');
const muteDrumsBtn = document.getElementById('muteDrums');
const volBassSlider = document.getElementById('volBass');
const volDrumsSlider = document.getElementById('volDrums');
const volBassLabel = document.getElementById('volBassLabel');
const volDrumsLabel = document.getElementById('volDrumsLabel');

function atualizarVolumes() {
  if (!bassGain || !drumGain) return;
  const vb = parseFloat(volBassSlider.value);
  const vd = parseFloat(volDrumsSlider.value);
  bassGain.gain.value = vb;
  drumGain.gain.value = vd;
  volBassLabel.textContent = Math.round(vb * 100) + '%';
  volDrumsLabel.textContent = Math.round(vd * 100) + '%';
}

volBassSlider.addEventListener('input', atualizarVolumes);
volDrumsSlider.addEventListener('input', atualizarVolumes);

muteBassBtn.addEventListener('click', () => {
  const mute = muteBassBtn.getAttribute('data-mute') === 'off';
  muteBassBtn.setAttribute('data-mute', mute ? 'on' : 'off');
  muteBassBtn.textContent = mute ? 'üé∏ Baixo OFF' : 'üé∏ Baixo ON';
  if (bassGain) bassGain.gain.value = mute ? 0 : parseFloat(volBassSlider.value);
});

muteDrumsBtn.addEventListener('click', () => {
  const mute = muteDrumsBtn.getAttribute('data-mute') === 'off';
  muteDrumsBtn.setAttribute('data-mute', mute ? 'on' : 'off');
  muteDrumsBtn.textContent = mute ? 'ü•Å Bateria OFF' : 'ü•Å Bateria ON';
  if (drumGain) drumGain.gain.value = mute ? 0 : parseFloat(volDrumsSlider.value);
});

btnPlayRandom.addEventListener('click', () => {
  if (isPlaying) return;
  gerarPlaybackAleatorio();
  preprocessarAnimacao();
  iniciarContagemRegressiva(() => {
    iniciarPlayback().catch(console.error);
  });
});

btnPlayManual.addEventListener('click', () => {
  if (isPlaying) return;
  lerComposicaoManual();
  if (!baixoSeq.length) {
    alert('Digite ao menos uma nota na composi√ß√£o manual.');
    return;
  }
  preprocessarAnimacao();
  iniciarContagemRegressiva(() => {
    iniciarPlayback().catch(console.error);
  });
});

btnStop.addEventListener('click', () => {
  stopPlayback();
});

btnPause.addEventListener('click', () => {
  pausePlayback();
});

</script>
</body>
</html>
