<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Jam On ‚Äì Playback Aleat√≥rio</title>
  <style>
    /* === ESTILOS GERAIS (DESKTOP) === */
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      background: #121212;
      color: #e0e0e0;
      margin: 0;
      padding: 20px;
    }
    header {
      text-align: center;
      margin-bottom: 20px;
    }
    h1 {
      color: #5eead4;
      font-size: 1.8em;
      margin: 0;
    }
    .pill {
      display: inline-block;
      background: #333;
      color: #aaa;
      font-size: 0.75em;
      padding: 4px 10px;
      border-radius: 12px;
    }
    .card {
      max-width: 800px;
      margin: 0 auto;
      background: #1e1e1e;
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      overflow: hidden; /* Mant√©m conte√∫do dentro das bordas arredondadas */
      padding: 20px;
      text-align: left;
    }
    .chord-display {
      text-align: center;
      margin: 20px 0;
    }
    .chord-name {
      font-size: 3em;
      color: #5eead4;
      margin: 0;
      font-weight: bold;
    }
    #chordTimer {
      font-size: 1.1em;
      color: #aaa;
    }
    #chordProgression {
      margin-top: 12px;
      font-family: monospace;
      font-size: 1.1em;
      white-space: nowrap;
      overflow-x: auto;
      padding: 8px 0;
      scrollbar-width: thin; /* Firefox */
    }
    /* Estiliza√ß√£o da barra de rolagem */
    #chordProgression::-webkit-scrollbar {
        height: 6px;
    }
    #chordProgression::-webkit-scrollbar-thumb {
        background: #444; 
        border-radius: 3px;
    }
    
    .chord-item {
      display: inline-block;
      padding: 6px 10px;
      margin: 0 4px;
      border-radius: 6px;
      background: #333;
      transition: background 0.3s;
    }
    .chord-item.current {
      background: #5eead4;
      color: #121212;
      font-weight: bold;
    }
    .controls {
      display: grid;
      gap: 15px;
      margin-bottom: 20px;
    }
    .btn-row {
      display: flex;
      justify-content: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    button {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      font-size: 1em;
      transition: opacity 0.2s;
      /* Previne sele√ß√£o de texto no bot√£o em mobile */
      -webkit-user-select: none; 
      user-select: none;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button.primary {
      background: #5eead4;
      color: #121212;
    }
    button.danger {
      background: #f44336;
      color: white;
    }
    button:hover:not(:disabled) {
      opacity: 0.9;
    }
    /* Click effect active */
    button:active:not(:disabled) {
        transform: scale(0.98);
    }

    .mute-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      margin: 10px 0;
    }
    .mute-buttons button {
      padding: 8px 14px;
      font-size: 0.9em;
    }
    .mute-buttons button.muted {
      opacity: 0.5;
    }
    .row {
      display: flex;
      align-items: center;
      gap: 10px;
      justify-content: center;
    }
    .row label {
      width: 100px;
      text-align: right;
      color: #ccc;
    }
    input[type="number"], select {
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #2a2a2a;
      color: #fff;
      width: 90px;
    }
    select {
      width: auto;
      min-width: 120px;
    }
    .slider-row {
      display: flex;
      align-items: center;
      gap: 10px;
      justify-content: center;
    }
    .slider-row label {
      width: 100px; /* Aumentado um pouco para caber nomes maiores */
      text-align: right;
      font-size: 0.9em;
    }
    input[type="range"] {
      width: 180px;
      accent-color: #5eead4;
      height: 20px; /* Facilita o toque */
    }
    .slider-value {
      width: 40px;
      text-align: left;
      font-size: 0.9em;
      color: #aaa;
    }
    .panel {
      margin-top: 20px;
    }
    .panel h3 {
      color: #5eead4;
      margin-top: 0;
    }
    .melody-panel {
      margin-top: 20px;
      /* Importante para mobile: */
      overflow-x: auto; 
      -webkit-overflow-scrolling: touch;
      padding-bottom: 10px;
    }
    .melody-toolbar {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 10px;
    }
    .melody-block {
      border: 1px solid #444;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 12px;
      background: #222;
      min-width: 600px; /* Garante que a tabela n√£o fique espremida */
    }
    .melody-caption {
      font-size: 0.9em;
      color: #ccc;
      margin-bottom: 6px;
    }
    .melody-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85em;
    }
    .melody-table th, .melody-table td {
      border: 1px solid #555;
      padding: 2px;
    }
    .melody-table input {
      width: 100%;
      padding: 4px;
      text-align: center;
      background: #333;
      border: 1px solid #555;
      color: white;
      border-radius: 4px;
      box-sizing: border-box; /* Garante que o padding n√£o aumente a largura */
    }
    .line-label {
      font-size: 0.8em;
      color: #aaa;
    }
    .instructions {
      font-size: 0.85em;
      color: #aaa;
      margin-top: 8px;
      text-align: center;
    }

    /* === OTIMIZA√á√ÉO PESADA PARA CELULAR === */
    @media (max-width: 768px) {
      body {
        padding: 10px 5px; /* Menos padding nas bordas da tela */
      }
      .card {
        padding: 15px 12px;
        border-radius: 12px;
        width: 100%;
        box-sizing: border-box;
      }
      h1 {
        font-size: 1.5em;
      }
      .chord-name {
        font-size: 2.5em; /* Um pouco menor para n√£o quebrar */
      }

      /* Bot√µes de A√ß√£o Principais (Play/Stop) */
      .btn-row {
        flex-direction: column; /* Empilha os bot√µes */
        width: 100%;
      }
      .btn-row button {
        width: 100%; /* Bot√£o largura total */
        padding: 15px; /* √Årea de toque maior */
        font-size: 1.1em;
      }

      /* Bot√µes de Mute */
      .mute-buttons {
        gap: 8px;
      }
      .mute-buttons button {
        flex: 1 1 45%; /* Ocupa quase metade da tela cada bot√£o */
        margin: 0;
        padding: 12px;
      }

      /* Linhas de Configura√ß√£o (BPM, Tom, etc) */
      .row {
        flex-wrap: wrap; /* Permite quebrar linha */
        justify-content: space-between;
        margin-bottom: 10px;
      }
      .row label {
        text-align: left;
        width: auto;
        font-size: 1em;
        margin-bottom: 4px;
      }
      input[type="number"], select {
        flex: 1; /* Ocupa o espa√ßo restante */
        width: auto;
        min-width: 100px;
        height: 45px; /* Altura boa para o dedo */
        font-size: 16px; /* Evita zoom autom√°tico no iOS */
      }

      /* Sliders de Volume */
      .slider-row {
        flex-wrap: wrap; /* Quebra linha */
        margin-bottom: 15px;
        background: #252525; /* Fundo sutil para separar */
        padding: 10px;
        border-radius: 8px;
      }
      .slider-row label {
        width: 100%; /* Label ocupa linha inteira em cima */
        text-align: left;
        margin-bottom: 8px;
        font-weight: bold;
        color: #fff;
      }
      input[type="range"] {
        flex: 1; /* Slider ocupa o resto */
        width: auto;
        height: 30px; /* Slider mais grosso */
      }
      .slider-value {
        width: 45px;
        text-align: center;
        background: #333;
        border-radius: 4px;
        padding: 4px 0;
      }

      /* Tabela de Melodia */
      .melody-table input {
        height: 44px; /* Altura boa para toque */
        font-size: 16px; /* Evita zoom iOS */
        min-width: 40px;
      }
      
      /* Bot√£o Gerar Progress√£o */
      #btnGenerateChordProgression {
        width: 100%;
        padding: 15px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Jam On ‚Äì Playback Aleat√≥rio</h1>
    <div class="pill">Cada pulso do BPM = sem√≠nima</div>
  </header>
  <div class="chord-display">
    <h2 class="chord-name" id="currentChord">‚Äî</h2>
    <div id="chordTimer">‚Äî</div>
    <div id="chordProgression"></div>
  </div>
  <div class="card">
    <div class="controls">
      <div class="btn-row">
        <button id="btnPlay" class="primary">‚ñ∂ Play</button>
        <button id="btnPause">‚è∏ Pause</button>
        <button id="btnStop" class="danger">‚èπ Stop</button>
        <button id="btnPrevious" class="primary">‚èÆ Voltar</button>
        <button id="btnSaveWAV" class="primary">üíæ Salvar como WAV</button>
        <button id="btnOpenManual" class="primary">üéõÔ∏è Abrir Composi√ß√£o Manual</button>
      </div>
      
      <div class="mute-buttons">
        <button id="muteBass" data-mute="off">üé∏ Baixo</button>
        <button id="muteDrums" data-mute="off">ü•Å Bateria</button>
        <button id="muteClean" data-mute="off">üîá Limpa</button>
        <button id="muteDist" data-mute="off">üîá Distor√ß√£o</button>
        <button id="mutePianoString" data-mute="off">üîá Piano</button>
        <button id="muteEcho" data-mute="off">üîá Guitarra Echo</button>
        <button id="muteCleanPicked" data-mute="off">üîá Guitarra Dedilhada</button>
        <button id="muteOrgan" data-mute="off">üîá √ìrg√£o</button>
      </div>

      <div class="row">
        <label>Assinatura</label>
        <select id="meter">
          <option value="auto" selected>aleat√≥ria</option>
          <option>2/4</option>
          <option>3/4</option>
          <option>4/4</option>
          <option>5/4</option>
          <option>6/4</option>
          <option>7/4</option>
        </select>
      </div>
      <div class="row">
        <label>BPM</label>
        <input type="number" id="bpm" min="40" max="220" value="100">
      </div>
      <div class="row">
        <label>Estilo</label>
        <select id="styleSelect">
          <option value="auto" selected>aleat√≥rio</option>
        </select>
      </div>
      <div class="row">
        <label>Tonalidade</label>
        <select id="keySelect">
          <option value="auto" selected>aleat√≥ria</option>
        </select>
      </div>
      <div class="row">
        <label>Qualidade</label>
        <select id="qualitySelect">
          <option value="maj" selected>Maior</option>
          <option value="min">Menor</option>
        </select>
      </div>
      <div class="row">
        <label>Melodia</label>
        <select id="melodyInstrument">
          <option value="dist">Guitarra Distorcida</option>
          <option value="piano">Piano/String</option>
          <option value="baixo">Baixo</option>
          <option value="sax">Sax</option>
          <option value="acordeon">Acordeon</option>
          <option value="sinos">Sinos</option>
          <option value="violao_aco">Viol√£o A√ßo</option>
          <option value="violao_nylon">Viol√£o Nylon</option>
          <option value="cordas">Cordas</option>
        </select>
      </div>

      <h3 style="color: #5eead4; margin: 15px 0 10px;">Controle de Volume</h3>
      <div class="slider-row">
        <label>Baixo</label>
        <input type="range" id="volBass" min="0" max="1" step="0.01" value="0.45">
        <span class="slider-value" id="volBassLabel">45%</span>
      </div>
      <div class="slider-row">
        <label>Bateria</label>
        <input type="range" id="volDrums" min="0" max="1" step="0.01" value="0.6">
        <span class="slider-value" id="volDrumsLabel">60%</span>
      </div>
      <div class="slider-row">
        <label>Limpa</label>
        <input type="range" id="volClean" min="0" max="1" step="0.01" value="0.45">
        <span class="slider-value" id="volCleanLabel">45%</span>
      </div>
      <div class="slider-row">
        <label>Distorcida</label>
        <input type="range" id="volDist" min="0" max="1" step="0.01" value="0.35">
        <span class="slider-value" id="volDistLabel">35%</span>
      </div>
      <div class="slider-row">
        <label>Piano</label>
        <input type="range" id="volPianoString" min="0" max="1" step="0.01" value="0.50">
        <span class="slider-value" id="volPianoStringLabel">50%</span>
      </div>
      <div class="slider-row">
        <label>Guitarra Echo</label>
        <input type="range" id="volEcho" min="0" max="1" step="0.01" value="0.50">
        <span class="slider-value" id="volEchoLabel">50%</span>
      </div>
      <div class="slider-row">
        <label>Guitarra Dedilhada</label>
        <input type="range" id="volCleanPicked" min="0" max="1" step="0.01" value="0.50">
        <span class="slider-value" id="volCleanPickedLabel">50%</span>
      </div>
      <div class="slider-row">
        <label>√ìrg√£o</label>
        <input type="range" id="volOrgan" min="0" max="1" step="0.01" value="0.50">
        <span class="slider-value" id="volOrganLabel">50%</span>
      </div>
      <div class="slider-row">
        <label>Melodia</label>
        <input type="range" id="volMelody" min="0" max="1" step="0.01" value="0.50">
        <span class="slider-value" id="volMelodyLabel">50%</span>
      </div>
    </div>
    
    <div class="panel">
      <h3>Estado Atual</h3>
      <div class="mono" id="state">Parado</div>
    </div>
    
    <div class="panel melody-panel">
      <h3>üé∏ Melodia Adaptativa</h3>
      <div class="melody-toolbar">
        <button id="btnMelodyAdd" class="primary">‚ûï Adicionar Bloco</button>
        <button id="btnMelodyClear" class="danger">üßπ Limpar Blocos</button>
      </div>
      <div class="instructions">
        Digite n√∫meros (1-49) para notas, "x" para pausa, ou deixe vazio.
      </div>
      <div id="melodyBlocks"></div>
    </div>
  </div>

  <div class="panel" style="margin-top: 24px; padding-top: 16px; border-top: 1px solid #333;">
    <h3 style="color: #5eead4; margin-top: 0;">üé≤ Gerador de Progress√£o Aleat√≥ria</h3>
    <p style="color: #aaa; margin-bottom: 16px; font-size: 0.95em;">
      Clique no bot√£o abaixo para gerar uma progress√£o de acordes aleat√≥ria.
    </p>
    <div style="text-align: center; margin-bottom: 16px;">
      <button id="btnGenerateChordProgression" class="primary">Gerar Progress√£o Aleat√≥ria</button>
    </div>
    <div id="generatedChordProgression" style="
      text-align: center;
      font-size: 1.3em;
      font-weight: bold;
      color: #5eead4;
      min-height: 1.5em;
      font-family: monospace;
      background: #2a2a2a;
      padding: 12px;
      border-radius: 8px;
    ">‚Äî</div>
    <div id="generatedChordProgressionRoman" style="
      text-align: center;
      font-size: 0.85em;
      color: #777;
      margin-top: 6px;
    "></div>
  </div>

 <script>
    // ===== FUN√á√ïES PRINCIPAIS =====
    function transposeDown3Semitones(note) {
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const index = notes.indexOf(note);
        if (index === -1) return note;
        return notes[(index - 3 + 12) % 12];
    }

    function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    // ===== ELEMENTOS DA INTERFACE =====
    const ui = {
        play: document.getElementById('btnPlay'),
        pause: document.getElementById('btnPause'),
        stop: document.getElementById('btnStop'),
        previous: document.getElementById('btnPrevious'),
        muteBass: document.getElementById('muteBass'),
        muteDrums: document.getElementById('muteDrums'),
        muteClean: document.getElementById('muteClean'),
        muteDist: document.getElementById('muteDist'),
        mutePianoString: document.getElementById('mutePianoString'),
        muteEcho: document.getElementById('muteEcho'),
        muteCleanPicked: document.getElementById('muteCleanPicked'),
        muteOrgan: document.getElementById('muteOrgan'),
        bpm: document.getElementById('bpm'),
        meter: document.getElementById('meter'),
        styleSelect: document.getElementById('styleSelect'),
        keySelect: document.getElementById('keySelect'),
        qualitySelect: document.getElementById('qualitySelect'),
        currentChord: document.getElementById('currentChord'),
        chordTimer: document.getElementById('chordTimer'),
        volPianoString: document.getElementById('volPianoString'),
        volPianoStringLabel: document.getElementById('volPianoStringLabel'),
        volEcho: document.getElementById('volEcho'),
        volEchoLabel: document.getElementById('volEchoLabel'),
        volCleanPicked: document.getElementById('volCleanPicked'),
        volCleanPickedLabel: document.getElementById('volCleanPickedLabel'),
        volOrgan: document.getElementById('volOrgan'),
        volOrganLabel: document.getElementById('volOrganLabel'),
        volBass: document.getElementById('volBass'),
        volDrums: document.getElementById('volDrums'),
        volClean: document.getElementById('volClean'),
        volDist: document.getElementById('volDist'),
        volBassLabel: document.getElementById('volBassLabel'),
        volDrumsLabel: document.getElementById('volDrumsLabel'),
        volCleanLabel: document.getElementById('volCleanLabel'),
        volDistLabel: document.getElementById('volDistLabel'),
        volMelody: document.getElementById('volMelody'),
        volMelodyLabel: document.getElementById('volMelodyLabel'),
        melodyBlocks: document.getElementById('melodyBlocks'),
        btnMelodyAdd: document.getElementById('btnMelodyAdd'),
        btnMelodyClear: document.getElementById('btnMelodyClear'),
        melodyInstrument: document.getElementById('melodyInstrument'),
        // Picker elements removed
        btnSaveWAV: document.getElementById('btnSaveWAV'),
        chordProgression: document.getElementById('chordProgression'),
        btnOpenManual: document.getElementById('btnOpenManual')
    };

    function initializeStyleAndKeySelectors() {
        const uniqueStyles = [...new Set(ALL_GROOVES.map(g => g.name))].sort();
        uniqueStyles.forEach(styleName => {
            const opt = document.createElement('option');
            opt.value = styleName;
            opt.textContent = styleName;
            ui.styleSelect.appendChild(opt);
        });
        const uniqueKeys = [...new Set(PITCHES)].sort();
        uniqueKeys.forEach(keyName => {
            const opt = document.createElement('option');
            opt.value = keyName; 
            opt.textContent = keyName.replace('S', '#');
            ui.keySelect.appendChild(opt);
        });
    }

    const audio = {
        ctx: null, master: null, mix: null,
        drumGain: null, bassGain: null, cleanGain: null, distGain: null, melodyGain: null, pianoStringGain: null,
        echoGain: null, cleanPickedGain: null, organGain: null
    };

    const bufferCache = new Map();
    let performanceStats = { scheduledNotes: 0, bufferMisses: 0, lateSchedules: 0, lastReport: 0 };

    async function loadBufferWithCache(url) {
        if (bufferCache.has(url)) return bufferCache.get(url);
        try {
            const buffer = await loadBuffer(url);
            if (buffer) {
                bufferCache.set(url, buffer);
                if (bufferCache.size > 50) {
                    const firstKey = bufferCache.keys().next().value;
                    bufferCache.delete(firstKey);
                }
            }
            return buffer;
        } catch (e) {
            console.warn(`Erro ao carregar: ${url}`);
            return null;
        }
    }

    function monitorPerformance() {
        performanceStats.scheduledNotes++;
        if (Date.now() - performanceStats.lastReport > 10000) {
            console.log('üìä Performance Stats:', { ...performanceStats, bufferCacheSize: bufferCache.size });
            performanceStats.scheduledNotes = 0; performanceStats.bufferMisses = 0;
            performanceStats.lateSchedules = 0; performanceStats.lastReport = Date.now();
        }
    }

    const PITCHES = ['A','AS','B','C','CS','D','DS','E','F','FS','G','GS'];
    const DEGREE_TO_ROOT = { 1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11 };
    const CHORD_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    const DRUMS = {
        bu: 'bumbo', ca: 'caixa', ch: 'chimbal', ba: 'bumbo-ataque',
        cch: 'caixa-chimbal', co: 'conducao', bco: 'bumbo-conducao', cco: 'caixa-conducao',
        to1: 'tom-1', to2: 'tom-2', su: 'surdo', bch: 'bumbo-chimbal'
    };

    const BASS_SAMPLES = {};
    for (const p of PITCHES) {
        BASS_SAMPLES[p] = `assets/bass-${p}.mp3`;
        if (p.endsWith('S')) {
            const base = p.replace('S', '');
            BASS_SAMPLES[base + '8S'] = `assets/bass-${base}8S.mp3`;
        } else {
            BASS_SAMPLES[p + '8'] = `assets/bass-${p}8.mp3`;
        }
    }
    BASS_SAMPLES['x'] = 'assets/bass-muted.mp3';

    const STYLE_PROGRESSIONS = {
        Rock: [[1,4,5,1], [1,5,6,4], [6,4,1,5]],
        Rock2: [[4,5,1,5], [5,4,1,4], [7,4,1,1]],
        Rock3: [[1,4,5,1], [1,3,4,5]],
        Rock4: [[6,4,1,5,1,5,4,5], [1,4,5,1,4,5,4,5], [1,5,6,4,1,5,6,7]],
        Rock5: [[1,5,7,4], [1,4,5,6], [1,5,6,4]],
        Rock6: [[1,5,6,4], [1,4,5,1], [1,5,6,7]],
        Rock7: [[2,3,5,1], [1,4,7,1], [1,5,3,4]],
        Rock_Progressivo: [[4,5,1,1,4,5,7], [1,4,1,4,5,6,5], [1,4,5,6,3,5,4]],
        Rock_Progressivo2: [[1,4,5,1,5], [4,5,3,1,3,1,4,5,7,5], [1,4,1,4,5]],
        Rock_Progressivo3: [[1,4,5,1,5,7], [1,3,4,5,2,5]],
        Rock_Progressivo4: [[4,5,1,1,4,5,7,5], [1,4,1,4,5,6,5,7], [1,4,5,6,3,5,4,5]],
        Rock_Progressivo5: [[4,5,1,1,4,5,7], [1,4,1,4,5,6,5], [1,4,5,6,3,5,4]],
        Rock_Progressivo6: [[1,4,5,6,3,5], [1,4,1,4,5,6,5]],
        Rock_Progressivo7: [[4,5,1,1], [1,4,5,1]],
        Blues: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]],
        Blues2: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]],
        Blues3: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,7]],
        Blues4: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]],
        Blues5: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,7]],
        Blues6: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]],
        Blues7: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]],
        Forr√≥: [[1,5,1,5,4,5,4,5]],
        Samba: [[2,5,1,1], [1,4,5,1]],
        Metal: [[1, 3, 5, 6, 1, 2, 3, 4], [1, 3, 4, 5], [2, 5, 1, 5]],
        Metal2: [[1, 3, 5, 4, 1, 2, 3, 4], [1, 3, 4, 5], [2, 5, 1, 5]],
        Metal3: [[1, 3, 5, 3, 1, 2, 4, 5], [1, 3, 4, 5], [2, 5, 1, 5]],
        Jazz: [[1,2,5,1], [2,5,1,4], [3,6,2,5]]
    };

    const ALL_GROOVES = [
        { name: "Rock", meter: "4/4", drumPattern: ["bch - ch - cch - ch - bch - ch - cch - ch bu"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8] },
        { name: "Rock2", meter: "4/4", drumPattern: ["bch - ch - cch - ch - bch - ch - cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 1, 1, 5] },
        { name: "Rock3", meter: "4/4", drumPattern: ["bch - ch bu cch bu ch - bch - ch - cch - ch -"], bassRhythm: ["bo - - bo - - bo - bo - bo - bo - bo -"], bassScale: [1, 1, 1, 1] },
        { name: "Rock4", meter: "4/4", drumPattern: ["ba - co - cco - co - bco - co - cco bu bco bu"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 7, 8, 7, 5, 3] },
        { name: "Rock5", meter: "4/4", drumPattern: ["bch ch ch ch cch ch ch ch bch ch ch ch cch ch ch -"], bassRhythm: ["bo - - bo - - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 1, 5] },
        { name: "Rock6", meter: "4/4", drumPattern: ["bco co co co cco co co co bco co co co cco co co co"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [8, 8, 1, 1] },
        { name: "Rock7", meter: "4/4", drumPattern: ["bch - ch - cch - ch - bch - co - cco - co -"], bassRhythm: ["bo - - bo - - bo - bo - bo - bo - bo -"], bassScale: [1, 1, 1, 1] },
        { name: "Rock_Progressivo", meter: "7/4", drumPattern: ["bch - ch -  cch - ch - bch - ch - cch - ch bu bch - ch - cch - ch - bch - ch bu"], bassRhythm: ["bo - - - - - - - bo - - - - - - bo - - bo bo bo bo bo bo bo bo bo bo"], bassScale: [1, 1, 1, 3, 5, 8, 3, 5, 8, 3, 5, 8, 5] },
        { name: "Rock_Progressivo2", meter: "5/4", drumPattern: ["ba - ch - bch - ch - cch - ch - bch - ch - cch - ch bu"], bassRhythm: ["bo - x x bo - bo - bo - bo - bo - bo -"], bassScale: [1, 1, 1, 1, 3, 5, 8, 1, 3, 5, 8] },
        { name: "Rock_Progressivo3", meter: "6/4", drumPattern: ["ba - - - ch - - bu cch - - - ch - - - bch - - - ch - - -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 1, 1, 3, 1, 1, 1, 3, 5, 5, 5, 1] },
        { name: "Rock_Progressivo4", meter: "4/4", drumPattern: ["ba - ch bu cch - ch - bch - ch bu cch - ch bu"], bassRhythm: ["bo - - bo - - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8] },
        { name: "Rock_Progressivo5", meter: "7/4", drumPattern: ["ba - co - cco - co - bco - co bu cco - co bu bch bu co - cch - ch - bch - ch bu"], bassRhythm: ["bo - - bo bo - - - bo - - bo bo - - bo - - bo bo - - bo bo - - bo bo"], bassScale: [1, 3, 5, 8] },
        { name: "Rock_Progressivo6", meter: "3/4", drumPattern: ["bch - - - ch - - bu cch - - -"], bassRhythm: ["bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8, 8, 8]},
        { name: "Rock_Progressivo7", meter: "4/4", drumPattern: ["bco co cch to1 cch - ch - bch - ch cch bu bu ch bu"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 1, 1, 1] },
        { name: "Blues", meter: "4/4", drumPattern: ["bch - ch ch cch - ch ch bch - ch ch cch - ch ch"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 6, 8, 6, 5, 3] },
        { name: "Blues2", meter: "4/4", drumPattern: ["bch - - - cch - - - bch - - - cch - - -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 6, 8, 6, 5, 3] },
        { name: "Blues3", meter: "4/4", drumPattern: ["bch - - bu cch - ch - ch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 6, 8, 6, 5, 3] },
        { name: "Blues4", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 6, 8, 6, 5, 3] },
        { name: "Blues5", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 6, 8, 6, 5, 3] },
        { name: "Blues6", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 6, 8, 6, 5, 3] },
        { name: "Blues7", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 6, 8, 6, 5, 3] },
        { name: "Forr√≥", meter: "2/4", drumPattern: ["bch - co - ch - ca -"], bassRhythm: ["bo - - - x - - -"], bassScale: [8, 1] },
        { name: "Funk", meter: "4/4", drumPattern: ["bch - ch - cch - ch - bch - ch - cch - ch -"], bassRhythm: ["bo - - - bo - bo x bo x bo x bo - x x"], bassScale: [1,8] },
        { name: "Funk2", meter: "4/4", drumPattern: ["bch - - - cch - - - bch - - - cch - - -"], bassRhythm: ["bo bo bo bo bo x x x bo - x x bo - x x"], bassScale: [1,7,8,1] },
        { name: "Disco", meter: "4/4", drumPattern: ["bu - ch ch bu - ch ch bu - ch ch bu - ch ch"], bassRhythm: ["bo - x x bo - x x bo - x x bo - x x"], bassScale: [1] },
        { name: "Forr√≥4", meter: "2/4", drumPattern: ["bch - co - ch - ca bu"], bassRhythm: ["bo - - - bo - - x"], bassScale: [8, 1] },
        { name: "Metal", meter: "4/4", drumPattern: ["bch bu bch bu cch bu bch bu bch bu bch bu cch bu bch bu"], bassRhythm: ["bo bo bo bo bo bo bo bo bo bo bo bo bo bo bo bo"], guitarRhythm: ["ab ab ab ab so - - - ab - ab - so - - -"] },
        { name: "Metal2", meter: "4/4", drumPattern: ["bch bu bch bu cch bu bch bu cch - ch bu cch bu bch bu"], bassRhythm: ["bo bo bo bo bo bo bo bo bo bo bo bo bo bo bo bo"], guitarRhythm: ["ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab"] },
        { name: "Metal3", meter: "4/4", drumPattern: ["bch bu bch - cch - ch - bch bu ch bu cch - ch -"], bassRhythm: ["bo bo bo - - - - - bo bo - bo - - - -"] },
        { name: "Metal4", meter: "4/4", drumPattern: ["bch bu cch - bu bu cch - bu bu cch - bu bu cch -"], bassRhythm: ["bo bo bo - bo bo bo - bo bo bo - bo bo bo -"], guitarRhythm: ["ab - ab - so - - - ab - ab - so - - -"] },
        { name: "Samba", meter: "2/4", drumPattern: ["bch - ch bu bch - ch bu"], bassRhythm: ["bo - x x bo - - x"], bassScale: [8, 5] },
        { name: "Jazz", meter: "4/4", drumPattern: ["bch co co - co co co ca bch co co - bch co co cch"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: "chromatic" },
    ];

    initializeStyleAndKeySelectors();

    const state = {
        running: false, paused: false, pauseTime: 0, nextNoteTime: 0, meter: '4/4', bpm: 100,
        sixteenthDur: 0.15, stepIndex: 0, buffers: { drums: {}, bass: {}, guitar: {}, melody: {} },
        bassPlan: [], chordPlan: [], signatureTag: '', key: null, keyIdx: 0, quality: 'maj',
        chordProgression: [], chordDurations: [], currentGroove: null, currentChordIndex: 0,
        barsInChord: 0, drumSeq: [], lastBassSource: null, lastBassGainNode: null,
        lastCleanSource: null, lastDistSource: null, lastMelodySource: null, lastMelodyGain: null,
        lastPianoStringSource: null, lastEchoSource: null, lastCleanPickedSource: null, lastOrganSource: null,
        melodyBlocks: [], melodyPlan: [], lastMelodyNote: null, guitarPlan: null, activeInput: null,
        schedulerTimer: null, previousPlaybacks: [], nextPlaybacks: []
    };

    const mute = {
        bass: false, drums: false, clean: true, dist: true, pianoString: true, melody: false,
        echo: true, cleanPicked: true, organ: true
    };

    function meterToBeats(meter) { return Number(meter.split('/')[0]) || 4; }
    let initPromise = null;

    function updateVolume() {
        if (audio.bassGain) audio.bassGain.gain.value = parseFloat(ui.volBass.value);
        if (audio.drumGain) audio.drumGain.gain.value = parseFloat(ui.volDrums.value);
        if (audio.cleanGain) audio.cleanGain.gain.value = parseFloat(ui.volClean.value);
        if (audio.distGain) audio.distGain.gain.value = parseFloat(ui.volDist.value);
        if (audio.pianoStringGain) audio.pianoStringGain.gain.value = parseFloat(ui.volPianoString.value);
        if (audio.melodyGain) audio.melodyGain.gain.value = parseFloat(ui.volMelody.value);
        if (audio.echoGain) audio.echoGain.gain.value = parseFloat(ui.volEcho.value);
        if (audio.cleanPickedGain) audio.cleanPickedGain.gain.value = parseFloat(ui.volCleanPicked.value);
        if (audio.organGain) audio.organGain.gain.value = parseFloat(ui.volOrgan.value);

        ui.volBassLabel.textContent = Math.round(ui.volBass.value * 100) + '%';
        ui.volDrumsLabel.textContent = Math.round(ui.volDrums.value * 100) + '%';
        ui.volCleanLabel.textContent = Math.round(ui.volClean.value * 100) + '%';
        ui.volDistLabel.textContent = Math.round(ui.volDist.value * 100) + '%';
        ui.volMelodyLabel.textContent = Math.round(ui.volMelody.value * 100) + '%';
        if (ui.volEchoLabel) ui.volEchoLabel.textContent = Math.round(ui.volEcho.value * 100) + '%';
        if (ui.volCleanPickedLabel) ui.volCleanPickedLabel.textContent = Math.round(ui.volCleanPicked.value * 100) + '%';
        if (ui.volOrganLabel) ui.volOrganLabel.textContent = Math.round(ui.volOrgan.value * 100) + '%';
    }

    async function initAudio() {
        if (audio.ctx) return;
        if (initPromise) return initPromise;
        initPromise = (async () => {
            try {
                audio.ctx = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 44100, latencyHint: 'interactive'
                });
                await audio.ctx.resume();
                audio.master = audio.ctx.createGain();
                audio.mix = audio.ctx.createGain();
                audio.drumGain = audio.ctx.createGain();
                audio.bassGain = audio.ctx.createGain();
                audio.cleanGain = audio.ctx.createGain();
                audio.distGain = audio.ctx.createGain();
                audio.pianoStringGain = audio.ctx.createGain();
                audio.melodyGain = audio.ctx.createGain();
                audio.echoGain = audio.ctx.createGain();
                audio.cleanPickedGain = audio.ctx.createGain();
                audio.organGain = audio.ctx.createGain();

                audio.master.gain.value = 0.85;
                audio.drumGain.gain.value = 0.6;
                audio.bassGain.gain.value = 0.45;
                audio.cleanGain.gain.value = 0.45;
                audio.distGain.gain.value = 0.35;
                audio.pianoStringGain.gain.value = 0.50;
                audio.melodyGain.gain.value = 0.50;
                audio.echoGain.gain.value = 0.50;
                audio.cleanPickedGain.gain.value = 0.50;
                audio.organGain.gain.value = 0.50;

                audio.master.connect(audio.mix);
                audio.mix.connect(audio.ctx.destination);
                audio.drumGain.connect(audio.master);
                audio.bassGain.connect(audio.master);
                audio.cleanGain.connect(audio.master);
                audio.distGain.connect(audio.master);
                audio.pianoStringGain.connect(audio.master);
                audio.melodyGain.connect(audio.master);
                audio.echoGain.connect(audio.master);
                audio.cleanPickedGain.connect(audio.master);
                audio.organGain.connect(audio.master);

                if (!state.buffers.melody) state.buffers.melody = {};
                await ensureBasicSamples();

                ui.volBass.addEventListener('input', updateVolume);
                ui.volDrums.addEventListener('input', updateVolume);
                ui.volClean.addEventListener('input', updateVolume);
                ui.volDist.addEventListener('input', updateVolume);
                ui.volPianoString.addEventListener('input', updateVolume);
                ui.volMelody.addEventListener('input', updateVolume);
                if (ui.volEcho) ui.volEcho.addEventListener('input', updateVolume);
                if (ui.volCleanPicked) ui.volCleanPicked.addEventListener('input', updateVolume);
                if (ui.volOrgan) ui.volOrgan.addEventListener('input', updateVolume);
                updateVolume();

                setInterval(() => {
                    if (audio.ctx.state === 'running') {
                        const silentOscillator = audio.ctx.createOscillator();
                        const silentGain = audio.ctx.createGain();
                        silentGain.gain.value = 0.001;
                        silentOscillator.connect(silentGain);
                        silentGain.connect(audio.ctx.destination);
                        silentOscillator.start();
                        silentOscillator.stop(audio.ctx.currentTime + 0.1);
                    }
                }, 30000);
            } catch (error) {
                console.error('Erro ao inicializar √°udio:', error);
                try {
                    audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    await audio.ctx.resume();
                } catch (fallbackError) {
                    throw new Error('N√£o foi poss√≠vel inicializar o sistema de √°udio');
                }
            }
        })();
        return initPromise;
    }

    async function preloadAllSamples() {
        if (!audio.ctx) await initAudio();
        const preloadPromises = [];
        for (const [key, name] of Object.entries(DRUMS)) {
            const url = `assets/${name}.mp3`;
            preloadPromises.push(loadBufferWithCache(url).then(buf => { if (buf) state.buffers.drums[key] = buf; }));
        }
        for (const [key, url] of Object.entries(BASS_SAMPLES)) {
            preloadPromises.push(loadBufferWithCache(url).then(buf => { if (buf) state.buffers.bass[key] = buf; }));
        }
        const commonChords = ['C', 'G', 'D', 'A', 'E', 'F', 'Am', 'Em', 'Dm', 'G7', 'C7'];
        for (const chord of commonChords) {
            const baseNote = chord.replace(/[^A-G#]/g, '');
            const urls = [
                `guitarraLimpa/${baseNote}/${chord}.mp3`,
                `guitarraDistorcao/${baseNote}/${chord}.mp3`,
                `assets/PianoStringChord/${baseNote}/${chord}.mp3`,
                `GuitarraEcho/${baseNote}/${chord}.mp3`,
                `GuitarraLimpaDedilhada/${baseNote}/${chord}.mp3`,
                `Orgao/${baseNote}/${chord}.mp3`
            ];
            urls.forEach(url => {
                preloadPromises.push(loadBufferWithCache(url).then(buf => {
                    if (!state.buffers.guitar) state.buffers.guitar = {};
                    if (buf) state.buffers.guitar[url] = buf;
                }));
            });
        }
        await Promise.all(preloadPromises);
    }

    async function ensureBasicSamples() {
        const promises = [];
        for (const [key, name] of Object.entries(DRUMS)) {
            const url = `assets/${name}.mp3`;
            if (!state.buffers.drums[key]) promises.push(loadBufferWithCache(url).then(buf => { if (buf) state.buffers.drums[key] = buf; }));
        }
        for (const [key, url] of Object.entries(BASS_SAMPLES)) {
            if (!state.buffers.bass[key]) promises.push(loadBufferWithCache(url).then(buf => { if (buf) state.buffers.bass[key] = buf; }));
        }
        await Promise.all(promises);
    }

    async function loadBuffer(url) {
        try {
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const arrayBuffer = await res.arrayBuffer();
            return await audio.ctx.decodeAudioData(arrayBuffer);
        } catch (e) {
            console.warn(`Erro ao carregar: ${url}`);
            return null;
        }
    }

    function expandRhythm(patternArray, totalSteps) {
        const joined = patternArray.join(' ').replace(/\s+/g, ' ').trim();
        const tokens = joined.split(/\s+/).filter(t => t);
        const out = [];
        let i = 0;
        while (out.length < totalSteps) {
            for (const token of tokens) {
                if (out.length >= totalSteps) break;
                out.push(token);
            }
            if (i++ > 1000) break;
        }
        return out.slice(0, totalSteps);
    }

    async function buildBassAndChordPlan() {
        if (!ui.styleSelect || ui.styleSelect.value === 'auto') {
            state.currentGroove = ALL_GROOVES[Math.floor(Math.random() * ALL_GROOVES.length)];
        } else {
            const matchingGrooves = ALL_GROOVES.filter(g => g.name === ui.styleSelect.value);
            state.currentGroove = matchingGrooves[Math.floor(Math.random() * matchingGrooves.length)] || ALL_GROOVES[0];
        }
        state.signatureTag = state.currentGroove.name;
        state.meter = ui.meter.value === 'auto' ? state.currentGroove.meter : ui.meter.value;
        if (state.currentGroove.name === "Samba") { ui.bpm.value = 70; state.bpm = 70; } 
        else { state.bpm = Number(ui.bpm.value) || 100; }
        
        const beats = meterToBeats(state.meter);
        const sixteenthsPerBar = beats * 4;
        
        if (!ui.keySelect || ui.keySelect.value === 'auto') {
            state.keyIdx = Math.floor(Math.random() * PITCHES.length);
            state.key = PITCHES[state.keyIdx];
            state.quality = Math.random() > 0.5 ? 'maj' : 'min';
        } else {
            state.key = ui.keySelect.value;
            state.keyIdx = PITCHES.indexOf(state.key);
            state.quality = ui.qualitySelect.value;
        }

        const grooveName = state.currentGroove.name;
        let styleKey = "Rock";
        if (grooveName.includes("Samba")) styleKey = "Samba";
        else if (grooveName.includes("Jazz")) styleKey = "Jazz";
        else if (grooveName.includes("Forr√≥")) styleKey = "Forr√≥";
        else if (grooveName.includes("Metal")) styleKey = "Metal";
        else if (grooveName.includes("Blues")) styleKey = "Blues";
        
        const progressions = STYLE_PROGRESSIONS[styleKey] || STYLE_PROGRESSIONS.Rock;
        let availableProgressions = progressions.filter(prog => !prog.includes(7));
        if (availableProgressions.length === 0) availableProgressions = progressions;
        state.chordProgression = availableProgressions[Math.floor(Math.random() * availableProgressions.length)];
        
        const totalBars = Math.min(state.chordProgression.length, 64);
        const totalSteps = sixteenthsPerBar * totalBars;
        const rhythm = expandRhythm(state.currentGroove.bassRhythm, totalSteps);
        const bassPlan = [];
        const chordPlan = [];

        function getBassNotesFromScale(degree, scale, chordType) {
            let isMinor = false;
            if ([1, 4, 5].includes(degree)) isMinor = (state.quality === 'min');
            else isMinor = (chordType.startsWith('m') || chordType.includes('dim') || ['5+', '75+', '95+'].includes(chordType));

            if (scale === "chromatic") {
                const rootIdx = (state.keyIdx + DEGREE_TO_ROOT[degree]) % 12;
                return Array(8).fill().map((_, i) => {
                    const noteIdx = (rootIdx - i + 12) % 12;
                    const p = PITCHES[noteIdx];
                    return p.endsWith('S') ? `${p.replace('S', '')}8S` : `${p}8`;
                });
            }
            if (Array.isArray(scale)) {
                const rootIdx = (state.keyIdx + DEGREE_TO_ROOT[degree]) % 12;
                return scale.map(interval => {
                    let intervalOffset;
                    if (isMinor) intervalOffset = { 1: 0, 2: 2, 3: 3, 4: 5, 5: 7, 6: 8, 7: 10, 8: 12 }[interval] || 0;
                    else intervalOffset = { 1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11, 8: 12 }[interval] || 0;
                    const noteIdx = (rootIdx + intervalOffset) % 12;
                    const octave = interval === 1 ? '' : '8';
                    const noteName = PITCHES[noteIdx];
                    return noteName.endsWith('S') ? `${noteName.replace('S', '')}${octave}S` : `${noteName}${octave}`;
                });
            }
            return [PITCHES[(state.keyIdx + DEGREE_TO_ROOT[degree]) % 12]];
        }

        let globalChordVariation = '';
        if (styleKey === "Blues") globalChordVariation = '7';
        else {
            const allVariations = ['', '11', '13', '4', '5', '6', '7', '9', 'm', 'm4', 'm5', 'm6', 'm7', 'm79', 'm9'];
            globalChordVariation = allVariations[Math.floor(Math.random() * allVariations.length)];
        }

        for (let bar = 0; bar < totalBars; bar++) {
            const degree = state.chordProgression[bar];
            const rootOffset = DEGREE_TO_ROOT[degree] || 0;
            const rootIdx = (state.keyIdx + rootOffset) % 12;
            const rootNote = PITCHES[rootIdx];
            let chordType = '';
            if (styleKey === "Blues") {
                chordType = globalChordVariation;
            } else {
                switch(degree) {
                    case 1: case 4: case 5:
                        chordType = (globalChordVariation === '' || globalChordVariation.startsWith('m') === false) ? globalChordVariation : '';
                        break;
                    case 2: case 3: case 6:
                        chordType = (globalChordVariation.startsWith('m') || globalChordVariation === 'dim') ? globalChordVariation : 'm';
                        break;
                    case 7: chordType = 'dim'; break;
                    default: chordType = '';
                }
            }
            const chordDisplay = CHORD_NAMES[rootIdx] + chordType;
            const displayedNote = transposeDown3Semitones(CHORD_NAMES[rootIdx]);
            const displayedChord = displayedNote + chordType;
            chordPlan.push({ note: rootNote, type: chordType, display: chordDisplay, displayed: displayedChord });
            const bassNotes = getBassNotesFromScale(degree, state.currentGroove.bassScale, chordType);
            const stepsInBar = sixteenthsPerBar;
            const notesPerBar = Math.ceil(stepsInBar / bassNotes.length);
            const fullBassNotes = Array(stepsInBar).fill().map((_, i) => bassNotes[Math.floor(i / notesPerBar)] || bassNotes[0]);
            for (let stepInBar = 0; stepInBar < stepsInBar; stepInBar++) {
                const step = bar * stepsInBar + stepInBar;
                const sym = rhythm[step] || '-';
                let bassNote = null;
                if (sym === 'x') bassNote = 'x';
                else if (sym === '-' || sym === 'sm') bassNote = '-';
                else bassNote = fullBassNotes[stepInBar];
                bassPlan.push(bassNote);
            }
        }

        state.bassPlan = bassPlan;
        state.chordPlan = chordPlan;
        state.currentChordIndex = 0;
        state.barsInChord = 0;
        state.chordDurations = Array(state.chordPlan.length).fill(1);
        const progEl = document.getElementById('chordProgression');
        if (progEl && state.chordPlan.length > 0) {
            const chordLabels = state.chordPlan.map(ch => ch.displayed);
            progEl.innerHTML = chordLabels.map((label, i) => `<span class="chord-item" data-index="${i}">${label}</span>`).join(' ');
        }

        const drumParsed = parsePattern(state.currentGroove.drumPattern.join(' '));
        const drumSeq = [...drumParsed.intro, ...drumParsed.loop];
        const drumExpanded = [];
        while (drumExpanded.length < state.bassPlan.length) {
            for (const t of drumSeq) {
                if (drumExpanded.length >= state.bassPlan.length) break;
                drumExpanded.push(t);
            }
        }
        state.drumSeq = drumExpanded.slice(0, state.bassPlan.length);

        const guitarUrls = new Set();
        for (const ch of state.chordPlan) {
            let fullChordName = ch.note;
            if (ch.type) fullChordName += ch.type;
            guitarUrls.add(`guitarraDistorcao/${ch.note}/${fullChordName}.mp3`);
            guitarUrls.add(`guitarraDistorcao/abafadas/${ch.note}/${fullChordName}.mp3`);
            guitarUrls.add(`guitarraDistorcao/dedilhada/${ch.note}/${fullChordName}.mp3`);
            guitarUrls.add(`guitarraLimpa/${ch.note}/${fullChordName}.mp3`);
            guitarUrls.add(`assets/PianoStringChord/${ch.note}/${fullChordName}.mp3`);
            guitarUrls.add(`GuitarraEcho/${ch.note}/${fullChordName}.mp3`);
            guitarUrls.add(`GuitarraLimpaDedilhada/${ch.note}/${fullChordName}.mp3`);
            guitarUrls.add(`Orgao/${ch.note}/${fullChordName}.mp3`);
        }

        const preloadPromises = [];
        guitarUrls.forEach(url => {
            if (!state.buffers.guitar) state.buffers.guitar = {};
            if (!state.buffers.guitar[url]) {
                const p = loadBufferWithCache(url).then(buf => { if (buf) state.buffers.guitar[url] = buf; });
                preloadPromises.push(p);
            }
        });
        await Promise.all(preloadPromises);
    }

    function parsePattern(patternText) {
        const result = { intro: [], loop: [] };
        const introMatch = patternText.match(/\[(.*?)\]/);
        const loopMatch = patternText.match(/\((.*?)\)/);
        if (introMatch) result.intro = introMatch[1].trim().split(/\s+/).filter(s => s);
        if (loopMatch) result.loop = loopMatch[1].trim().split(/\s+/).filter(s => s);
        if (!introMatch && !loopMatch) result.loop = patternText.trim().split(/\s+/).filter(s => s);
        if (!result.loop.length) result.loop = result.intro.slice();
        return result;
    }

    function playClickAtTime(time, isStrong) {
        const ctx = audio.ctx;
        const osc = ctx.createOscillator();
        const g = ctx.createGain();
        osc.connect(g);
        g.connect(audio.drumGain);
        osc.frequency.value = isStrong ? 880 : 440;
        g.gain.setValueAtTime(0.0, time);
        g.gain.linearRampToValueAtTime(isStrong ? 0.18 : 0.09, time + 0.002);
        g.gain.linearRampToValueAtTime(0.0, time + 0.06);
        osc.start(time);
        osc.stop(time + 0.07);
    }

    async function onPlay() {
        if (state.running && !state.paused) return;
        try {
            if (!audio.ctx) await initAudio();
            if (audio.ctx.state === "suspended") await audio.ctx.resume();
        } catch (e) {
            console.error('Falha ao inicializar √°udio:', e);
            alert('Erro ao iniciar o sistema de √°udio.');
            return;
        }

        if (state.paused) {
            state.paused = false;
            const resumeOffset = audio.ctx.currentTime - state.pauseTime;
            state.nextNoteTime += resumeOffset;
            return;
        }

        if (state.bassPlan && state.bassPlan.length > 0 && state.chordPlan && state.chordPlan.length > 0) {
            if (!state.previousPlaybacks) state.previousPlaybacks = [];
            state.previousPlaybacks.push({
                bassPlan: [...state.bassPlan], chordPlan: [...state.chordPlan],
                drumSeq: [...state.drumSeq], melodyPlan: [...state.melodyPlan],
                currentGroove: {...state.currentGroove}, meter: state.meter, bpm: state.bpm,
                key: state.key, keyIdx: state.keyIdx, quality: state.quality,
                signatureTag: state.signatureTag, chordProgression: [...state.chordProgression]
            });
        }

        state.bpm = Number(ui.bpm.value) || 100;
        state.sixteenthDur = 60 / state.bpm / 4;

        try {
            await buildBassAndChordPlan();
            buildMelodyPlanFromBlocks();
            await ensureMelodySamplesNeeded();
        } catch (err) {
            alert('Erro ao gerar a progress√£o musical.');
            console.error(err);
            return;
        }

        const beats = meterToBeats(state.meter);
        const startTime = audio.ctx.currentTime + 0.05;
        for (let i = 0; i < beats; i++) playClickAtTime(startTime + i * (60 / state.bpm), i === 0);

        setTimeout(() => {
            state.running = true;
            state.nextNoteTime = audio.ctx.currentTime + 0.05 + beats * (60 / state.bpm);
            startScheduler();
        }, beats * (60 / state.bpm) * 1000);
    }

    function onPause() {
        if (state.running && !state.paused) {
            state.paused = true;
            state.pauseTime = audio.ctx.currentTime;
        }
    }

    function onPrevious() {
        if (!state.previousPlaybacks || state.previousPlaybacks.length === 0) {
            alert('Nenhum playback anterior dispon√≠vel.');
            return;
        }
        if (!state.nextPlaybacks) state.nextPlaybacks = [];
        if (state.bassPlan?.length > 0) {
            state.nextPlaybacks.push({
                bassPlan: [...state.bassPlan], chordPlan: [...state.chordPlan], drumSeq: [...state.drumSeq],
                melodyPlan: [...state.melodyPlan], currentGroove: {...state.currentGroove},
                meter: state.meter, bpm: state.bpm, key: state.key, keyIdx: state.keyIdx, quality: state.quality,
                signatureTag: state.signatureTag, chordProgression: [...state.chordProgression]
            });
        }

        const prev = state.previousPlaybacks.pop();
        Object.assign(state, {
            bassPlan: prev.bassPlan, chordPlan: prev.chordPlan, drumSeq: prev.drumSeq,
            melodyPlan: prev.melodyPlan, currentGroove: prev.currentGroove, meter: prev.meter,
            bpm: prev.bpm, key: prev.key, keyIdx: prev.keyIdx, quality: prev.quality,
            signatureTag: prev.signatureTag, chordProgression: prev.chordProgression,
            stepIndex: 0, currentChordIndex: 0, barsInChord: 0, guitarPlan: null
        });

        ui.bpm.value = state.bpm;
        ui.meter.value = state.meter;
        const progEl = document.getElementById('chordProgression');
        if (progEl && state.chordPlan.length > 0) {
            const chordLabels = state.chordPlan.map(ch => ch.displayed);
            progEl.innerHTML = chordLabels.map((label, i) => `<span class="chord-item" data-index="${i}">${label}</span>`).join(' ');
        }
        onPlay();
    }

    function scheduler() {
        if (!state.running || state.paused) return;
        const lookahead = 0.20;
        const currentTime = audio.ctx.currentTime;
        while (state.nextNoteTime < currentTime + lookahead) {
            scheduleStep();
        }
    }

    function startScheduler() {
        const lookaheadTime = 0.5;
        function tick() {
            if (state.running && !state.paused) {
                const currentTime = audio.ctx.currentTime;
                while (state.nextNoteTime < currentTime + lookaheadTime) {
                    scheduleStep();
                }
            }
            requestAnimationFrame(tick);
        }
        tick();
        state.schedulerTimer = setInterval(() => {
            if (state.running && !state.paused) scheduler();
        }, 25);
    }

    function scheduleStep() {
        const time = state.nextNoteTime;
        monitorPerformance();
        if (time < audio.ctx.currentTime - 0.1) {
            console.warn('Audio muito atrasado, ajustando...');
            performanceStats.lateSchedules++;
            state.nextNoteTime = audio.ctx.currentTime + 0.05;
            return;
        }
        const beats = meterToBeats(state.meter);
        const sixteenthsPerBar = beats * 4;
        const isNewBar = (state.stepIndex % sixteenthsPerBar) === 0;
        const chord = state.chordPlan[state.currentChordIndex];
        
        const drumToken = state.drumSeq[state.stepIndex % state.drumSeq.length];
        if (drumToken && !mute.drums) {
            let drumKey = null;
            if (['bu', 'bumbo'].includes(drumToken)) drumKey = 'bu';
            else if (['ca', 'caixa'].includes(drumToken)) drumKey = 'ca';
            else if (['ch', 'chimbal'].includes(drumToken)) drumKey = 'ch';
            else if (['ba', 'bumbo-ataque'].includes(drumToken)) drumKey = 'ba';
            else if (['cch', 'caixa-chimbal'].includes(drumToken)) drumKey = 'cch';
            else if (['bco', 'bumbo-conducao'].includes(drumToken)) drumKey = 'bco';
            else if (['co', 'conducao'].includes(drumToken)) drumKey = 'co';
            else if (['cco', 'caixa-conducao'].includes(drumToken)) drumKey = 'cco';
            else if (['to1', 'tom-1'].includes(drumToken)) drumKey = 'to1';
            else if (['to2', 'tom-2'].includes(drumToken)) drumKey = 'to2';
            else if (['su', 'surdo'].includes(drumToken)) drumKey = 'su';
            else if (['bch', 'bumbo-chimbal'].includes(drumToken)) drumKey = 'bch';
            
            if (drumKey && state.buffers.drums[drumKey]) {
                const src = audio.ctx.createBufferSource();
                const g = audio.ctx.createGain();
                src.buffer = state.buffers.drums[drumKey];
                src.connect(g);
                g.connect(audio.drumGain);
                g.gain.setValueAtTime(0.0, time);
                g.gain.linearRampToValueAtTime(1.0, time + 0.005);
                src.start(time);
            }
        }
        
        const bassCommand = state.bassPlan[state.stepIndex % state.bassPlan.length];
        if (!mute.bass && bassCommand !== '-' && bassCommand !== 'x') {
            if (state.lastBassSource) {
                try {
                    const fadeTime = 0.02;
                    if (state.lastBassGainNode) state.lastBassGainNode.gain.linearRampToValueAtTime(0, time + fadeTime);
                    state.lastBassSource.stop(time + fadeTime);
                } catch (e) {}
            }
            const buf = state.buffers.bass[bassCommand];
            if (buf) {
                const src = audio.ctx.createBufferSource();
                const g = audio.ctx.createGain();
                src.buffer = buf;
                src.connect(g);
                g.connect(audio.bassGain);
                g.gain.setValueAtTime(0.0, time);
                g.gain.linearRampToValueAtTime(1.0, time + 0.02);
                const releaseTime = Math.min(buf.duration - 0.05, state.sixteenthDur - 0.02);
                if (releaseTime > 0.1) {
                    g.gain.linearRampToValueAtTime(1.0, time + releaseTime);
                    g.gain.linearRampToValueAtTime(0.0, time + releaseTime + 0.02);
                }
                src.start(time);
                state.lastBassSource = src;
                state.lastBassGainNode = g;
            } else {
                performanceStats.bufferMisses++;
            }
        }
        
        if (!mute.clean && chord && isNewBar) {
            if (state.lastCleanSource) try { state.lastCleanSource.stop(time + 0.01); } catch (e) {}
            let fullChordName = chord.note + (chord.type || '');
            const url = `guitarraLimpa/${chord.note}/${fullChordName}.mp3`;
            const buf = state.buffers.guitar?.[url];
            if (buf) {
                const src = audio.ctx.createBufferSource();
                const g = audio.ctx.createGain();
                src.buffer = buf;
                src.connect(g);
                g.connect(audio.cleanGain);
                g.gain.setValueAtTime(0.0, time);
                g.gain.linearRampToValueAtTime(1.0, time + 0.08);
                src.start(time);
                state.lastCleanSource = src;
            }
        }
        
        if (!mute.pianoString && chord && isNewBar) {
            let fullChordName = chord.note + (chord.type || '');
            const url = `assets/PianoStringChord/${chord.note}/${fullChordName}.mp3`;
            const buf = state.buffers.guitar?.[url];
            if (buf) {
                const src = audio.ctx.createBufferSource();
                const g = audio.ctx.createGain();
                src.buffer = buf;
                src.connect(g);
                g.connect(audio.pianoStringGain);
                g.gain.setValueAtTime(0.0, time);
                g.gain.linearRampToValueAtTime(1.0, time + 0.05);
                src.start(time);
                state.lastPianoStringSource = src;
            }
        }
        
        if (!mute.dist) {
            if (state.currentGroove && state.currentGroove.guitarRhythm) {
                if (!state.guitarPlan) state.guitarPlan = expandRhythm(state.currentGroove.guitarRhythm, state.bassPlan.length);
                const guitarCommand = state.guitarPlan[state.stepIndex % state.guitarPlan.length];
                if (guitarCommand && guitarCommand !== '-' && chord) {
                    if (state.lastDistSource) try { state.lastDistSource.stop(time + 0.01); } catch (e) {}
                    let baseFolder = 'guitarraDistorcao';
                    if (guitarCommand === 'ab') baseFolder = 'guitarraDistorcao/abafadas';
                    else if (guitarCommand === 'de') baseFolder = 'guitarraDistorcao/dedilhada';
                    else if (guitarCommand === 'so') baseFolder = 'guitarraDistorcao';
                    let fullChordName = chord.note + (chord.type || '');
                    const url = `${baseFolder}/${chord.note}/${fullChordName}.mp3`;
                    const buf = state.buffers.guitar?.[url];
                    if (buf) {
                        const src = audio.ctx.createBufferSource();
                        const g = audio.ctx.createGain();
                        src.buffer = buf;
                        src.connect(g);
                        g.connect(audio.distGain);
                        g.gain.setValueAtTime(0.0, time);
                        g.gain.linearRampToValueAtTime(1.0, time + 0.03);
                        src.start(time);
                        state.lastDistSource = src;
                    }
                }
            } else if (chord && isNewBar) {
                if (state.lastDistSource) try { state.lastDistSource.stop(time + 0.01); } catch (e) {}
                let fullChordName = chord.note + (chord.type || '');
                const url = `guitarraDistorcao/${chord.note}/${fullChordName}.mp3`;
                const buf = state.buffers.guitar?.[url];
                if (buf) {
                    const src = audio.ctx.createBufferSource();
                    const g = audio.ctx.createGain();
                    src.buffer = buf;
                    src.connect(g);
                    g.connect(audio.distGain);
                    g.gain.setValueAtTime(0.0, time);
                    g.gain.linearRampToValueAtTime(1.0, time + 0.05);
                    src.start(time);
                    state.lastDistSource = src;
                }
            }
        }
        
        if (!mute.echo && chord && isNewBar) {
            if (state.lastEchoSource) try { state.lastEchoSource.stop(time + 0.01); } catch (e) {}
            let fullChordName = chord.note + (chord.type || '');
            const url = `GuitarraEcho/${chord.note}/${fullChordName}.mp3`;
            const buf = state.buffers.guitar?.[url];
            if (buf) {
                const src = audio.ctx.createBufferSource();
                const g = audio.ctx.createGain();
                src.buffer = buf;
                src.connect(g);
                g.connect(audio.echoGain);
                g.gain.setValueAtTime(0.0, time);
                g.gain.linearRampToValueAtTime(1.0, time + 0.06);
                src.start(time);
                state.lastEchoSource = src;
            }
        }
        
        if (!mute.cleanPicked && chord && isNewBar) {
            if (state.lastCleanPickedSource) try { state.lastCleanPickedSource.stop(time + 0.01); } catch (e) {}
            let fullChordName = chord.note + (chord.type || '');
            const url = `GuitarraLimpaDedilhada/${chord.note}/${fullChordName}.mp3`;
            const buf = state.buffers.guitar?.[url];
            if (buf) {
                const src = audio.ctx.createBufferSource();
                const g = audio.ctx.createGain();
                src.buffer = buf;
                src.connect(g);
                g.connect(audio.cleanPickedGain);
                g.gain.setValueAtTime(0.0, time);
                g.gain.linearRampToValueAtTime(1.0, time + 0.07);
                src.start(time);
                state.lastCleanPickedSource = src;
            }
        }
        
        if (!mute.organ && chord && isNewBar) {
            if (state.lastOrganSource) try { state.lastOrganSource.stop(time + 0.01); } catch (e) {}
            let fullChordName = chord.note + (chord.type || '');
            const url = `Orgao/${chord.note}/${fullChordName}.mp3`;
            const buf = state.buffers.guitar?.[url];
            if (buf) {
                const src = audio.ctx.createBufferSource();
                const g = audio.ctx.createGain();
                src.buffer = buf;
                src.connect(g);
                g.connect(audio.organGain);
                g.gain.setValueAtTime(0.0, time);
                g.gain.linearRampToValueAtTime(1.0, time + 0.08);
                src.start(time);
                state.lastOrganSource = src;
            }
        }
        
        const melodyEvent = state.melodyPlan[state.stepIndex % state.melodyPlan.length];
        if (melodyEvent && melodyEvent.type === 'start') {
            if (state.lastMelodySource) {
                try { state.lastMelodySource.stop(time); } catch (e) {}
                state.lastMelodySource = null;
            }
            let adaptedNumber = melodyEvent.adaptedNumber;
            if (adaptedNumber === null) {
                adaptedNumber = adaptNumberToChord(melodyEvent.originalNumber, chord.note, chord.type, state.lastMelodyNote);
                melodyEvent.adaptedNumber = adaptedNumber;
            }
            state.lastMelodyNote = adaptedNumber;
            const instrument = melodyEvent.instrument || ui.melodyInstrument.value;
            const folder = MELODY_INSTRUMENTS[instrument];
            if (folder) {
                const noteName = NUM_TO_NAME[adaptedNumber];
                const url = `${folder}/${adaptedNumber}${noteName}.mp3`;
                const buf = state.buffers.melody[url];
                if (buf) {
                    const src = audio.ctx.createBufferSource();
                    const g = audio.ctx.createGain();
                    src.buffer = buf;
                    src.connect(g);
                    g.connect(audio.melodyGain);
                    g.gain.setValueAtTime(0.0, time);
                    g.gain.linearRampToValueAtTime(1.0, time + 0.01);
                    const maxDur = state.sixteenthDur * 16;
                    src.start(time);
                    src.stop(time + Math.min(buf.duration, maxDur));
                    state.lastMelodySource = src;
                }
            }
        } else if (melodyEvent && melodyEvent.type === 'mute') {
            if (state.lastMelodySource) {
                try { state.lastMelodySource.stop(time); } catch (e) {}
                state.lastMelodySource = null;
            }
            state.lastMelodyNote = null;
        } else if (state.lastMelodyNote !== null && chord) {
            const newlyAdaptedNumber = adaptNumberToChord(state.lastMelodyNote, chord.note, chord.type, null);
            if (newlyAdaptedNumber !== state.lastMelodyNote) {
                if (state.lastMelodySource) {
                    try { state.lastMelodySource.stop(time); } catch (e) {}
                    state.lastMelodySource = null;
                }
                playMelodyNumber(time, newlyAdaptedNumber, ui.melodyInstrument.value);
                state.lastMelodyNote = newlyAdaptedNumber;
            }
        }
        
        if (isNewBar) updateCurrentChordDisplay();
        state.stepIndex++;
        if (isNewBar) {
            state.currentChordIndex = (state.currentChordIndex + 1) % state.chordPlan.length;
            state.barsInChord = 0;
            state.guitarPlan = null;
        }
        state.nextNoteTime += state.sixteenthDur;
    }

    function updateCurrentChordDisplay() {
        if (state.chordPlan.length > 0) {
            const chord = state.chordPlan[state.currentChordIndex];
            ui.currentChord.textContent = chord.displayed;
            document.querySelectorAll('.chord-item').forEach((el, i) => {
                el.classList.toggle('current', i === state.currentChordIndex);
            });
        }
    }

    function onStop() {
        state.running = false;
        state.paused = false;
        ui.currentChord.textContent = '‚Äî';
        ui.chordTimer.textContent = '‚Äî';
        if (state.lastBassSource) state.lastBassSource.stop(0);
        if (state.lastDistSource) state.lastDistSource.stop(0);
        if (state.lastMelodySource) state.lastMelodySource.stop(0);
        if (state.lastCleanSource) state.lastCleanSource.stop(0);
        if (state.lastEchoSource) state.lastEchoSource.stop(0);
        if (state.lastCleanPickedSource) state.lastCleanPickedSource.stop(0);
        if (state.lastOrganSource) state.lastOrganSource.stop(0);
        state.lastBassSource = null;
        state.lastDistSource = null;
        state.lastMelodySource = null;
        state.lastCleanSource = null;
        state.lastEchoSource = null;
        state.lastCleanPickedSource = null;
        state.lastOrganSource = null;
        state.lastMelodyGain = null;
        state.lastMelodyNote = null;
        if (state.schedulerTimer) {
            clearInterval(state.schedulerTimer);
            state.schedulerTimer = null;
        }
        state.guitarPlan = null;
        document.querySelectorAll('.chord-item.current').forEach(el => el.classList.remove('current'));
    }

    function toggleMute(type, button) {
        mute[type] = !mute[type];
        updateMuteButtonUI(type, button);
    }

    const ORDER_E_UP = ['E','F','FS','G','GS','A','AS','B','C','CS','D','DS'];
    const NUM_TO_NAME = (() => {
        const map = {};
        let n = 1, i = 0;
        while (n <= 49) {
            map[n] = ORDER_E_UP[i % ORDER_E_UP.length];
            n++; i++;
        }
        return map;
    })();

    function chordTriad(rootPitchName, quality) {
        const rootIdx = PITCHES.indexOf(rootPitchName);
        if (rootIdx === -1) return [rootPitchName];
        let basicQuality = 'maj';
        let hasSeventh = false, hasNinth = false;
        if (quality.includes('m') && !quality.includes('maj')) basicQuality = 'min';
        else if (quality.includes('dim')) basicQuality = 'dim';
        if (quality.includes('7')) hasSeventh = true;
        if (/[^1]9/.test(quality) || quality.endsWith('9')) hasNinth = true;
        
        let chordNotes = [];
        if (basicQuality === 'min') chordNotes = [PITCHES[rootIdx], PITCHES[(rootIdx + 3) % 12], PITCHES[(rootIdx + 7) % 12]];
        else if (basicQuality === 'dim') chordNotes = [PITCHES[rootIdx], PITCHES[(rootIdx + 3) % 12], PITCHES[(rootIdx + 6) % 12]];
        else chordNotes = [PITCHES[rootIdx], PITCHES[(rootIdx + 4) % 12], PITCHES[(rootIdx + 7) % 12]];
        
        if (hasSeventh) {
            if (basicQuality === 'min' || basicQuality === 'dim') chordNotes.push(PITCHES[(rootIdx + 10) % 12]);
            else chordNotes.push(PITCHES[(rootIdx + 11) % 12]);
        }
        if (hasNinth) chordNotes.push(PITCHES[(rootIdx + 2) % 12]);
        return chordNotes;
    }

    function distanceBetweenNotes(n1, n2) {
        const i1 = ORDER_E_UP.indexOf(n1);
        const i2 = ORDER_E_UP.indexOf(n2);
        return i1 === -1 || i2 === -1 ? 100 : Math.abs(i1 - i2);
    }

    function adaptNumberToChord(number, root, type, lastPlayedNote = null) {
        const baseName = NUM_TO_NAME[number];
        const chordNotes = chordTriad(root, type);
        if (chordNotes.includes(baseName)) return findClosestNumber(number, baseName);
        const noteDistances = chordNotes.map(note => ({ note, distance: distanceBetweenNotes(baseName, note) }));
        noteDistances.sort((a, b) => a.distance - b.distance);
        if (lastPlayedNote && noteDistances.length > 1) {
            const lastNoteName = NUM_TO_NAME[lastPlayedNote];
            if (noteDistances[0].note === lastNoteName) return findClosestNumber(number, noteDistances[1].note);
        }
        return findClosestNumber(number, noteDistances[0].note);
    }

    function findClosestNumber(targetNumber, targetNote) {
        let bestNum = targetNumber, bestDist = 100;
        for (let n = 1; n <= 49; n++) {
            const name = NUM_TO_NAME[n];
            if (name === targetNote) {
                const dist = Math.abs(n - targetNumber);
                if (dist < bestDist) { bestDist = dist; bestNum = n; }
            }
        }
        return bestNum;
    }

    function addMelodyBlock() {
        const beats = meterToBeats(state.meter || '4/4');
        const cols = beats * 4;
        const blockIdx = state.melodyBlocks.length;
        const div = document.createElement('div');
        div.className = 'melody-block';
        const caption = document.createElement('div');
        caption.className = 'melody-caption';
        caption.textContent = `Bloco #${blockIdx + 1} ‚Äî ${beats}/4 (${cols} colunas)`;
        div.appendChild(caption);
        const table = document.createElement('table');
        table.className = 'melody-table';
        const tr = document.createElement('tr');
        tr.innerHTML = '<th>Notas</th>' + Array(cols).fill().map((_, i) => `<th>${i+1}</th>`).join('');
        table.appendChild(tr);
        const inputRow = document.createElement('tr');
        const tdLabel = document.createElement('td');
        tdLabel.innerHTML = `<span class="line-label">Notas</span>`;
        inputRow.appendChild(tdLabel);
        for (let c = 0; c < cols; c++) {
            const td = document.createElement('td');
            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = 'x';
            input.dataset.block = String(blockIdx);
            input.dataset.col = String(c);
            input.inputMode = 'numeric'; // Melhor teclado no mobile
            td.appendChild(input);
            inputRow.appendChild(td);
            if (isMobileDevice()) {
                input.addEventListener('dblclick', (e) => { e.target.value = ''; });
            }
        }
        table.appendChild(inputRow);
        div.appendChild(table);
        ui.melodyBlocks.appendChild(div);
        state.melodyBlocks.push(div);
    }

    function clearMelodyBlocks() {
        state.melodyBlocks = [];
        ui.melodyBlocks.innerHTML = '';
    }

    const MELODY_INSTRUMENTS = {
        dist: "guitarraDistorcao/Melodia", guitar2: "guitarraDistorcao/Melodia2",
        guitar3: "guitarraDistorcao/Melodia3", guitar4: "guitarraDistorcao/Melodia4",
        guitar5: "guitarraDistorcao/Melodia5", piano: "assets/PianoString",
        baixo: "assets/BaixoMelodia", sax: "assets/SaxMelodia", acordeon: "assets/AcordeonMelodia",
        sinos: "assets/SinosMelodia", violao_aco: "assets/ViolaoAcoMelodia",
        violao_nylon: "assets/ViolaoNylonMelodia", cordas: "assets/Cordas"
    };

    function updateMelodyInstrumentSelect() {
        ui.melodyInstrument.innerHTML = '';
        const options = [
            { value: 'dist', text: 'Guitarra 1' }, { value: 'guitar2', text: 'Guitarra 2' },
            { value: 'guitar3', text: 'Guitarra 3' }, { value: 'guitar4', text: 'Guitarra 4' },
            { value: 'guitar5', text: 'Guitarra 5' }, { value: 'piano', text: 'Piano/String' },
            { value: 'baixo', text: 'Baixo' }, { value: 'sax', text: 'Sax' },
            { value: 'acordeon', text: 'Acordeon' }, { value: 'sinos', text: 'Sinos' },
            { value: 'violao_aco', text: 'Viol√£o A√ßo' }, { value: 'violao_nylon', text: 'Viol√£o Nylon' },
            { value: 'cordas', text: 'Cordas' }
        ];
        options.forEach(opt => {
            const el = document.createElement('option');
            el.value = opt.value; el.textContent = opt.text;
            ui.melodyInstrument.appendChild(el);
        });
    }

    function buildMelodyPlanFromBlocks() {
        const plan = [];
        for (const block of state.melodyBlocks) {
            const inputs = block.querySelectorAll('input');
            inputs.forEach((input) => {
                const value = input.value.trim();
                if (value === '') plan.push(null);
                else if (value.toLowerCase() === 'x') plan.push({ type: 'mute' });
                else {
                    const num = parseInt(value, 10);
                    if (!isNaN(num) && num >= 1 && num <= 49) {
                        plan.push({ type: 'start', originalNumber: num, adaptedNumber: null, instrument: ui.melodyInstrument.value });
                    }
                }
            });
        }
        state.melodyPlan = plan;
    }

    async function ensureMelodySamplesNeeded() {
        const instrument = ui.melodyInstrument.value;
        const folder = MELODY_INSTRUMENTS[instrument];
        if (!folder) return;
        const promises = [];
        for (let i = 1; i <= 49; i++) {
            const noteName = NUM_TO_NAME[i];
            const url = `${folder}/${i}${noteName}.mp3`;
            if (!state.buffers.melody[url]) {
                promises.push(loadBuffer(url).then(buf => { if (buf) state.buffers.melody[url] = buf; }));
            }
        }
        await Promise.all(promises);
    }

    function playMelodyNumber(time, number, instrumentType) {
        const folder = MELODY_INSTRUMENTS[instrumentType];
        if (!folder) return;
        const noteName = NUM_TO_NAME[number];
        const url = `${folder}/${number}${noteName}.mp3`;
        const buf = state.buffers.melody[url];
        if (!buf) return;
        if (state.lastMelodySource && !state.lastMelodySource.finished) state.lastMelodySource.stop(time);
        
        const src = audio.ctx.createBufferSource();
        const g = audio.ctx.createGain();
        src.buffer = buf;
        src.connect(g);
        if (!audio.melodyGain) {
            audio.melodyGain = audio.ctx.createGain();
            audio.melodyGain.gain.value = 0.50;
            audio.melodyGain.connect(audio.master);
        }
        g.connect(audio.melodyGain);
        g.gain.setValueAtTime(0.0, time);
        g.gain.linearRampToValueAtTime(1.0, time + 0.01);
        const maxDur = state.sixteenthDur * 16;
        src.start(time);
        src.stop(time + Math.min(buf.duration, maxDur));
        state.lastMelodySource = src;
        state.lastMelodyGain = g;
        src.finished = false;
        src.onended = () => { src.finished = true; };
    }

    function audioBufferToWav(buffer) {
        const numOfChan = buffer.numberOfChannels;
        const length = buffer.length * numOfChan * 2 + 44;
        const arrayBuffer = new ArrayBuffer(length);
        const view = new DataView(arrayBuffer);
        const channels = [];
        let i, sample, offset = 0;
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
        }
        writeString(view, 0, 'RIFF');
        view.setUint32(4, length - 8, true);
        writeString(view, 8, 'WAVE');
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numOfChan, true);
        view.setUint32(24, buffer.sampleRate, true);
        view.setUint32(28, buffer.sampleRate * 2 * numOfChan, true);
        view.setUint16(32, 2 * numOfChan, true);
        view.setUint16(34, 16, true);
        writeString(view, 36, 'data');
        view.setUint32(40, length - 44, true);
        for (i = 0; i < buffer.numberOfChannels; i++) channels.push(buffer.getChannelData(i));
        offset = 44;
        for (i = 0; i < buffer.length; i++) {
            for (let channel = 0; channel < numOfChan; channel++) {
                sample = Math.max(-1, Math.min(1, channels[channel][i]));
                sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF);
                view.setInt16(offset, sample, true);
                offset += 2;
            }
        }
        return new Blob([view], { type: 'audio/wav' });
    }

    function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
    }

    async function renderAndDownloadWAV(durationInSeconds) {
        if (!state.running) {
            alert('Por favor, inicie a reprodu√ß√£o primeiro para gerar a grava√ß√£o.');
            return;
        }
        try {
            const sampleRate = 44100;
            const totalLength = Math.ceil(durationInSeconds * sampleRate);
            const offlineCtx = new OfflineAudioContext(2, totalLength, sampleRate);
            const master = offlineCtx.createGain();
            const mix = offlineCtx.createGain();
            const drumGain = offlineCtx.createGain();
            const bassGain = offlineCtx.createGain();
            const cleanGain = offlineCtx.createGain();
            const distGain = offlineCtx.createGain();
            const melodyGain = offlineCtx.createGain();
            const pianoStringGain = offlineCtx.createGain();
            const echoGain = offlineCtx.createGain();
            const cleanPickedGain = offlineCtx.createGain();
            const organGain = offlineCtx.createGain();

            master.gain.value = 0.9;
            drumGain.gain.value = parseFloat(ui.volDrums.value);
            bassGain.gain.value = parseFloat(ui.volBass.value);
            cleanGain.gain.value = parseFloat(ui.volClean.value);
            distGain.gain.value = parseFloat(ui.volDist.value);
            melodyGain.gain.value = parseFloat(ui.volMelody.value);
            pianoStringGain.gain.value = parseFloat(ui.volPianoString.value);
            echoGain.gain.value = parseFloat(ui.volEcho.value);
            cleanPickedGain.gain.value = parseFloat(ui.volCleanPicked.value);
            organGain.gain.value = parseFloat(ui.volOrgan.value);

            master.connect(mix);
            mix.connect(offlineCtx.destination);
            drumGain.connect(master);
            bassGain.connect(master);
            cleanGain.connect(master);
            distGain.connect(master);
            melodyGain.connect(master);
            pianoStringGain.connect(master);
            echoGain.connect(master);
            cleanPickedGain.connect(master);
            organGain.connect(master);

            const sixteenthDur = 60 / state.bpm / 4;
            const beatsPerBar = meterToBeats(state.meter);
            const stepsPerBar = beatsPerBar * 4;
            const lastSources = { bass: null, clean: null, dist: null, melody: null, pianoString: null, echo: null, cleanPicked: null, organ: null };

            function scheduleSample(buffer, time, gainNode, instrumentKey, gainValue = 1.0) {
                if (!buffer || time >= durationInSeconds) return;
                if (lastSources[instrumentKey]) try { lastSources[instrumentKey].stop(time); } catch (e) {}
                const src = offlineCtx.createBufferSource();
                const g = offlineCtx.createGain();
                src.buffer = buffer;
                src.connect(g);
                g.connect(gainNode);
                g.gain.setValueAtTime(0.0, time);
                g.gain.linearRampToValueAtTime(gainValue, time + 0.01);
                src.start(time);
                const stopTime = Math.min(time + buffer.duration, time + 2.0, durationInSeconds);
                src.stop(stopTime);
                lastSources[instrumentKey] = src;
            }

            const totalSteps = Math.floor(durationInSeconds / sixteenthDur);
            for (let stepIdx = 0; stepIdx < totalSteps; stepIdx++) {
                const currentTime = stepIdx * sixteenthDur;
                const isNewBar = (stepIdx % stepsPerBar) === 0;
                const currentChordIndex = Math.floor(stepIdx / stepsPerBar) % state.chordPlan.length;
                const chord = state.chordPlan[currentChordIndex];

                if (!mute.drums) {
                    const drumToken = state.drumSeq[stepIdx % state.drumSeq.length];
                    let drumKey = null;
                    if (['bu', 'bumbo'].includes(drumToken)) drumKey = 'bu';
                    else if (['ca', 'caixa'].includes(drumToken)) drumKey = 'ca';
                    else if (['ch', 'chimbal'].includes(drumToken)) drumKey = 'ch';
                    else if (['ba', 'bumbo-ataque'].includes(drumToken)) drumKey = 'ba';
                    else if (['cch', 'caixa-chimbal'].includes(drumToken)) drumKey = 'cch';
                    else if (['bco', 'bumbo-conducao'].includes(drumToken)) drumKey = 'bco';
                    else if (['co', 'conducao'].includes(drumToken)) drumKey = 'co';
                    else if (['cco', 'caixa-conducao'].includes(drumToken)) drumKey = 'cco';
                    else if (['to1', 'tom-1'].includes(drumToken)) drumKey = 'to1';
                    else if (['to2', 'tom-2'].includes(drumToken)) drumKey = 'to2';
                    else if (['su', 'surdo'].includes(drumToken)) drumKey = 'su';
                    else if (['bch', 'bumbo-chimbal'].includes(drumToken)) drumKey = 'bch';
                    if (drumKey && state.buffers.drums[drumKey]) {
                        const src = offlineCtx.createBufferSource();
                        const g = offlineCtx.createGain();
                        src.buffer = state.buffers.drums[drumKey];
                        src.connect(g);
                        g.connect(drumGain);
                        g.gain.setValueAtTime(0.0, currentTime);
                        g.gain.linearRampToValueAtTime(1.0, currentTime + 0.005);
                        src.start(currentTime);
                    }
                }
                
                if (!mute.bass) {
                    const bassCommand = state.bassPlan[stepIdx % state.bassPlan.length];
                    if (bassCommand !== '-' && state.buffers.bass[bassCommand]) scheduleSample(state.buffers.bass[bassCommand], currentTime, bassGain, 'bass');
                }
                
                if (!mute.clean && chord && isNewBar) {
                    let fullChordName = chord.note + (chord.type || '');
                    const url = `guitarraLimpa/${chord.note}/${fullChordName}.mp3`;
                    const buf = state.buffers.guitar?.[url];
                    if (buf) scheduleSample(buf, currentTime, cleanGain, 'clean');
                }
                
                if (!mute.pianoString && chord && isNewBar) {
                    let fullChordName = chord.note + (chord.type || '');
                    const url = `assets/PianoStringChord/${chord.note}/${fullChordName}.mp3`;
                    const buf = state.buffers.guitar?.[url];
                    if (buf) scheduleSample(buf, currentTime, pianoStringGain, 'pianoString');
                }
                
                if (!mute.dist) {
                    if (state.currentGroove && state.currentGroove.guitarRhythm) {
                        if (!state.guitarPlan) state.guitarPlan = expandRhythm(state.currentGroove.guitarRhythm, state.bassPlan.length);
                        const guitarCommand = state.guitarPlan[stepIdx % state.guitarPlan.length];
                        if (guitarCommand && guitarCommand !== '-' && chord) {
                            let baseFolder = 'guitarraDistorcao';
                            if (guitarCommand === 'ab') baseFolder = 'guitarraDistorcao/abafadas';
                            else if (guitarCommand === 'de') baseFolder = 'guitarraDistorcao/dedilhada';
                            else if (guitarCommand === 'so') baseFolder = 'guitarraDistorcao';
                            let fullChordName = chord.note + (chord.type || '');
                            const url = `${baseFolder}/${chord.note}/${fullChordName}.mp3`;
                            const buf = state.buffers.guitar?.[url];
                            if (buf) scheduleSample(buf, currentTime, distGain, 'dist');
                        }
                    } else if (chord && isNewBar) {
                        let fullChordName = chord.note + (chord.type || '');
                        const url = `guitarraDistorcao/${chord.note}/${fullChordName}.mp3`;
                        const buf = state.buffers.guitar?.[url];
                        if (buf) scheduleSample(buf, currentTime, distGain, 'dist');
                    }
                }
                
                if (!mute.echo && chord && isNewBar) {
                    let fullChordName = chord.note + (chord.type || '');
                    const url = `GuitarraEcho/${chord.note}/${fullChordName}.mp3`;
                    const buf = state.buffers.guitar?.[url];
                    if (buf) scheduleSample(buf, currentTime, echoGain, 'echo');
                }
                
                if (!mute.cleanPicked && chord && isNewBar) {
                    let fullChordName = chord.note + (chord.type || '');
                    const url = `GuitarraLimpaDedilhada/${chord.note}/${fullChordName}.mp3`;
                    const buf = state.buffers.guitar?.[url];
                    if (buf) scheduleSample(buf, currentTime, cleanPickedGain, 'cleanPicked');
                }
                
                if (!mute.organ && chord && isNewBar) {
                    let fullChordName = chord.note + (chord.type || '');
                    const url = `Orgao/${chord.note}/${fullChordName}.mp3`;
                    const buf = state.buffers.guitar?.[url];
                    if (buf) scheduleSample(buf, currentTime, organGain, 'organ');
                }

                if (state.melodyPlan.length > 0) {
                    const melodyEvent = state.melodyPlan[stepIdx % state.melodyPlan.length];
                    if (melodyEvent && melodyEvent.type === 'start') {
                        let adaptedNumber = melodyEvent.adaptedNumber;
                        if (adaptedNumber === null) {
                            adaptedNumber = adaptNumberToChord(melodyEvent.originalNumber, chord.note, chord.type, state.lastMelodyNote);
                        }
                        const instrument = melodyEvent.instrument || ui.melodyInstrument.value;
                        const folder = MELODY_INSTRUMENTS[instrument];
                        if (folder) {
                            const noteName = NUM_TO_NAME[adaptedNumber];
                            const url = `${folder}/${adaptedNumber}${noteName}.mp3`;
                            const buf = state.buffers.melody[url];
                            if (buf) scheduleSample(buf, currentTime, melodyGain, 'melody');
                        }
                    } else if (melodyEvent && melodyEvent.type === 'mute') {
                        if (lastSources.melody) { try { lastSources.melody.stop(currentTime); } catch (e) {} lastSources.melody = null; }
                    }
                }
            }

            ui.btnSaveWAV.innerHTML = '‚è≥ Renderizando...';
            ui.btnSaveWAV.disabled = true;
            const renderedBuffer = await offlineCtx.startRendering();
            const wavBlob = audioBufferToWav(renderedBuffer);
            const fileName = `jam-on-${Math.floor(durationInSeconds)}s-${new Date().toISOString().slice(11,19).replace(/:/g,'-')}.wav`;
            downloadBlob(wavBlob, fileName);
            ui.btnSaveWAV.innerHTML = 'üíæ Salvar como WAV';
            ui.btnSaveWAV.disabled = false;
        } catch (error) {
            console.error('Erro ao renderizar WAV:', error);
            alert('Erro ao gerar o arquivo de √°udio. Verifique o console para mais detalhes.');
            ui.btnSaveWAV.innerHTML = 'üíæ Salvar como WAV';
            ui.btnSaveWAV.disabled = false;
        }
    }

    ui.btnSaveWAV.addEventListener('click', async () => {
        if (!state.running) {
            alert('Por favor, inicie a reprodu√ß√£o primeiro para poder gravar.');
            return;
        }
        const input = prompt('Digite a dura√ß√£o desejada para o arquivo WAV (em segundos):', '30');
        const duration = parseFloat(input);
        if (isNaN(duration) || duration <= 0) {
            alert('Por favor, insira um n√∫mero v√°lido maior que zero.');
            return;
        }
        if (duration > 300) {
            alert('Por favor, escolha uma dura√ß√£o de at√© 300 segundos (5 minutos).');
            return;
        }
        await renderAndDownloadWAV(duration);
    });

    function initializeApp() {
        ui.play.addEventListener('click', onPlay);
        ui.pause.addEventListener('click', onPause);
        ui.stop.addEventListener('click', onStop);
        ui.previous.addEventListener('click', onPrevious);
        
        ui.muteBass.addEventListener('click', () => toggleMute('bass', ui.muteBass));
        ui.muteDrums.addEventListener('click', () => toggleMute('drums', ui.muteDrums));
        ui.muteClean.addEventListener('click', () => toggleMute('clean', ui.muteClean));
        ui.muteDist.addEventListener('click', () => toggleMute('dist', ui.muteDist));
        ui.mutePianoString.addEventListener('click', () => toggleMute('pianoString', ui.mutePianoString));
        ui.muteEcho.addEventListener('click', () => toggleMute('echo', ui.muteEcho));
        ui.muteCleanPicked.addEventListener('click', () => toggleMute('cleanPicked', ui.muteCleanPicked));
        ui.muteOrgan.addEventListener('click', () => toggleMute('organ', ui.muteOrgan));
        
        ui.btnMelodyAdd.addEventListener('click', addMelodyBlock);
        ui.btnMelodyClear.addEventListener('click', clearMelodyBlocks);
        
        if (ui.btnOpenManual) {
            ui.btnOpenManual.addEventListener('click', () => { window.open('jam-on-composicao-manual.html', '_blank'); });
        }
        
        // Mobile picker initialization removed here
        updateMelodyInstrumentSelect();
        
        const buttons = document.querySelectorAll('button');
        buttons.forEach(btn => { btn.disabled = false; btn.style.opacity = '1'; });
        
        updateMuteButtonUI('bass', ui.muteBass);
        updateMuteButtonUI('drums', ui.muteDrums);
        updateMuteButtonUI('clean', ui.muteClean);
        updateMuteButtonUI('dist', ui.muteDist);
        updateMuteButtonUI('pianoString', ui.mutePianoString);
        updateMuteButtonUI('echo', ui.muteEcho);
        updateMuteButtonUI('cleanPicked', ui.muteCleanPicked);
        updateMuteButtonUI('organ', ui.muteOrgan);

        // Adiciona pr√©-carregamento inicial de performance
        setTimeout(() => {
            if (audio.ctx && audio.ctx.state === 'suspended') {
                audio.ctx.resume().then(() => { console.log('‚úÖ Audio context pr√©-aquecido'); });
            }
            preloadAllSamples().then(() => { console.log('‚úÖ Samples essenciais pr√©-carregados'); })
            .catch(err => { console.warn('‚ùå Pr√©-carregamento falhou:', err); });
        }, 1000);
    }

    function updateMuteButtonUI(type, button) {
        let icon, label;
        if (type === 'pianoString') { icon = mute[type] ? 'üîá' : 'üéπ'; label = 'Piano'; }
        else if (type === 'echo') { icon = mute[type] ? 'üîá' : 'üé∏'; label = 'Guitarra Echo'; }
        else if (type === 'cleanPicked') { icon = mute[type] ? 'üîá' : 'üé∏'; label = 'Guitarra Dedilhada'; }
        else if (type === 'organ') { icon = mute[type] ? 'üîá' : 'ü™ò'; label = '√ìrg√£o'; }
        else {
            icon = mute[type] ? 'üîá' : (type === 'bass' ? 'üé∏' : (type === 'drums' ? 'ü•Å' : (type === 'clean' ? 'üé∏' : 'üî•')));
            const labelMap = { bass: 'Baixo', drums: 'Bateria', clean: 'Limpa', dist: 'Distor√ß√£o' };
            label = labelMap[type];
        }
        button.textContent = `${icon} ${label}`;
        button.classList.toggle('muted', mute[type]);
    }

    window.addEventListener('load', initializeApp);

    const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const NOTE_TO_INDEX = {};
    NOTES.forEach((note, i) => NOTE_TO_INDEX[note] = i);

    const PROGRESSIONS = [
        "I ‚Äì IV ‚Äì V", "I ‚Äì V ‚Äì vi ‚Äì IV", "I ‚Äì vi ‚Äì IV ‚Äì V", "I ‚Äì V ‚Äì IV ‚Äì I", "vi ‚Äì IV ‚Äì I ‚Äì V",
        "I ‚Äì V ‚Äì vi ‚Äì iii ‚Äì IV ‚Äì I ‚Äì IV ‚Äì V", "I ‚Äì iii ‚Äì IV ‚Äì V", "I ‚Äì IV ‚Äì I ‚Äì V", "I ‚Äì V ‚Äì vi ‚Äì iii ‚Äì IV ‚Äì I ‚Äì IV ‚Äì V",
        "I ‚Äì V ‚Äì IV ‚Äì vi", "ii ‚Äì V ‚Äì I", "I ‚Äì IV ‚Äì V ‚Äì I", "I ‚Äì V ‚Äì I", "IV ‚Äì V ‚Äì I", "ii ‚Äì V ‚Äì I ‚Äì vi",
        "I ‚Äì V ‚Äì vi ‚Äì IV ‚Äì ii ‚Äì V ‚Äì I", "V ‚Äì vi ‚Äì IV ‚Äì I", "I ‚Äì V ‚Äì IV ‚Äì ii ‚Äì V ‚Äì I", "vi ‚Äì ii ‚Äì V ‚Äì I", "I ‚Äì IV ‚Äì ii ‚Äì V",
        "I7 ‚Äì IV7 ‚Äì V7", "I7 ‚Äì IV7 ‚Äì I7 ‚Äì V7", "I7 ‚Äì I7 ‚Äì IV7 ‚Äì I7 ‚Äì V7 ‚Äì IV7 ‚Äì I7 ‚Äì V7", "I7 ‚Äì IV7 ‚Äì V7 ‚Äì IV7",
        "I ‚Äì bVII ‚Äì IV ‚Äì I", "I ‚Äì bVII ‚Äì bIII ‚Äì IV", "I ‚Äì IV ‚Äì V ‚Äì IV", "I ‚Äì V ‚Äì IV ‚Äì bVII", "I ‚Äì IV ‚Äì vii¬∞ ‚Äì iii ‚Äì vi ‚Äì ii ‚Äì V ‚Äì I",
        "I ‚Äì vi ‚Äì ii ‚Äì V", "iii ‚Äì vi ‚Äì ii ‚Äì V ‚Äì I", "vi ‚Äì ii ‚Äì V ‚Äì I", "I ‚Äì V ‚Äì ii ‚Äì V ‚Äì I", "I ‚Äì vi ‚Äì IV ‚Äì V",
        "i ‚Äì VII ‚Äì VI ‚Äì VII", "i ‚Äì VI ‚Äì III ‚Äì VII", "i ‚Äì v ‚Äì VI ‚Äì v", "I ‚Äì bVII ‚Äì IV ‚Äì I", "I ‚Äì bIII ‚Äì bVII ‚Äì IV",
        "I ‚Äì V ‚Äì bVII ‚Äì IV", "I ‚Äì bVII ‚Äì bVI ‚Äì V", "I ‚Äì ii ‚Äì IV ‚Äì V", "I ‚Äì IV ‚Äì bVII ‚Äì IV", "ii ‚Äì V ‚Äì I ‚Äì IV",
        "I ‚Äì vi ‚Äì ii ‚Äì V ‚Äì I", "Imaj7 ‚Äì IVmaj7 ‚Äì V7 ‚Äì Imaj7", "ii7 ‚Äì V7 ‚Äì Imaj7 ‚Äì vi7", "iii7 ‚Äì vi7 ‚Äì ii7 ‚Äì V7",
        "Imaj7 ‚Äì vi7 ‚Äì ii7 ‚Äì V7", "I ‚Äì V/vi ‚Äì vi ‚Äì IV", "Imaj7 ‚Äì V7 ‚Äì iii7 ‚Äì vi7 ‚Äì ii7 ‚Äì V7 ‚Äì Imaj7"
    ];

    function romanToChord(roman, rootNote, isMajor = true) {
        let base = roman.replace(/[^ivIVX¬∞b\/]/g, '');
        let suffix = roman.replace(base, '');
        let flat = false;
        if (base.startsWith('b')) { flat = true; base = base.substring(1); }
        const degreeMap = { 'I': 0, 'II': 2, 'III': 4, 'IV': 5, 'V': 7, 'VI': 9, 'VII': 11 };
        const minorDegreeMap = { 'i': 0, 'ii': 2, 'iii': 3, 'iv': 5, 'v': 7, 'vi': 8, 'vii': 10 };
        let rootIndex = NOTE_TO_INDEX[rootNote];
        let interval;
        if (base in degreeMap) {
            interval = degreeMap[base];
        } else if (base.toLowerCase() in minorDegreeMap) {
            interval = minorDegreeMap[base.toLowerCase()];
            if (base === base.toLowerCase()) isMajor = false;
        } else if (base === 'vii¬∞') {
            interval = 10; suffix = '¬∞';
        } else return 'X';
        if (flat) interval -= 1;
        let noteIndex = (rootIndex + interval) % 12;
        let note = NOTES[noteIndex];
        if (suffix.includes('¬∞')) return note + '¬∞';
        else if (roman.startsWith('i') && roman[1] !== 'I') {
            if (!suffix || suffix === '7' || suffix === '9') return note + 'm' + suffix;
            else return note + suffix;
        } else if (roman.startsWith('I') || roman.startsWith('V/') || roman.includes('maj')) return note + suffix;
        else if (roman.startsWith('ii') || roman.startsWith('iii') || roman.startsWith('vi') || roman.startsWith('vii')) {
            if (!suffix || suffix === '7') return note + 'm' + suffix;
            else return note + suffix;
        } else return note + suffix;
    }

    function generateRandomProgression() {
        const rootNote = NOTES[Math.floor(Math.random() * NOTES.length)];
        const progressionRoman = PROGRESSIONS[Math.floor(Math.random() * PROGRESSIONS.length)];
        const chords = progressionRoman.split(' ‚Äì ').map(roman => romanToChord(roman, rootNote, true));
        const progressionText = chords.join(' ‚Äì ');
        document.getElementById('generatedChordProgression').textContent = progressionText;
        document.getElementById('generatedChordProgressionRoman').textContent = `(${progressionRoman})`;
    }

    const genBtn = document.getElementById('btnGenerateChordProgression');
    if (genBtn && !genBtn.hasListener) {
        genBtn.addEventListener('click', generateRandomProgression);
        genBtn.hasListener = true;
    }
  </script>
</body>
</html>
