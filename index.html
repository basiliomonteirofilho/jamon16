<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gerador de Treinamento – Jam On</title>
</head>
<body>
  <h2>🧠 Gerando 100 músicas para treinamento...</h2>
  <p id="log">Iniciando...</p>

  <script>
    // ===== CONSTANTES MUSICAIS =====
    const PITCHES = ['A','AS','B','C','CS','D','DS','E','F','FS','G','GS'];
    const DEGREE_TO_ROOT = { 1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11 };
    const CHORD_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    const DRUMS = {
        bu: 'bumbo', ca: 'caixa', ch: 'chimbal', ba: 'bumbo-ataque',
        cch: 'caixa-chimbal', co: 'conducao', bco: 'bumbo-conducao',
        cco: 'caixa-conducao', to1: 'tom-1', to2: 'tom-2', su: 'surdo', bch: 'bumbo-chimbal'
    };
    const BASS_SAMPLES = {};
    for (const p of PITCHES) {
        BASS_SAMPLES[p] = `assets/bass-${p}.mp3`;
        if (p.endsWith('S')) BASS_SAMPLES[`${p.replace('S','')}8S`] = `assets/bass-${p.replace('S','')}8S.mp3`;
        else BASS_SAMPLES[`${p}8`] = `assets/bass-${p}8.mp3`;
    }
    BASS_SAMPLES['x'] = 'assets/bass-muted.mp3';

    const STYLE_PROGRESSIONS = {
        Rock: [[1,4,5,1], [1,5,6,4], [6,4,1,5]],
        Blues: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]],
        Forró: [[1,5,1,5,4,5,4,5]],
        Samba: [[2,5,1,1], [1,4,5,1]],
        Metal: [[1,3,5,6,1,2,3,4], [1,3,4,5], [2,5,1,5]],
        Jazz: [[1,2,5,1], [2,5,1,4], [3,6,2,5]]
    };

    const ALL_GROOVES = [
        { name: "Rock", meter: "4/4", drumPattern: ["bch - ch - cch - ch - bch - ch - cch - ch bu"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8] },
        { name: "Blues", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 7, 8, 7, 5, 3] },
        { name: "Forró", meter: "2/4", drumPattern: ["bch co ch bu bco ch cch"], bassRhythm: ["bo - - - bo - - x"], bassScale: [8, 1] },
        { name: "Samba", meter: "2/4", drumPattern: ["bch - ch bu bch - ch bu"], bassRhythm: ["bo - - x bo - - x"], bassScale: [8, 5] },
        { name: "Metal", meter: "4/4", drumPattern: ["bch bu bch bu cch bu bch bu bch bu bch bu cch bu bch bu"], bassRhythm: ["bo bo bo bo bo bo bo bo bo bo bo bo bo bo bo bo"], guitarRhythm: ["ab ab ab ab so - - - ab - ab - so - - -"] },
        { name: "Jazz", meter: "4/4", drumPattern: ["bch co co - co co co ca bch co co - bch co co cch"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: "chromatic" }
    ];

    // ===== ESTADO =====
    let audioCtx = null;
    const buffers = { drums: {}, bass: {}, guitar: {} };
    const mute = { drums: false, bass: false, clean: false, dist: false, pianoString: false, echo: false, cleanPicked: false, organ: false };

    // ===== UTILS =====
    function log(msg) {
        document.getElementById('log').textContent += `\n${msg}`;
        console.log(msg);
    }

    function meterToBeats(meter) {
        return Number(meter.split('/')[0]) || 4;
    }

    async function initAudio() {
        if (audioCtx) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    async function loadBuffer(url) {
        try {
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const arrayBuffer = await res.arrayBuffer();
            return await audioCtx.decodeAudioData(arrayBuffer);
        } catch (e) {
            console.warn(`Erro ao carregar: ${url}`);
            return null;
        }
    }

    function expandRhythm(patternArray, totalSteps) {
        const joined = patternArray.join(' ').replace(/\s+/g, ' ').trim();
        const tokens = joined.split(/\s+/).filter(t => t);
        const out = [];
        while (out.length < totalSteps) {
            for (const token of tokens) {
                if (out.length >= totalSteps) break;
                out.push(token);
            }
        }
        return out.slice(0, totalSteps);
    }

    function parsePattern(patternText) {
        const result = { intro: [], loop: [] };
        const introMatch = patternText.match(/\[(.*?)\]/);
        const loopMatch = patternText.match(/\((.*?)\)/);
        if (introMatch) result.intro = introMatch[1].trim().split(/\s+/).filter(s => s);
        if (loopMatch) result.loop = loopMatch[1].trim().split(/\s+/).filter(s => s);
        if (!introMatch && !loopMatch) result.loop = patternText.trim().split(/\s+/).filter(s => s);
        if (!result.loop.length) result.loop = result.intro.slice();
        return result;
    }

    function getBassNotesFromScale(degree, scale, chordType, isMinorGlobal, keyIdx) {
        let isMinor = false;
        if ([1, 4, 5].includes(degree)) isMinor = isMinorGlobal;
        else isMinor = chordType.startsWith('m') || chordType.includes('dim') || ['5+', '75+', '95+'].includes(chordType);

        if (scale === "chromatic") {
            const rootIdx = (keyIdx + DEGREE_TO_ROOT[degree]) % 12;
            return Array(8).fill().map((_, i) => {
                const noteIdx = (rootIdx - i + 12) % 12;
                const p = PITCHES[noteIdx];
                return p.endsWith('S') ? `${p.replace('S', '')}8S` : `${p}8`;
            });
        }
        if (Array.isArray(scale)) {
            const rootIdx = (keyIdx + DEGREE_TO_ROOT[degree]) % 12;
            return scale.map(interval => {
                let intervalOffset;
                if (isMinor) {
                    const minorIntervals = {1:0,2:2,3:3,4:5,5:7,6:8,7:10,8:12};
                    intervalOffset = minorIntervals[interval] || 0;
                } else {
                    const majorIntervals = {1:0,2:2,3:4,4:5,5:7,6:9,7:11,8:12};
                    intervalOffset = majorIntervals[interval] || 0;
                }
                const noteIdx = (rootIdx + intervalOffset) % 12;
                const octave = interval === 1 ? '' : '8';
                const noteName = PITCHES[noteIdx];
                return interval === 1 ? noteName : (noteName.endsWith('S') ? `${noteName.replace('S', '')}${octave}S` : `${noteName}${octave}`);
            });
        }
        return [PITCHES[(keyIdx + DEGREE_TO_ROOT[degree]) % 12]];
    }

    // ===== FUNÇÃO PRINCIPAL =====
    async function generateSyntheticTrainingBatch(count = 100) {
        await initAudio();
        log(`Iniciando geração de ${count} músicas...`);

        // Carrega samples básicos de bateria e baixo
        const drumPromises = Object.entries(DRUMS).map(([key, name]) =>
            loadBuffer(`assets/${name}.mp3`).then(buf => { if (buf) buffers.drums[key] = buf; })
        );
        const bassPromises = Object.entries(BASS_SAMPLES).map(([key, url]) =>
            loadBuffer(url).then(buf => { if (buf) buffers.bass[key] = buf; })
        );
        await Promise.all([...drumPromises, ...bassPromises]);

        const results = [];

        for (let i = 1; i <= count; i++) {
            log(`Gerando música ${i}/${count}...`);

            // 1. Gera plano musical aleatório
            const groove = ALL_GROOVES[Math.floor(Math.random() * ALL_GROOVES.length)];
            const styleKey = groove.name.replace(/\d+$/, '');
            const progressions = STYLE_PROGRESSIONS[styleKey] || STYLE_PROGRESSIONS.Rock;
            let prog = progressions[Math.floor(Math.random() * progressions.length)].filter(p => p !== 7);
            if (prog.length === 0) prog = [1,4,5,1];

            const keyIdx = Math.floor(Math.random() * PITCHES.length);
            const key = PITCHES[keyIdx];
            const quality = Math.random() > 0.5 ? 'maj' : 'min';
            const bpm = groove.name.includes("Samba") ? 70 : (80 + Math.floor(Math.random() * 100));
            const meter = groove.meter;
            const beats = meterToBeats(meter);
            const sixteenthsPerBar = beats * 4;
            const totalBars = Math.min(prog.length, 16);
            const totalSteps = sixteenthsPerBar * totalBars;

            // Variação global de acorde
            let globalVar = '';
            if (styleKey === "Blues") globalVar = '7';
            else {
                const vars = ['', '11', '13', '4', '5', '6', '7', '9', 'm', 'm4', 'm5', 'm6', 'm7', 'm79', 'm9'];
                globalVar = vars[Math.floor(Math.random() * vars.length)];
            }

            const chordPlan = [];
            const bassPlan = [];
            for (let bar = 0; bar < totalBars; bar++) {
                const degree = prog[bar];
                const rootIdx = (keyIdx + DEGREE_TO_ROOT[degree]) % 12;
                const rootNote = PITCHES[rootIdx];
                let chordType = '';
                if (styleKey === "Blues") chordType = globalVar;
                else {
                    if ([1,4,5].includes(degree)) chordType = globalVar.startsWith('m') ? '' : globalVar;
                    else if ([2,3,6].includes(degree)) chordType = globalVar.startsWith('m') || globalVar === 'dim' ? globalVar : 'm';
                    else if (degree === 7) chordType = 'dim';
                }
                chordPlan.push({ note: rootNote, type: chordType });
                const bassNotes = getBassNotesFromScale(degree, groove.bassScale, chordType, quality === 'min', keyIdx);
                const stepsInBar = sixteenthsPerBar;
                const notesPerBar = Math.ceil(stepsInBar / bassNotes.length);
                const fullBassNotes = Array(stepsInBar).fill().map((_, i) => bassNotes[Math.floor(i / notesPerBar)] || bassNotes[0]);
                const rhythm = expandRhythm(groove.bassRhythm, totalSteps);
                for (let stepInBar = 0; stepInBar < stepsInBar; stepInBar++) {
                    const step = bar * stepsInBar + stepInBar;
                    const sym = rhythm[step] || '-';
                    bassPlan.push(sym === 'x' ? 'x' : (sym === '-' ? '-' : fullBassNotes[stepInBar]));
                }
            }

            // Drum sequence
            const drumParsed = parsePattern(groove.drumPattern.join(' '));
            const drumSeq = [...drumParsed.intro, ...drumParsed.loop];
            const drumExpanded = [];
            while (drumExpanded.length < bassPlan.length) {
                for (const t of drumSeq) {
                    if (drumExpanded.length >= bassPlan.length) break;
                    drumExpanded.push(t);
                }
            }

            // Guitar plan (se houver)
            let guitarPlan = null;
            if (groove.guitarRhythm) {
                guitarPlan = expandRhythm(groove.guitarRhythm, bassPlan.length);
            }

            // 2. Carrega buffers dos acordes usados
            const guitarUrls = new Set();
            for (const ch of chordPlan) {
                const name = ch.note + (ch.type || '');
                const paths = [
                    `guitarraDistorcao/${ch.note}/${name}.mp3`,
                    `guitarraDistorcao/abafadas/${ch.note}/${name}.mp3`,
                    `guitarraDistorcao/dedilhada/${ch.note}/${name}.mp3`,
                    `guitarraLimpa/${ch.note}/${name}.mp3`,
                    `assets/PianoStringChord/${ch.note}/${name}.mp3`,
                    `GuitarraEcho/${ch.note}/${name}.mp3`,
                    `GuitarraLimpaDedilhada/${ch.note}/${name}.mp3`,
                    `Orgao/${ch.note}/${name}.mp3`
                ];
                paths.forEach(p => guitarUrls.add(p));
            }

            const preloadPromises = [];
            for (const url of guitarUrls) {
                if (!buffers.guitar) buffers.guitar = {};
                if (!buffers.guitar[url]) {
                    preloadPromises.push(loadBuffer(url).then(buf => { if (buf) buffers.guitar[url] = buf; }));
                }
            }
            await Promise.all(preloadPromises);

            // 3. Renderiza áudio offline
            const duration = 30;
            const sampleRate = 44100;
            const totalLength = Math.ceil(duration * sampleRate);
            const offlineCtx = new OfflineAudioContext(2, totalLength, sampleRate);

            const master = offlineCtx.createGain();
            const mix = offlineCtx.createGain();
            const gains = {
                drum: offlineCtx.createGain(),
                bass: offlineCtx.createGain(),
                clean: offlineCtx.createGain(),
                dist: offlineCtx.createGain(),
                piano: offlineCtx.createGain(),
                echo: offlineCtx.createGain(),
                cleanPicked: offlineCtx.createGain(),
                organ: offlineCtx.createGain()
            };
            master.gain.value = 0.9;
            Object.values(gains).forEach(g => g.gain.value = 0.5);
            master.connect(mix);
            mix.connect(offlineCtx.destination);
            Object.values(gains).forEach(g => g.connect(master));

            // Últimos sources agendados (para interromper)
            const lastSources = {
                bass: null, clean: null, dist: null, piano: null,
                echo: null, cleanPicked: null, organ: null
            };

            const sixteenthDur = 60 / bpm / 4;
            const stepsPerBar = beats * 4;
            const totalStepsRender = Math.floor(duration / sixteenthDur);

            for (let stepIdx = 0; stepIdx < totalStepsRender; stepIdx++) {
                const time = stepIdx * sixteenthDur;
                const isNewBar = (stepIdx % stepsPerBar) === 0;
                const chordIndex = Math.floor(stepIdx / stepsPerBar) % chordPlan.length;
                const chord = chordPlan[chordIndex];
                const maxDur = Math.min(2.0, sixteenthDur * stepsPerBar);

                // Bateria (não interrompe, samples curtos)
                if (!mute.drums) {
                    const token = drumSeq[stepIdx % drumSeq.length];
                    const drumKey = Object.keys(DRUMS).find(k => DRUMS[k] === token || k === token);
                    if (drumKey && buffers.drums[drumKey]) {
                        const src = offlineCtx.createBufferSource();
                        const g = offlineCtx.createGain();
                        src.buffer = buffers.drums[drumKey];
                        src.connect(g);
                        g.connect(gains.drum);
                        g.gain.setValueAtTime(0.0, time);
                        g.gain.linearRampToValueAtTime(1.0, time + 0.005);
                        src.start(time);
                    }
                }

                // Baixo (interrompe anterior)
                if (!mute.bass) {
                    const bassCmd = bassPlan[stepIdx % bassPlan.length];
                    if (bassCmd !== '-' && bassCmd !== 'x' && buffers.bass[bassCmd]) {
                        if (lastSources.bass) try { lastSources.bass.stop(time); } catch(e) {}
                        const src = offlineCtx.createBufferSource();
                        const g = offlineCtx.createGain();
                        src.buffer = buffers.bass[bassCmd];
                        src.connect(g);
                        g.connect(gains.bass);
                        g.gain.setValueAtTime(0.0, time);
                        g.gain.linearRampToValueAtTime(1.0, time + 0.01);
                        src.start(time);
                        src.stop(Math.min(time + buffers.bass[bassCmd].duration, time + maxDur, duration));
                        lastSources.bass = src;
                    }
                }

                // Instrumentos harmônicos (tocam no início do compasso, interrompem anterior)
                if (chord && isNewBar) {
                    const fullChordName = chord.note + (chord.type || '');
                    const instruments = [
                        { key: 'clean', folder: 'guitarraLimpa' },
                        { key: 'piano', folder: 'assets/PianoStringChord' },
                        { key: 'echo', folder: 'GuitarraEcho' },
                        { key: 'cleanPicked', folder: 'GuitarraLimpaDedilhada' },
                        { key: 'organ', folder: 'Orgao' }
                    ];
                    instruments.forEach(inst => {
                        const url = `${inst.folder}/${chord.note}/${fullChordName}.mp3`;
                        const buf = buffers.guitar?.[url];
                        if (buf) {
                            if (lastSources[inst.key]) try { lastSources[inst.key].stop(time); } catch(e) {}
                            const src = offlineCtx.createBufferSource();
                            const g = offlineCtx.createGain();
                            src.buffer = buf;
                            src.connect(g);
                            g.connect(gains[inst.key]);
                            g.gain.setValueAtTime(0.0, time);
                            g.gain.linearRampToValueAtTime(1.0, time + 0.01);
                            src.start(time);
                            src.stop(Math.min(time + buf.duration, time + maxDur, duration));
                            lastSources[inst.key] = src;
                        }
                    });
                }

                // Guitarra distorcida (pode tocar em ritmo)
                if (!mute.dist && chord) {
                    let urlBase = 'guitarraDistorcao';
                    if (guitarPlan) {
                        const cmd = guitarPlan[stepIdx % guitarPlan.length];
                        if (cmd && cmd !== '-') {
                            if (cmd === 'ab') urlBase = 'guitarraDistorcao/abafadas';
                            else if (cmd === 'de') urlBase = 'guitarraDistorcao/dedilhada';
                        }
                    }
                    const url = `${urlBase}/${chord.note}/${chord.note + (chord.type || '')}.mp3`;
                    const buf = buffers.guitar?.[url];
                    if (buf) {
                        if (lastSources.dist) try { lastSources.dist.stop(time); } catch(e) {}
                        const src = offlineCtx.createBufferSource();
                        const g = offlineCtx.createGain();
                        src.buffer = buf;
                        src.connect(g);
                        g.connect(gains.dist);
                        g.gain.setValueAtTime(0.0, time);
                        g.gain.linearRampToValueAtTime(1.0, time + 0.01);
                        src.start(time);
                        src.stop(Math.min(time + buf.duration, time + maxDur, duration));
                        lastSources.dist = src;
                    }
                }
            }

            const renderedBuffer = await offlineCtx.startRendering();

            // 4. Gera rótulos
            const labels = {
                bpm, meter, key, quality, style: groove.name, duration,
                chords: []
            };
            for (let step = 0; step < totalStepsRender; step++) {
                const bar = Math.floor(step / stepsPerBar);
                const chord = chordPlan[bar % chordPlan.length];
                labels.chords.push({
                    start: parseFloat((step * sixteenthDur).toFixed(3)),
                    end: parseFloat(((step + 1) * sixteenthDur).toFixed(3)),
                    chord: chord.note + (chord.type || ''),
                    root: chord.note,
                    quality: chord.type || 'maj'
                });
            }

            // Salva
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const baseName = `training-${String(i).padStart(3, '0')}-${timestamp}`;
            results.push({ baseName, buffer: renderedBuffer, labels });
        }

        // Downloads
        log(`Iniciando downloads de ${count} pares (WAV + JSON)...`);
        results.forEach(({ baseName, buffer, labels }) => {
            // WAV
            const wavBlob = audioBufferToWav(buffer);
            downloadBlob(wavBlob, `${baseName}.wav`);
            // JSON
            const jsonBlob = new Blob([JSON.stringify(labels, null, 2)], { type: 'application/json' });
            downloadBlob(jsonBlob, `${baseName}.json`);
        });

        log(`✅ ${count} músicas geradas com sucesso!`);
    }

    // ===== FUNÇÕES DE UTILIDADE =====
    function audioBufferToWav(buffer) {
        const numOfChan = buffer.numberOfChannels;
        const length = buffer.length * numOfChan * 2 + 44;
        const arrayBuffer = new ArrayBuffer(length);
        const view = new DataView(arrayBuffer);
        const channels = [];
        for (let i = 0; i < buffer.numberOfChannels; i++) channels.push(buffer.getChannelData(i));
        function writeString(offset, str) {
            for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
        }
        writeString(0, 'RIFF');
        view.setUint32(4, length - 8, true);
        writeString(8, 'WAVE');
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numOfChan, true);
        view.setUint32(24, 44100, true);
        view.setUint32(28, 44100 * 2 * numOfChan, true);
        view.setUint16(32, 2 * numOfChan, true);
        view.setUint16(34, 16, true);
        writeString(36, 'data');
        view.setUint32(40, length - 44, true);
        let offset = 44;
        for (let i = 0; i < buffer.length; i++) {
            for (let ch = 0; ch < numOfChan; ch++) {
                const sample = Math.max(-1, Math.min(1, channels[ch][i]));
                const s = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                view.setInt16(offset, s, true);
                offset += 2;
            }
        }
        return new Blob([view], { type: 'audio/wav' });
    }

    function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
    }

    // Inicia automaticamente
    window.addEventListener('load', () => {
        generateSyntheticTrainingBatch(100).catch(err => {
            console.error(err);
            log(`❌ Erro: ${err.message}`);
        });
    });
  </script>
</body>
</html>      su: 'surdo', bch: 'bumbo-chimbal'
    };
    const BASS_SAMPLES = {};
    for (const p of PITCHES) {
      BASS_SAMPLES[p] = `assets/bass-${p}.mp3`;
      if (p.endsWith('S')) BASS_SAMPLES[`${p.replace('S','')}8S`] = `assets/bass-${p.replace('S','')}8S.mp3`;
      else BASS_SAMPLES[`${p}8`] = `assets/bass-${p}8.mp3`;
    }
    BASS_SAMPLES['x'] = 'assets/bass-muted.mp3';

    // ===== ESTADO =====
    let audioCtx = null;
    let buffers = { drums: {}, bass: {}, guitar: {} };
    let isRunning = false;

    // ===== UTILS =====
    function log(msg) {
      const el = document.getElementById('log');
      el.innerHTML += `[${new Date().toLocaleTimeString()}] ${msg}<br>`;
      el.scrollTop = el.scrollHeight;
    }

    function meterToBeats(meter) {
      return Number(meter.split('/')[0]) || 4;
    }

    function expandRhythm(patternArray, totalSteps) {
      const joined = patternArray.join(' ').replace(/\s+/g, ' ').trim();
      const tokens = joined.split(/\s+/).filter(t => t);
      const out = [];
      while (out.length < totalSteps) {
        for (const token of tokens) {
          if (out.length >= totalSteps) break;
          out.push(token);
        }
      }
      return out.slice(0, totalSteps);
    }

    function parsePattern(patternText) {
      const result = { intro: [], loop: [] };
      const introMatch = patternText.match(/\[(.*?)\]/);
      const loopMatch = patternText.match(/\((.*?)\)/);
      if (introMatch) result.intro = introMatch[1].trim().split(/\s+/).filter(s => s);
      if (loopMatch) result.loop = loopMatch[1].trim().split(/\s+/).filter(s => s);
      if (!introMatch && !loopMatch) result.loop = patternText.trim().split(/\s+/).filter(s => s);
      if (!result.loop.length) result.loop = result.intro.slice();
      return result;
    }

    async function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    async function loadBuffer(url) {
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const arrayBuffer = await res.arrayBuffer();
        return await audioCtx.decodeAudioData(arrayBuffer);
      } catch (e) {
        console.warn(`Erro ao carregar: ${url}`);
        return null;
      }
    }

    async function ensureBasicSamples() {
      const promises = [];
      for (const [key, name] of Object.entries(DRUMS)) {
        const url = `assets/${name}.mp3`;
        if (!buffers.drums[key]) {
          promises.push(loadBuffer(url).then(buf => { if (buf) buffers.drums[key] = buf; }));
        }
      }
      for (const [key, url] of Object.entries(BASS_SAMPLES)) {
        if (!buffers.bass[key]) {
          promises.push(loadBuffer(url).then(buf => { if (buf) buffers.bass[key] = buf; }));
        }
      }
      await Promise.all(promises);
    }

    // ===== GERAÇÃO DE PROGRESSÃO =====
    function generatePlan() {
      const groove = ALL_GROOVES[Math.floor(Math.random() * ALL_GROOVES.length)];
      const styleKey = groove.name.replace(/\d+$/, '');
      const progressions = STYLE_PROGRESSIONS[styleKey] || STYLE_PROGRESSIONS.Rock;
      let prog = progressions[Math.floor(Math.random() * progressions.length)];
      prog = prog.filter(p => p !== 7); // remove acordes diminutos problemáticos
      const keyIdx = Math.floor(Math.random() * PITCHES.length);
      const key = PITCHES[keyIdx];
      const quality = Math.random() > 0.5 ? 'maj' : 'min';
      const bpm = groove.name.includes("Samba") ? 70 : (80 + Math.floor(Math.random() * 100));
      const meter = groove.meter;
      const beats = meterToBeats(meter);
      const sixteenthsPerBar = beats * 4;
      const totalBars = Math.min(prog.length, 16);
      const totalSteps = sixteenthsPerBar * totalBars;

      // Baixo
      function getBassNotes(degree, scale, chordType) {
        let isMinor = false;
        if ([1,4,5].includes(degree)) isMinor = (quality === 'min');
        else isMinor = chordType.startsWith('m') || chordType.includes('dim') || ['5+','75+','95+'].includes(chordType);
        
        if (scale === "chromatic") {
          const rootIdx = (keyIdx + DEGREE_TO_ROOT[degree]) % 12;
          return Array(8).fill().map((_, i) => {
            const noteIdx = (rootIdx - i + 12) % 12;
            const p = PITCHES[noteIdx];
            return p.endsWith('S') ? `${p.replace('S', '')}8S` : `${p}8`;
          });
        }
        if (Array.isArray(scale)) {
          const rootIdx = (keyIdx + DEGREE_TO_ROOT[degree]) % 12;
          return scale.map(interval => {
            let intervalOffset;
            if (isMinor) {
              const minorIntervals = {1:0,2:2,3:3,4:5,5:7,6:8,7:10,8:12};
              intervalOffset = minorIntervals[interval] || 0;
            } else {
              const majorIntervals = {1:0,2:2,3:4,4:5,5:7,6:9,7:11,8:12};
              intervalOffset = majorIntervals[interval] || 0;
            }
            const noteIdx = (rootIdx + intervalOffset) % 12;
            const noteName = PITCHES[noteIdx];
            return noteName.endsWith('S') ? `${noteName.replace('S', '')}8S` : `${noteName}8`;
          });
        }
        return [PITCHES[(keyIdx + DEGREE_TO_ROOT[degree]) % 12]];
      }

      // Variação global
      let globalVar = '';
      if (styleKey === "Blues") globalVar = '7';
      else {
        const vars = ['', '11', '13', '4', '5', '6', '7', '9', 'm', 'm4', 'm5', 'm6', 'm7', 'm79', 'm9'];
        globalVar = vars[Math.floor(Math.random() * vars.length)];
      }

      const chordPlan = [];
      const bassPlan = [];
      for (let bar = 0; bar < totalBars; bar++) {
        const degree = prog[bar];
        const rootIdx = (keyIdx + DEGREE_TO_ROOT[degree]) % 12;
        const rootNote = PITCHES[rootIdx];
        let chordType = '';
        if (styleKey === "Blues") chordType = globalVar;
        else {
          if ([1,4,5].includes(degree)) chordType = globalVar.startsWith('m') ? '' : globalVar;
          else if ([2,3,6].includes(degree)) chordType = globalVar.startsWith('m') || globalVar === 'dim' ? globalVar : 'm';
          else if (degree === 7) chordType = 'dim';
        }
        chordPlan.push({ note: rootNote, type: chordType });
        const bassNotes = getBassNotes(degree, groove.bassScale, chordType);
        const stepsInBar = sixteenthsPerBar;
        const notesPerBar = Math.ceil(stepsInBar / bassNotes.length);
        const fullBassNotes = Array(stepsInBar).fill().map((_, i) => bassNotes[Math.floor(i / notesPerBar)] || bassNotes[0]);
        const rhythm = expandRhythm(groove.bassRhythm, totalSteps);
        for (let stepInBar = 0; stepInBar < stepsInBar; stepInBar++) {
          const step = bar * stepsInBar + stepInBar;
          const sym = rhythm[step] || '-';
          bassPlan.push(sym === 'x' ? 'x' : (sym === '-' ? '-' : fullBassNotes[stepInBar]));
        }
      }

      // Bateria
      const drumParsed = parsePattern(groove.drumPattern.join(' '));
      const drumSeq = [...drumParsed.intro, ...drumParsed.loop];
      const drumExpanded = [];
      while (drumExpanded.length < bassPlan.length) {
        for (const t of drumSeq) {
          if (drumExpanded.length >= bassPlan.length) break;
          drumExpanded.push(t);
        }
      }

      // Guitarra
      let guitarPlan = null;
      if (groove.guitarRhythm) {
        guitarPlan = expandRhythm(groove.guitarRhythm, bassPlan.length);
      }

      return {
        meter, bpm, key, quality, grooveName: groove.name,
        chordPlan, bassPlan, drumSeq: drumExpanded.slice(0, bassPlan.length), guitarPlan
      };
    }

    // ===== CARREGA BUFFERS DOS ACORDES =====
    async function loadChordBuffers(chordPlan) {
      const urls = new Set();
      for (const ch of chordPlan) {
        const name = ch.note + (ch.type || '');
        const basePaths = [
          `guitarraDistorcao/${ch.note}/${name}.mp3`,
          `guitarraDistorcao/abafadas/${ch.note}/${name}.mp3`,
          `guitarraDistorcao/dedilhada/${ch.note}/${name}.mp3`,
          `guitarraLimpa/${ch.note}/${name}.mp3`,
          `assets/PianoStringChord/${ch.note}/${name}.mp3`,
          `GuitarraEcho/${ch.note}/${name}.mp3`,
          `GuitarraLimpaDedilhada/${ch.note}/${name}.mp3`,
          `Orgao/${ch.note}/${name}.mp3`
        ];
        basePaths.forEach(u => urls.add(u));
      }
      const promises = [];
      for (const url of urls) {
        if (!buffers.guitar) buffers.guitar = {};
        if (!buffers.guitar[url]) {
          promises.push(loadBuffer(url).then(buf => { if (buf) buffers.guitar[url] = buf; }));
        }
      }
      await Promise.all(promises);
    }

    // ===== RENDER OFFLINE =====
    function audioBufferToWav(buffer) {
      const numOfChan = buffer.numberOfChannels;
      const length = buffer.length * numOfChan * 2 + 44;
      const arrayBuffer = new ArrayBuffer(length);
      const view = new DataView(arrayBuffer);
      function writeString(offset, str) {
        for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
      }
      writeString(0, 'RIFF');
      view.setUint32(4, length - 8, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numOfChan, true);
      view.setUint32(24, 44100, true);
      view.setUint32(28, 44100 * 2 * numOfChan, true);
      view.setUint16(32, 2 * numOfChan, true);
      view.setUint16(34, 16, true);
      writeString(36, 'data');
      view.setUint32(40, length - 44, true);
      const channels = [];
      for (let i = 0; i < numOfChan; i++) channels.push(buffer.getChannelData(i));
      let offset = 44;
      for (let i = 0; i < buffer.length; i++) {
        for (let ch = 0; ch < numOfChan; ch++) {
          const sample = Math.max(-1, Math.min(1, channels[ch][i]));
          const s = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
          view.setInt16(offset, s, true);
          offset += 2;
        }
      }
      return new Blob([view], { type: 'audio/wav' });
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    }

    async function renderMusic(plan, duration = 30) {
      await initAudio();
      const sampleRate = 44100;
      const totalLength = Math.ceil(duration * sampleRate);
      const ctx = new OfflineAudioContext(2, totalLength, sampleRate);

      // Cria ganhos
      const master = ctx.createGain();
      const mix = ctx.createGain();
      const gains = {
        drum: ctx.createGain(),
        bass: ctx.createGain(),
        clean: ctx.createGain(),
        dist: ctx.createGain(),
        piano: ctx.createGain(),
        echo: ctx.createGain(),
        cleanPicked: ctx.createGain(),
        organ: ctx.createGain()
      };
      master.gain.value = 0.9;
      Object.values(gains).forEach(g => g.gain.value = 0.5);
      master.connect(mix);
      mix.connect(ctx.destination);
      Object.values(gains).forEach(g => g.connect(master));

      // Agenda sons
      const sixteenthDur = 60 / plan.bpm / 4;
      const beatsPerBar = meterToBeats(plan.meter);
      const stepsPerBar = beatsPerBar * 4;
      const totalSteps = Math.floor(duration / sixteenthDur);

      function playBuffer(buffer, time, gainNode, maxDur = 2.0) {
        if (!buffer || time >= duration) return;
        const src = ctx.createBufferSource();
        const g = ctx.createGain();
        src.buffer = buffer;
        src.connect(g);
        g.connect(gainNode);
        g.gain.setValueAtTime(0.0, time);
        g.gain.linearRampToValueAtTime(1.0, time + 0.01);
        src.start(time);
        src.stop(Math.min(time + buffer.duration, time + maxDur, duration));
      }

      for (let step = 0; step < totalSteps; step++) {
        const time = step * sixteenthDur;
        const isNewBar = (step % stepsPerBar) === 0;
        const chordIndex = Math.floor(step / stepsPerBar) % plan.chordPlan.length;
        const chord = plan.chordPlan[chordIndex];
        const maxDur = Math.min(2.0, sixteenthDur * stepsPerBar);

        // Bateria
        const drumToken = plan.drumSeq[step % plan.drumSeq.length];
        if (drumToken) {
          const drumKey = Object.keys(DRUMS).find(k => DRUMS[k] === drumToken || k === drumToken);
          if (drumKey && buffers.drums[drumKey]) {
            const src = ctx.createBufferSource();
            const g = ctx.createGain();
            src.buffer = buffers.drums[drumKey];
            src.connect(g);
            g.connect(gains.drum);
            g.gain.setValueAtTime(0.0, time);
            g.gain.linearRampToValueAtTime(1.0, time + 0.005);
            src.start(time);
          }
        }

        // Baixo
        const bassCmd = plan.bassPlan[step % plan.bassPlan.length];
        if (bassCmd !== '-' && bassCmd !== 'x' && buffers.bass[bassCmd]) {
          playBuffer(buffers.bass[bassCmd], time, gains.bass, maxDur);
        }

        // Harmônicos (no início do compasso)
        if (chord && isNewBar) {
          const name = chord.note + (chord.type || '');
          const paths = {
            clean: `guitarraLimpa/${chord.note}/${name}.mp3`,
            piano: `assets/PianoStringChord/${chord.note}/${name}.mp3`,
            echo: `GuitarraEcho/${chord.note}/${name}.mp3`,
            cleanPicked: `GuitarraLimpaDedilhada/${chord.note}/${name}.mp3`,
            organ: `Orgao/${chord.note}/${name}.mp3`
          };
          for (const [key, path] of Object.entries(paths)) {
            if (buffers.guitar?.[path]) playBuffer(buffers.guitar[path], time, gains[key], maxDur);
          }
        }

        // Guitarra distorcida
        if (chord) {
          let path = `guitarraDistorcao/${chord.note}/${chord.note + (chord.type || '')}.mp3`;
          if (plan.guitarPlan) {
            const cmd = plan.guitarPlan[step % plan.guitarPlan.length];
            if (cmd && cmd !== '-') {
              let folder = 'guitarraDistorcao';
              if (cmd === 'ab') folder = 'guitarraDistorcao/abafadas';
              else if (cmd === 'de') folder = 'guitarraDistorcao/dedilhada';
              path = `${folder}/${chord.note}/${chord.note + (chord.type || '')}.mp3`;
            }
          }
          if (buffers.guitar?.[path]) playBuffer(buffers.guitar[path], time, gains.dist, maxDur);
        }
      }

      const buffer = await ctx.startRendering();
      return audioBufferToWav(buffer);
    }

    // ===== GERAÇÃO PRINCIPAL =====
    async function generateBatch(count = 100) {
      if (isRunning) return;
      isRunning = true;
      document.getElementById('btnStart').disabled = true;
      log(`Iniciando geração de ${count} músicas...`);

      await initAudio();
      await ensureBasicSamples();

      const results = [];
      for (let i = 1; i <= count; i++) {
        log(`Gerando música ${i}/${count}...`);
        const plan = generatePlan();
        await loadChordBuffers(plan.chordPlan);
        const wavBlob = await renderMusic(plan, 30);

        // Rótulos
        const sixteenthDur = 60 / plan.bpm / 4;
        const beatsPerBar = meterToBeats(plan.meter);
        const stepsPerBar = beatsPerBar * 4;
        const totalSteps = Math.floor(30 / sixteenthDur);
        const chords = [];
        for (let step = 0; step < totalSteps; step++) {
          const bar = Math.floor(step / stepsPerBar);
          const chord = plan.chordPlan[bar % plan.chordPlan.length];
          chords.push({
            start: parseFloat((step * sixteenthDur).toFixed(3)),
            end: parseFloat(((step + 1) * sixteenthDur).toFixed(3)),
            chord: chord.note + (chord.type || ''),
            root: chord.note,
            quality: chord.type || 'maj'
          });
        }
        const jsonBlob = new Blob([JSON.stringify({
          bpm: plan.bpm,
          meter: plan.meter,
          key: plan.key,
          quality: plan.quality,
          style: plan.grooveName,
          duration: 30,
          chords
        }, null, 2)], { type: 'application/json' });

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const baseName = `training-${String(i).padStart(3, '0')}-${timestamp}`;
        results.push({ baseName, wavBlob, jsonBlob });
      }

      // Downloads
      log(`Iniciando downloads de ${count} pares (WAV + JSON)...`);
      results.forEach(({ baseName, wavBlob, jsonBlob }) => {
        downloadBlob(wavBlob, `${baseName}.wav`);
        downloadBlob(jsonBlob, `${baseName}.json`);
      });

      log(`✅ Geração concluída! ${count} músicas prontas.`);
      document.getElementById('btnStart').disabled = false;
      isRunning = false;
    }

    // ===== INICIALIZAÇÃO =====
    document.getElementById('btnStart').addEventListener('click', () => generateBatch(100));
  </script>
</body>
</html>

