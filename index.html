<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jam on ‚Äì Playback Aleat√≥rio</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121822;
      --accent: #5eead4;
      --muted: #7a89a6;
      --text: #e6edf6;
      --danger: #f87171;
      --ok: #86efac;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; background: var(--bg); color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      min-height: 100vh; display: grid; place-items: center;
    }
    .wrap { width: min(1100px, 92vw); }
    header { display:flex; align-items:center; justify-content:space-between; gap:1rem; margin: 2rem 0 1.25rem; }
    h1 { font-size: clamp(1.4rem, 2.2vw, 2rem); margin: 0; letter-spacing: .3px; }
    
    .chord-display {
      grid-column: span 12;
      text-align: center;
      margin: 1rem 0;
    }
    .chord-name {
      font-size: 4rem;
      font-weight: bold;
      color: var(--accent);
      margin: 0;
    }
    .chord-timer {
      font-size: 1.5rem;
      color: var(--ok);
    }

    .card { background: linear-gradient(180deg, #121822, #0d131c); border: 1px solid #1e293b; border-radius: 18px; padding: 1rem; box-shadow: 0 10px 40px rgba(0,0,0,.25); }
    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 12px; }
    .controls { grid-column: span 12; display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .controls button, .controls select, .controls input[type="number"] {
      background: #0f172a; color: var(--text); border: 1px solid #1f2937; border-radius: 12px; padding: .65rem .9rem; font-size: .95rem; outline: none;
    }
    .controls button { cursor: pointer; border-color:#334155; transition: transform .06s ease, background .2s ease, border-color .2s ease; }
    .controls button:hover { transform: translateY(-1px); }
    .controls button.primary { background: #0b3b39; border-color:#134e4a; }
    .controls button.primary[data-state="on"] { background:#065f46; border-color:#0f766e; }
    .controls button.danger { background:#3b0b0b; border-color:#7f1d1d; }
    .pill { background:#0b1320; border:1px solid #1f2a44; padding:.4rem .6rem; border-radius:999px; font-size:.85rem; color: var(--muted); }
    .split { grid-column: span 12; display:grid; grid-template-columns: repeat(12, 1fr); gap:12px; }
    .panel { grid-column: span 6; background:#0b0f16; border:1px solid #1b2538; border-radius:12px; padding:12px; }
    .panel h3 { margin:0 0 8px; font-size:1rem; color:#a6b4cf; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:.92rem; }
    .log { grid-column: span 12; background:#080c12; border:1px dashed #1b283b; border-radius:12px; padding:10px; height: 170px; overflow:auto; white-space: pre-wrap; font-size:.9rem; color:#cbd5e1; }
    .footer { margin: .75rem 0 0; color: var(--muted); font-size:.85rem; }
    .badge { display:inline-block; padding:.15rem .45rem; border-radius:6px; border:1px solid #294256; background:#0b1826; color:#9bd5f0; font-size:.8rem; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .spacer { flex: 1 1 auto; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Jam on ‚Äì Playback Aleat√≥rio (baixo + bateria + guitarra)</h1>
      <div class="pill">Cada pulso do BPM = sem√≠nima</div>
    </header>

    <!-- Visor de acorde -->
    <div class="chord-display">
      <h2 class="chord-name" id="currentChord">‚Äî</h2>
      <div class="chord-timer" id="chordTimer">‚Äî</div>
    </div>

    <section class="card">
      <div class="grid">
        <div class="controls">
          <button id="btnPlay" class="primary">‚ñ∂Ô∏è Play</button>
          <button id="btnPause">‚è∏Ô∏è Pause</button>
          <button id="btnStop" class="danger">‚èπÔ∏è Stop</button>
          <button id="btnSave" class="primary">üíæ Salvar 4 min (MP3)</button>

          <!-- Bot√µes de mute -->
          <span class="spacer"></span>
          <button id="muteBass" data-mute="off">üé∏ Baixo</button>
          <button id="muteDrums" data-mute="off">ü•Å Bateria</button>
          <button id="muteClean" data-mute="off">üé∏ Limpa</button>
          <button id="muteDist" data-mute="off">üî• Distor√ß√£o</button>

          <label class="row">BPM <input id="bpm" type="number" min="40" max="220" value="100" style="width:90px"></label>
          <label class="row">Assinatura
            <select id="meter">
              <option value="auto" selected>aleat√≥ria</option>
              <option>2/4</option>
              <option>3/4</option>
              <option>4/4</option>
              <option>5/4</option>
              <option>6/4</option>
              <option>7/4</option>
            </select>
          </label>
        </div>

        <div class="split">
          <div class="panel" style="grid-column: span 6;">
            <h3>Estado atual</h3>
            <div class="mono" id="state"></div>
            <div class="footer">Ao clicar em <b>Play</b>, gera um novo playback aleat√≥rio.</div>
          </div>
          <div class="panel" style="grid-column: span 6;">
            <h3>Arquivos esperados</h3>
            <div class="mono">
              <div>Coloque os √°udios nas pastas:</div>
              <ul>
                <li><b>guitarraLimpa/[nota]/acorde.mp3</b> (ex: <code>guitarraLimpa/A/A5.mp3</code>)</li>
                <li><b>guitarraDistorcao/[nota]/acorde.mp3</b> (ex: <code>guitarraDistorcao/AS/AS7.mp3</code>)</li>
                <li>Pe√ßas de bateria: <b>bumbo.mp3</b>, <b>caixa.mp3</b>, etc.</li>
                <li>Baixo: <b>bass-A.mp3</b>, <b>bass-AS.mp3</b>, etc.</li>
              </ul>
            </div>
          </div>
          <div class="log mono" id="log"></div>
        </div>
      </div>
    </section>
  </div>

<script>
  // =============================
  // Jam on ‚Äì Playback Personalizado
  // =============================
  const ui = {
    play: document.getElementById('btnPlay'),
    pause: document.getElementById('btnPause'),
    stop: document.getElementById('btnStop'),
    save: document.getElementById('btnSave'),
    muteBass: document.getElementById('muteBass'),
    muteDrums: document.getElementById('muteDrums'),
    muteClean: document.getElementById('muteClean'),
    muteDist: document.getElementById('muteDist'),
    bpm: document.getElementById('bpm'),
    meter: document.getElementById('meter'),
    log: document.getElementById('log'),
    state: document.getElementById('state'),
    currentChord: document.getElementById('currentChord'),
    chordTimer: document.getElementById('chordTimer'),
  };

  const audio = {
    ctx: null,
    master: null,
    mix: null,
    drumGain: null,
    bassGain: null,
    cleanGain: null,
    distGain: null,
    schedulerTimer: null,
    lookahead: 0.1,
    scheduleHorizon: 0.25,
  };

  const PITCHES = ['A','AS','B','C','CS','D','DS','E','F','FS','G','GS'];
  const CHORD_TYPES = [
    'A', 'A4', 'A5', 'A5+', 'A6', 'A7', 'A9', 'A11', 'A13', 'A45+', 'A75+', 'A95+',
    'Adim', 'Am', 'Am4', 'Am5', 'Am5+', 'Am6', 'Am7', 'Am9', 'Am75+', 'Am79'
  ];

  // Mapeamento de graus para notas
  const DEGREE_TO_ROOT = {
    1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11
  };

  // Pe√ßas de bateria
  const DRUMS = {
    chimbal: 'assets/chimbal.mp3',
    chimbalAberto: 'assets/chimbal-aberto.mp3',
    chimbalPedal: 'assets/chimbal-pedal.mp3',
    bumbo: 'assets/bumbo.mp3',
    caixa: 'assets/caixa.mp3',
    conducao: 'assets/conducao.mp3',
    ataque: 'assets/ataque.mp3',
    tom1: 'assets/tom1.mp3',
    tom2: 'assets/tom2.mp3',
    surdo: 'assets/surdo.mp3',
    ba: 'assets/bumbo-ataque.mp3',
    bch: 'assets/bumbo-chimbal.mp3',
    cch: 'assets/caixa-chimbal.mp3',
    bc: 'assets/bumbo-conducao.mp3',
    cc: 'assets/caixa-conducao.mp3'
  };

  // Gera todos os samples de baixo
  const BASS_SAMPLES = (() => {
    const baseOctaves = ['', '8', '16'];
    const table = {};
    for (const p of PITCHES) {
      for (const o of baseOctaves) {
        const note = p.replace('S', '');
        const sharp = p.includes('S') ? 'S' : '';
        const key = o + sharp;
        const filename = `bass-${note}${key || ''}.mp3`;
        table[p + o] = `assets/${filename}`;
      }
    }
    return table;
  })();

  BASS_SAMPLES['X'] = 'assets/bass-muted.mp3';

  // Gera URLs de acordes
  function getChordUrl(type, note, folder) {
    return `${folder}/${note}/${note}${type}.mp3`;
  }

  // Todos os acordes
 // Lista apenas os acordes que VOC√ä TEM gravados
const AVAILABLE_CHORDS = [
  // Acordes em A
  'A', 'A11', 'A13', 'A4', 'A45+', 'A5', 'A5+', 'A6', 'A7', 'A75+', 'A9', 'A95+', 'Adim', 
  'Am', 'Am4', 'Am5', 'Am5+', 'Am6', 'Am7', 'Am75+', 'Am79', 'Am9',

  // Acordes em AS (A#)
  'AS', 'AS11', 'AS13', 'AS4', 'AS45+', 'AS5', 'AS5+', 'AS6', 'AS7', 'AS75+', 'AS9', 'AS95+',
  'ASdim', 'ASm', 'ASm4', 'ASm5', 'ASm5+', 'ASm6', 'ASm7', 'ASm75+', 'ASm79', 'ASm9',

  // Acordes em B
  'B', 'B11', 'B13', 'B4', 'B45+', 'B5', 'B5+', 'B6', 'B7', 'B75+', 'B9', 'B95+', 'Bdim',
  'Bm', 'Bm4', 'Bm5', 'Bm5+', 'Bm6', 'Bm7', 'Bm75+', 'Bm79', 'Bm9',

  // Acordes em C
  'C', 'C11', 'C13', 'C4', 'C45+', 'C5', 'C5+', 'C6', 'C7', 'C75+', 'C9', 'C95+', 'Cdim',
  'Cm', 'Cm4', 'Cm5', 'Cm5+', 'Cm6', 'Cm7', 'Cm75+', 'Cm79', 'Cm9',

  // Acordes em CS (C#)
  'CS', 'CS11', 'CS13', 'CS4', 'CS45+', 'CS5', 'CS5+', 'CS6', 'CS7', 'CS75+', 'CS9', 'CS95+',
  'CSdim', 'CSm', 'CSm4', 'CSm5', 'CSm5+', 'CSm6', 'CSm7', 'CSm75+', 'CSm79', 'CSm9',

  // Acordes em D
  'D', 'D11', 'D13', 'D4', 'D45+', 'D5', 'D5+', 'D6', 'D7', 'D75+', 'D9', 'D95+', 'Ddim',
  'Dm', 'Dm4', 'Dm5', 'Dm5+', 'Dm6', 'Dm7', 'Dm75+', 'Dm79', 'Dm9',

  // Acordes em E
  'E', 'E11', 'E13', 'E4', 'E45+', 'E5', 'E5+', 'E6', 'E7', 'E75+', 'E9', 'E95+', 'Edim',
  'Em', 'Em4', 'Em5', 'Em5+', 'Em6', 'Em7', 'Em75+', 'Em79', 'Em9',

  // Acordes em DS (D#)
  'DS', 'DS11', 'DS13', 'DS4', 'DS45+', 'DS5', 'DS5+', 'DS6', 'DS7', 'DS75+', 'DS9', 'DS95+',
  'DSdim', 'DSm', 'DSm4', 'DSm5', 'DSm5+', 'DSm6', 'DSm7', 'DSm75+', 'DSm79', 'DSm9',

  // Acordes em F
  'F', 'F11', 'F13', 'F4', 'F45+', 'F5', 'F5+', 'F6', 'F7', 'F75+', 'F9', 'F95+', 'Fdim',
  'Fm', 'Fm4', 'Fm5', 'Fm5+', 'Fm6', 'Fm7', 'Fm75+', 'Fm79', 'Fm9',

  // Acordes em FS (F#)
  'FS', 'FS11', 'FS13', 'FS4', 'FS45+', 'FS5', 'FS5+', 'FS6', 'FS7', 'FS75+', 'FS9', 'FS95+',
  'FSdim', 'FSm', 'FSm4', 'FSm5', 'FSm5+', 'FSm6', 'FSm7', 'FSm75+', 'FSm79', 'FSm9',

  // Acordes em G
  'G', 'G11', 'G13', 'G4', 'G45+', 'G5', 'G5+', 'G6', 'G7', 'G75+', 'G9', 'G95+', 'Gdim',
  'Gm', 'Gm4', 'Gm5', 'Gm5+', 'Gm6', 'Gm7', 'Gm75+', 'Gm79', 'Gm9',

  // Acordes em GS (G#)
  'GS', 'GS11', 'GS13', 'GS4', 'GS45+', 'GS5', 'GS5+', 'GS6', 'GS7', 'GS75+', 'GS9', 'GS95+',
  'GSdim', 'GSm', 'GSm4', 'GSm5', 'GSm5+', 'GSm6', 'GSm7', 'GSm75+', 'GSm79', 'GSm9'
];

const GUITAR_CHORDS = {};

['guitarraLimpa', 'guitarraDistorcao'].forEach(folder => {
  AVAILABLE_CHORDS.forEach(chordBase => {
    PITCHES.forEach(note => {
      // Ex: A ‚Üí AA, Am ‚Üí AAm, etc.
      const chordName = note + chordBase.replace(/[A-Z]/, ''); // remove o A inicial
      const filename = chordBase; // nome do arquivo: A.mp3, Am.mp3, etc.
      const key = `${folder}_${note}${chordBase}`;
      GUITAR_CHORDS[key] = `${folder}/${note}/${filename}.mp3`;
    });
  });
});

  // PROGRESS√ïES HARM√îNICAS
  const PROGRESSIONS = [
    [1, 1, 1, 1, 4, 4, 5, 5, 6, 6],
    [1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5],
    [1, 1, 7, 6, 5, 4, 3, 2, 1, 1, 4, 1],
    [1, 1, 1, 1, 5, 5, 5, 5, 6, 6, 6, 4, 4, 5, 5, 1, 1],
    [1, 1, 1, 1, 4, 4, 5, 5],
    [1, 1, 1, 3, 4, 5, 7, 4],
    [6, 4, 1, 1, 1, 5, 5, 4, 4, 5, 5],
    [1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 4, 4, 4, 4, 1, 1, 1, 1],
    [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 1, 1, 1],
    [4, 4, 4, 4, 5, 5, 6, 6, 1, 1, 1, 1, 3, 4],
    [1, 1, 1, 1, 2, 2, 4, 4, 5, 5],
    [1, 1, 1, 3, 4, 1, 1, 1, 3, 4, 5, 4, 5, 1, 1, 1, 1],
    [4, 4, 4, 4, 5, 5, 5, 5, 3, 3, 3, 3, 6, 6, 2, 5, 1, 5, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 5, 5, 1, 1, 1, 1, 4, 4, 5, 5, 1, 1, 1, 1]
  ];

  // üõ†Ô∏è CUSTOM_GROOVES (mantido do seu c√≥digo)

  const CUSTOM_GROOVES = [
    // (seu c√≥digo completo aqui, mantido)
    {
      name: "pop rock 1",
      meter: "4/4",
      drumPattern: [
        "ba - - - ch - - - cch - - - ch - - - bch - - -"
      ],
      bassRhythm: [
        "S - - - S - - - S ¬∞ S ¬∞ S ¬∞ S ¬∞"
      ]
    }
    // ... outros estilos
  ];

  const state = {
    running: false,
    paused: false,
    nextNoteTime: 0,
    meter: '4/4',
    bpm: 100,
    sixteenthDur: 0.15,
    stepIndex: 0,
    pattern: [],
    buffers: { drums: {}, bass: {}, guitar: {} },
    lastBassSrc: null,
    bassPlan: [],
    signatureTag: '',
    key: null,
    keyIdx: 0,
    quality: 'maj',
    chordProgression: [],
    chordDurations: [],
    currentGroove: null,
    currentChordIndex: 0,
    barsInChord: 0,
    lastBassAttack: false,
    bassMode: 'arpejo', // 'arpejo' ou 'tonica'
    cleanChordPlayed: false,
    distChordPlayed: false
  };

  // MUTE STATES
  const mute = {
    bass: false,
    drums: false,
    clean: false,
    dist: false
  };

  function log(msg){ ui.log.textContent += `\n${msg}`; ui.log.scrollTop = ui.log.scrollHeight; }

  function setStatePanel(){
    ui.state.innerHTML = `
      <div>Estilo: <b>${state.signatureTag}</b></div>
      <div>Compasso: <b>${state.meter}</b></div>
      <div>BPM: <b>${state.bpm}</b> (semicolcheia = ${(state.sixteenthDur * 1000).toFixed(0)} ms)</div>
      <div>Tom: <b>${state.key} ${state.quality}</b></div>
      <div>Progress√£o: <b>${state.chordProgression.join('-')}</b></div>
    `;
  }

  async function loadBuffer(url) {
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
      const arrayBuffer = await res.arrayBuffer();
      const audioBuffer = await audio.ctx.decodeAudioData(arrayBuffer);
      return audioBuffer;
    } catch (e) {
      log(`[ERRO] Falha ao carregar: ${url} ‚Üí ${e.message}`);
      throw e;
    }
  }

  async function ensureSamples(){
    const promises = [];
    // Bateria
    for (const [k, url] of Object.entries(DRUMS)) {
      if (!state.buffers.drums[k]) {
        promises.push(loadBuffer(url).then(buf => state.buffers.drums[k] = buf));
      }
    }
    // Baixo
    for (const [k, url] of Object.entries(BASS_SAMPLES)) {
      if (!state.buffers.bass[k]) {
        promises.push(loadBuffer(url).then(buf => state.buffers.bass[k] = buf));
      }
    }
    // Guitarra
    for (const [k, url] of Object.entries(GUITAR_CHORDS)) {
      if (!state.buffers.guitar[k]) {
        promises.push(loadBuffer(url).then(buf => state.buffers.guitar[k] = buf));
      }
    }
    await Promise.all(promises);
  }

  function initAudio(){
    if (audio.ctx) return;
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    audio.ctx = ctx;
    audio.master = ctx.createGain();
    audio.master.gain.value = 0.9;

    audio.drumGain = ctx.createGain();
    audio.drumGain.gain.value = 0.85;

    audio.bassGain = ctx.createGain();
    audio.bassGain.gain.value = 0.9;

    audio.cleanGain = ctx.createGain();
    audio.cleanGain.gain.value = 0.8;

    audio.distGain = ctx.createGain();
    audio.distGain.gain.value = 0.8;

    audio.mix = ctx.createMediaStreamDestination();

    // Conecta
    audio.drumGain.connect(audio.master);
    audio.bassGain.connect(audio.master);
    audio.cleanGain.connect(audio.master);
    audio.distGain.connect(audio.master);
    audio.master.connect(audio.mix);
    audio.master.connect(ctx.destination);
  }

  function randItem(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }

  function meterToBeats(meter) {
    const [num, den] = meter.split('/').map(Number);
    return [num, den];
  }

  // === Metr√¥nomo ===
  function playClick(isStrong) {
    const ctx = audio.ctx;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain); gain.connect(audio.drumGain);
    osc.frequency.setValueAtTime(isStrong ? 880 : 440, ctx.currentTime);
    gain.gain.setValueAtTime(0.3, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);
    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + 0.08);
  }

  // === Seleciona estilo aleat√≥rio ===
  function selectRandomGroove() {
    return randItem(CUSTOM_GROOVES);
  }

  // === Constr√≥i plano do baixo ===
  function buildBassPlan() {
    const groove = state.currentGroove;
    state.meter = ui.meter.value === 'auto' ? groove.meter : ui.meter.value;
    const [num, den] = meterToBeats(state.meter);
    const sixteenthsPerBar = num * 4;

    const totalBars = groove.drumPattern.length;
    const totalSteps = totalBars * sixteenthsPerBar;

    state.keyIdx = randInt(0, PITCHES.length - 1);
    state.key = PITCHES[state.keyIdx];
    state.quality = randItem(['maj', 'min']);

    const progression = randItem(PROGRESSIONS);
    state.chordProgression = progression;

    const durations = [];
    let current = progression[0], count = 1;
    for (let i = 1; i < progression.length; i++) {
      if (progression[i] === current) count++;
      else { durations.push(count); current = progression[i]; count = 1; }
    }
    durations.push(count);
    state.chordDurations = durations;
    state.currentChordIndex = 0;
    state.barsInChord = 0;
    state.bassMode = 'arpejo';
    state.bassCycleCount = 0;

    // Mapeamento de acordes
    const chordMap = progression.map(degree => {
      const rootOffset = DEGREE_TO_ROOT[degree] || 0;
      const rootIdx = (state.keyIdx + rootOffset) % 12;
      return state.quality === 'maj' 
        ? [rootIdx, (rootIdx + 4) % 12, (rootIdx + 7) % 12]
        : [rootIdx, (rootIdx + 3) % 12, (rootIdx + 7) % 12];
    });

    const rhythmLines = groove.bassRhythm.flatMap(line => line.split('|').map(s => s.trim()).filter(Boolean));
    const rhythmPattern = [];
    for (let i = 0; i < totalBars; i++) {
      const line = rhythmLines[i % rhythmLines.length];
      const parts = line.split(/\s+/).filter(Boolean);
      rhythmPattern.push(...parts);
    }

    const plan = [];
    let barsInChord = 0;
    let chordIndex = 0;

    for (let step = 0; step < totalSteps; step++) {
      const sixteenthInBar = step % sixteenthsPerBar;
      if (sixteenthInBar === 0) {
        barsInChord++;
        if (barsInChord >= state.chordDurations[chordIndex]) {
          chordIndex = (chordIndex + 1) % progression.length;
          barsInChord = 0;
        }
      }

      const chordNotes = chordMap[chordIndex];
      const root = PITCHES[chordNotes[0]];
      const third = PITCHES[chordNotes[1]];
      const fifth = PITCHES[chordNotes[2]];

      const rhythm = rhythmPattern[step % rhythmPattern.length];
      let note = '-';

      if (rhythm === 'S') {
        if (state.bassMode === 'tonica') {
          note = root;
        } else {
          note = randItem([root, third, fifth]);
        }
      } else if (rhythm === 'x') {
        note = 'X';
      } else if (rhythm === '¬∞' || rhythm === '¬∫') {
        note = '-';
      }

      plan.push(note);
    }

    state.bassPlan = plan;
    state.signatureTag = groove.name;
    updateChordDisplay();
  }

  // === Constr√≥i padr√£o da bateria ===
  function buildDrumPattern() {
    // (mantido do seu c√≥digo)
  }

  // === Toca acorde de guitarra ===
  function playChord(time, chordName, isDistorted) {
    const folder = isDistorted ? 'guitarraDistorcao' : 'guitarraLimpa';
    const key = `${folder}_${chordName}`;
    const buf = state.buffers.guitar[key];
    if (!buf || (isDistorted && mute.dist) || (!isDistorted && mute.clean)) return;

    const src = audio.ctx.createBufferSource();
    const gainNode = isDistorted ? audio.distGain : audio.cleanGain;
    src.buffer = buf;
    src.connect(gainNode);
    src.start(time);
  }

  // === Scheduler ===
  function scheduleStep(time, stepIdx) {
    const cell = state.pattern[stepIdx % state.pattern.length];

    // Bateria
    if (cell && cell !== '-' && !mute.drums) {
      const isSixteenth = stepIdx % 4 !== 0;
      const dynamicGain = isSixteenth ? 0.6 + Math.random() * 0.3 : 1.0;
      cell.split(',').forEach(p => {
        const buf = state.buffers.drums[p];
        if (!buf) return;
        const src = audio.ctx.createBufferSource();
        const gainNode = audio.ctx.createGain();
        src.buffer = buf;
        src.connect(gainNode);
        gainNode.connect(audio.drumGain);
        gainNode.gain.value = 0.8 * dynamicGain;
        src.start(time);
        if (p !== 'ataque' && p !== 'ba') src.stop(time + 0.15);
      });
    }

    // Mudan√ßa de acorde
    const [num, den] = meterToBeats(state.meter);
    const sixteenthsPerBar = num * 4;
    const isNewBar = stepIdx % sixteenthsPerBar === 0;

    if (isNewBar && stepIdx > 0) {
      state.barsInChord++;
      if (state.barsInChord >= state.chordDurations[state.currentChordIndex]) {
        state.currentChordIndex = (state.currentChordIndex + 1) % state.chordProgression.length;
        state.barsInChord = 0;

        // Toca acordes
        const chordName = getCurrentChordName();
        if (!mute.clean) playChord(time, chordName, false);
        if (!mute.dist) playChord(time, chordName, true);

        // Alterna modo do baixo
        if (state.bassMode === 'arpejo') {
          state.bassMode = 'tonica';
          state.bassCycleCount = 0;
        } else if (state.bassMode === 'tonica') {
          state.bassCycleCount++;
          if (state.bassCycleCount >= 2) {
            state.bassMode = 'arpejo';
            state.bassCycleCount = 0;
          }
        }
      }
      updateChordDisplay();
    }

    // Baixo
    const rhythmLines = state.currentGroove.bassRhythm.flatMap(line => line.split('|').map(s => s.trim()).filter(Boolean));
    const rhythmPattern = [];
    for (let i = 0; i < 16; i++) {
      const line = rhythmLines[i % rhythmLines.length];
      const parts = line.split(/\s+/).filter(Boolean);
      rhythmPattern.push(...parts);
    }

    const symbol = rhythmPattern[stepIdx % rhythmPattern.length];
    const bassKey = state.bassPlan[stepIdx % state.bassPlan.length];

    if (symbol === '¬∞' || symbol === '¬∫') {
      if (state.lastBassSrc) try { state.lastBassSrc.stop(time + 0.005); } catch(e){}
      return;
    }

    if (symbol === 'x' && state.buffers.bass['X'] && !mute.bass) {
      if (state.lastBassSrc) try { state.lastBassSrc.stop(time + 0.005); } catch(e){}
      const src = audio.ctx.createBufferSource();
      src.buffer = state.buffers.bass['X'];
      src.connect(audio.bassGain);
      src.start(time);
      src.stop(time + 0.1);
      src.onended = () => { if (state.lastBassSrc === src) state.lastBassSrc = null; };
      state.lastBassSrc = src;
      return;
    }

    if (symbol === 'S' && bassKey && bassKey !== '-' && bassKey !== 'X' && !mute.bass) {
      if (state.lastBassSrc) try { state.lastBassSrc.stop(time + 0.005); } catch(e){}
      const run = async () => {
        if (!state.buffers.bass[bassKey]) {
          try { state.buffers.bass[bassKey] = await loadBuffer(BASS_SAMPLES[bassKey]); }
          catch(e) { return; }
        }
        const src = audio.ctx.createBufferSource();
        src.buffer = state.buffers.bass[bassKey];
        src.connect(audio.bassGain);
        src.start(time);
        src.onended = () => { if (state.lastBassSrc === src) state.lastBassSrc = null; };
        state.lastBassSrc = src;
      };
      run();
    }
  }

  function scheduler() {
    const now = audio.ctx.currentTime;
    while (state.nextNoteTime < now + audio.scheduleHorizon) {
      scheduleStep(state.nextNoteTime, state.stepIndex);
      state.nextNoteTime += state.sixteenthDur;
      state.stepIndex++;
    }
  }

  // === Grava√ß√£o com convers√£o WebM ‚Üí MP3 ===
let recorder = null;
let recChunks = [];
let recTimer = null;

// Elementos de UI adicionais (adicione no HTML se quiser ver a barra)
// <div class="progress-bar" style="width:100%; height:6px; background:#1e293b; border-radius:3px; margin:10px 0; overflow:hidden;">
//   <div id="progressFill" style="width:0%; height:100%; background:#5eead4; transition: width 1s;"></div>
// </div>

// Inicializa o conversor MP3
let mp3Encoder = null;
async function initMp3Encoder() {
  if (mp3Encoder) return mp3Encoder;
  try {
    mp3Encoder = await lamejs.Mp3Encoder({ channels: 2, rate: 44100, kbps: 128 });
    return mp3Encoder;
  } catch (e) {
    log('[MP3] Erro ao carregar encoder: ' + e.message);
    return null;
  }
}

function startRecording() {
  if (!audio.mix) return;
  try {
    recorder = new MediaRecorder(audio.mix.stream, { mimeType: 'audio/webm' });
  } catch (e) {
    log('[REC] Erro ao iniciar grava√ß√£o: ' + e.message);
    return;
  }

  recChunks = [];
  recorder.ondataavailable = e => {
    if (e.data.size) recChunks.push(e.data);
  };

  recorder.onstop = async () => {
    const webmBlob = new Blob(recChunks, { type: 'audio/webm' });
    log('[REC] WebM gravado. Convertendo para MP3...');

    // Convers√£o WebM ‚Üí MP3
    const arrayBuffer = await webmBlob.arrayBuffer();
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

    const samples = audioBuffer.getChannelData(0);
    const samplesRight = audioBuffer.numberOfChannels > 1 ? audioBuffer.getChannelData(1) : samples;

    const mp3 = await initMp3Encoder();
    if (!mp3) {
      log('[MP3] Falha no encoder. Baixando WebM.');
      downloadWebm(webmBlob);
      return;
    }

    const frameSize = 1152;
    const mp3Data = [];

    for (let i = 0; i < samples.length; i += frameSize) {
      const left = samples.subarray(i, i + frameSize);
      const right = samplesRight.subarray(i, i + frameSize);
      const mp3buf = mp3.encodeBuffer(left, right);
      if (mp3buf.length > 0) mp3Data.push(mp3buf);
    }

    const finalMp3 = mp3.flush();
    if (finalMp3.length > 0) mp3Data.push(finalMp3);

    const mp3Blob = new Blob(mp3Data, { type: 'audio/mp3' });

    // ‚úÖ Ativa pr√©via e download
    downloadMp3(mp3Blob);
  };

  // üî• Inicia a grava√ß√£o
  recorder.start();

  // üî• Timer fixo de 4 minutos ‚Äî n√£o pode ser cancelado pelo Stop
  const fixedDuration = 4 * 60 * 1000; // 4 minutos
  const startTime = Date.now();
  const endTime = startTime + fixedDuration;

  const finalTimer = setInterval(() => {
    const now = Date.now();
    if (now >= endTime) {
      if (recorder && recorder.state !== 'inactive') {
        recorder.stop();
      }
      clearInterval(finalTimer);
      log('[‚úÖ] Grava√ß√£o de 4 minutos conclu√≠da e convertida para MP3!');
    } else {
      // üìä Atualiza barra de progresso (0% a 100%)
      const progress = ((now - startTime) / fixedDuration) * 100;
      const progressFill = document.getElementById('progressFill');
      if (progressFill) {
        progressFill.style.width = `${progress}%`;
      }
    }
  }, 1000);

  // Armazena o timer para evitar m√∫ltiplos timers
  if (state.recordingTimer) clearInterval(state.recordingTimer);
  state.recordingTimer = finalTimer;

  log('[REC] Grava√ß√£o iniciada. Dura√ß√£o fixa: 4 minutos (ser√° convertido para MP3).');

  ui.save.disabled = true;
  ui.save.textContent = '‚è≥ Gravando... (4 min)';
}

function stopRecording() {
  // Apenas para a grava√ß√£o se ainda estiver ativa
  if (recorder && recorder.state !== 'inactive') {
    recorder.stop();
  }
  // O timer de 4 minutos continua at√© o fim
}

// Fun√ß√µes de download
function downloadMp3(blob) {
  // üîä Cria pr√©via do √°udio
  const audioPreview = new Audio();
  audioPreview.src = URL.createObjectURL(blob);
  audioPreview.controls = true;
  audioPreview.style.display = 'block';
  audioPreview.style.margin = '10px 0';
  audioPreview.style.width = '100%';
  audioPreview.addEventListener('ended', () => {
    URL.revokeObjectURL(audioPreview.src);
  });

  // Adiciona ao log
  const previewDiv = document.createElement('div');
  previewDiv.innerHTML = '<div><b>üéß Pr√©via do seu playback:</b></div>';
  previewDiv.appendChild(audioPreview);
  ui.log.parentNode.insertBefore(previewDiv, ui.log);

  // üìÖ Nome do arquivo: jam-estilo-YYYYMMDD-HHMM.mp3
  const now = new Date();
  const dateStr = now.getFullYear() +
    String(now.getMonth() + 1).padStart(2, '0') +
    String(now.getDate()).padStart(2, '0') + '-' +
    String(now.getHours()).padStart(2, '0') +
    String(now.getMinutes()).padStart(2, '0');

  const filename = `jam-${state.signatureTag}-${dateStr}.mp3`;

  // üíæ Download
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(a.href);

  log(`[‚úÖ] Arquivo salvo: ${filename}`);

  // ‚úÖ Reativa bot√£o
  ui.save.disabled = false;
  ui.save.textContent = 'üíæ Salvar 4 min (MP3)';
}

function downloadWebm(blob) {
  const now = new Date();
  const dateStr = now.getFullYear() +
    String(now.getMonth() + 1).padStart(2, '0') +
    String(now.getDate()).padStart(2, '0') + '-' +
    String(now.getHours()).padStart(2, '0') +
    String(now.getMinutes()).padStart(2, '0');

  const filename = `jam-${state.signatureTag}-${dateStr}.webm`;

  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(a.href);

  log(`[‚ö†Ô∏è] MP3 falhou. Arquivo salvo: ${filename}`);

  // ‚úÖ Reativa bot√£o
  ui.save.disabled = false;
  ui.save.textContent = 'üíæ Salvar 4 min (MP3)';
}

// === MUTE BUTTONS ===
ui.muteBass.addEventListener('click', () => toggleMute('bass', ui.muteBass));
ui.muteDrums.addEventListener('click', () => toggleMute('drums', ui.muteDrums));
ui.muteClean.addEventListener('click', () => toggleMute('clean', ui.muteClean));
ui.muteDist.addEventListener('click', () => toggleMute('dist', ui.muteDist));

// Fun√ß√£o de mute
function toggleMute(type, button) {
  mute[type] = !mute[type];
  button.dataset.mute = mute[type] ? 'on' : 'off';
  button.textContent = mute[type] ? `üîá ${button.textContent.split(' ')[1]}` : `üîä ${button.textContent.split(' ')[1]}`;
}

  // === Atualiza visor de acorde ===
  function updateChordDisplay() {
    const chordNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const rootNote = chordNames[state.keyIdx];
    const chordType = state.quality === 'maj' ? '' : 'm';
    const currentChord = rootNote + chordType;
    const barsLeft = state.chordDurations[state.currentChordIndex] - state.barsInChord;

    ui.currentChord.textContent = currentChord;
    ui.chordTimer.textContent = `Pr√≥x: ${barsLeft} compasso(s)`;
  }

  function getCurrentChordName() {
    const chordNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const rootNote = chordNames[state.keyIdx];
    const degree = state.chordProgression[state.currentChordIndex];
    const type = state.quality === 'maj' ? (degree === 5 ? '5' : 'A') : 'm';
    return rootNote + type;
  }

  // === Controles ===
  async function onPlay() {
    if (state.running) { onStop(); setTimeout(onPlay, 100); return; }
    initAudio();
    state.currentGroove = selectRandomGroove();
    await ensureSamples();
    buildBassPlan();
    state.pattern = buildDrumPattern();
    state.bpm = Number(ui.bpm.value) || 100;
    state.sixteenthDur = (60 / state.bpm) / 4;
    state.stepIndex = 0;
    state.currentChordIndex = 0;
    state.barsInChord = 0;
    state.bassMode = 'arpejo';
    state.bassCycleCount = 0;

    const [num] = meterToBeats(state.meter);
    const quarterDur = 60 / state.bpm;
    const totalClicks = num * 2;
    const playbackStartTime = audio.ctx.currentTime + 0.1 + totalClicks * quarterDur;
    state.nextNoteTime = playbackStartTime;

    for (let i = 0; i < totalClicks; i++) {
      const isStrong = i % num === 0;
      const clickTime = audio.ctx.currentTime + 0.1 + i * quarterDur;
      setTimeout(() => playClick(isStrong), (clickTime - audio.ctx.currentTime) * 1000);
    }

    setTimeout(() => {
      state.running = true;
      startScheduler();
      ui.play.dataset.state = 'on';
      log(`[PLAY] Estilo: ${state.signatureTag} | ${state.meter} @ ${state.bpm} BPM`);
    }, (playbackStartTime - audio.ctx.currentTime) * 1000);

    setStatePanel();
    updateChordDisplay();
  }

  function onPause() {
    if (state.running && !state.paused) {
      audio.ctx.suspend();
      state.paused = true;
      ui.play.textContent = '‚ñ∂Ô∏è Retomar';
    } else if (state.paused) {
      audio.ctx.resume();
      state.paused = false;
      ui.play.textContent = '‚è∏Ô∏è Pause';
      startScheduler();
    }
  }

  async function onStop() {
    stopScheduler();
    stopRecording();

    if (audio.ctx && audio.ctx.state !== 'closed') {
      try {
        await audio.ctx.close();
      } catch (e) {
        console.warn('[√ÅUDIO] Erro ao fechar AudioContext:', e);
      }
    }
    audio.ctx = null;

    state.running = false;
    state.paused = false;
    state.stepIndex = 0;
    state.pattern = [];
    state.bassPlan = [];
    state.currentGroove = null;

    ui.currentChord.textContent = '‚Äî';
    ui.chordTimer.textContent = '‚Äî';

    ui.play.dataset.state = '';
    ui.play.textContent = '‚ñ∂Ô∏è Play';
    log('[STOP] Pronto para novo playback.');
  }

  function onSave() {
    if (!audio.ctx) return;
    startRecording();
  }

  // === Eventos ===
  ui.play.addEventListener('click', onPlay);
  ui.pause.addEventListener('click', onPause);
  ui.stop.addEventListener('click', onStop);
  ui.save.addEventListener('click', onSave);

  log('üîß Personalize em CUSTOM_GROOVES. Pressione Play para come√ßar.');
</script>
</body>
</html>