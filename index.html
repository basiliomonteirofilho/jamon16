<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Jam On ‚Äì Playback Aleat√≥rio</title>
  <style>
    body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
  background: #121212;
  color: #e0e0e0;
  margin: 0;
  padding: 20px;
}
header {
  text-align: center;
  margin-bottom: 20px;
}
h1 {
  color: #5eead4;
  font-size: 1.8em;
  margin: 0;
}
.pill {
  display: inline-block;
  background: #333;
  color: #aaa;
  font-size: 0.75em;
  padding: 4px 10px;
  border-radius: 12px;
}
.card {
  max-width: 800px;
  margin: 0 auto;
  background: #1e1e1e;
  border-radius: 16px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  overflow: hidden;
  padding: 20px;
  text-align: left;
}
.chord-display {
  text-align: center;
  margin: 20px 0;
}
.chord-name {
  font-size: 3em;
  color: #5eead4;
  margin: 0;
  font-weight: bold;
}
#chordTimer {
  font-size: 1.1em;
  color: #aaa;
}
#chordProgression {
  margin-top: 12px;
  font-family: monospace;
  font-size: 1.1em;
  white-space: nowrap;
  overflow-x: auto;
  padding: 8px 0;
}
.chord-item {
  display: inline-block;
  padding: 6px 10px;
  margin: 0 4px;
  border-radius: 6px;
  background: #333;
  transition: background 0.3s;
}
.chord-item.current {
  background: #5eead4;
  color: #121212;
  font-weight: bold;
}
.controls {
  display: grid;
  gap: 15px;
  margin-bottom: 20px;
}
.btn-row {
  display: flex;
  justify-content: center;
  gap: 12px;
  flex-wrap: wrap;
}
button {
  padding: 12px 20px;
  border: none;
  border-radius: 8px;
  font-weight: bold;
  cursor: pointer;
  font-size: 1em;
}
button.primary {
  background: #5eead4;
  color: #121212;
}
button.danger {
  background: #f44336;
  color: white;
}
button:hover {
  opacity: 0.9;
}
.mute-buttons {
  display: flex;
  justify-content: center;
  gap: 10px;
  flex-wrap: wrap;
  margin: 10px 0;
}
.mute-buttons button {
  padding: 8px 14px;
  font-size: 0.9em;
}
.mute-buttons button.muted {
  opacity: 0.5;
}
.row {
  display: flex;
  align-items: center;
  gap: 10px;
  justify-content: center;
}
.row label {
  width: 100px;
  text-align: right;
  color: #ccc;
}
input[type="number"], select {
  padding: 8px;
  border-radius: 6px;
  border: 1px solid #444;
  background: #2a2a2a;
  color: #fff;
  width: 90px;
}
select {
  width: auto;
  min-width: 120px;
}
.slider-row {
  display: flex;
  align-items: center;
  gap: 10px;
  justify-content: center;
}
.slider-row label {
  width: 80px;
  text-align: right;
  font-size: 0.9em;
}
input[type="range"] {
  width: 180px;
  accent-color: #5eead4;
}
.slider-value {
  width: 40px;
  text-align: left;
  font-size: 0.9em;
  color: #aaa;
}
.panel {
  margin-top: 20px;
}
.panel h3 {
  color: #5eead4;
  margin-top: 0;
}
.melody-panel {
  margin-top: 20px;
}
.melody-toolbar {
  display: flex;
  gap: 10px;
  align-items: center;
  flex-wrap: wrap;
  justify-content: center;
  margin-bottom: 10px;
}
.melody-block {
  border: 1px solid #444;
  border-radius: 8px;
  padding: 10px;
  margin-bottom: 12px;
  background: #222;
}
.melody-caption {
  font-size: 0.9em;
  color: #ccc;
  margin-bottom: 6px;
}
.melody-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85em;
}
.melody-table th, .melody-table td {
  border: 1px solid #555;
  padding: 2px;
}
.melody-table input {
  width: 100%;
  padding: 4px;
  text-align: center;
  background: #333;
  border: 1px solid #555;
  color: white;
  border-radius: 4px;
}
.line-label {
  font-size: 0.8em;
  color: #aaa;
}
.instructions {
  font-size: 0.85em;
  color: #aaa;
  margin-top: 8px;
  text-align: center;
}
/* === ESTILOS PARA MOBILE === */
@media (max-width: 768px) {
  body {
    padding: 10px;
  }
  .card {
    padding: 15px;
    border-radius: 12px;
  }
  h1 {
    font-size: 1.5em;
  }
  .chord-name {
    font-size: 2em;
  }
  button {
    padding: 14px 22px; /* Aumentado para toque */
    font-size: 1em;
  }
  .row label {
    width: 80px;
    font-size: 0.9em;
  }
  input[type="number"], select {
    width: 70px;
    font-size: 0.9em;
    padding: 10px; /* Aumentado para toque */
  }
  .slider-row label {
    width: 60px;
    font-size: 0.8em;
  }
  input[type="range"] {
    width: 140px;
  }
  .slider-value {
    width: 35px;
    font-size: 0.8em;
  }
  .melody-table {
    font-size: 0.9em; /* Aumentado para melhor leitura */
  }
  .melody-table input {
    height: 40px; /* Aumentado para toque */
    font-size: 0.9em;
    padding: 8px; /* Aumentado para toque */
  }
  .melody-caption {
    font-size: 0.85em;
  }
}
/* === ESTILOS DO PICKER DE N√öMEROS === */
#numberPicker {
  display: none;
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background: #1e1e1e;
  border-top: 2px solid #5eead4;
  padding: 15px;
  box-shadow: 0 -4px 10px rgba(0,0,0,0.5);
  z-index: 1000;
  animation: slideUp 0.3s ease-out;
  /* --- NOVO: Usa grid para 4 colunas --- */
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 10px;
}
@keyframes slideUp {
  from {
    transform: translateY(100%);
  }
  to {
    transform: translateY(0);
  }
}
#numberPicker h3 {
  color: #5eead4;
  text-align: center;
  margin-top: 0;
  margin-bottom: 15px;
  /* --- NOVO: Ocupa todas as 4 colunas --- */
  grid-column: span 4;
}
#numberGrid {
  /* --- REMOVIDO: O grid agora est√° no #numberPicker --- */
}
.number-btn {
  background: #333;
  color: #e0e0e0;
  border: 1px solid #444;
  border-radius: 6px;
  padding: 12px 0; /* Aumentado para toque */
  font-size: 1em;
  cursor: pointer;
  transition: all 0.1s ease;
}
.number-btn:hover {
  background: #444;
}
.number-btn:active {
  transform: scale(0.95);
  background: #5eead4;
  color: #121212;
}
.close-btn {
  /* --- NOVO: Ocupa todas as 4 colunas --- */
  grid-column: span 4;
  background: #f44336;
  color: white;
  font-weight: bold;
}

/* Estilo para o modal da partitura */
#sheetModal {
  display: none;
  position: fixed;
  z-index: 1001;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.8);
}
#sheetContent {
  background-color: #222;
  margin: 5% auto;
  padding: 20px;
  border: 1px solid #5eead4;
  border-radius: 10px;
  width: 90%;
  max-width: 800px;
  text-align: center;
}
#sheetCanvas {
  background: white;
  margin: 20px auto;
  display: block;
  box-shadow: 0 0 10px rgba(0,0,0,0.5);
}
#closeSheet, #downloadSheet {
  margin: 10px 5px;
  padding: 10px 20px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 1em;
}
#closeSheet {
  background-color: #f44336;
  color: white;
}
#downloadSheet {
  background-color: #5eead4;
  color: #121212;
}
  </style>
  <script src="https://unpkg.com/vexflow/releases/vexflow-min.js"></script>
</head>
<body>
  <header>
    <h1>Jam On ‚Äì Playback Aleat√≥rio</h1>
    <div class="pill">Cada pulso do BPM = sem√≠nima</div>
  </header>
  <div class="chord-display">
    <h2 class="chord-name" id="currentChord">‚Äî</h2>
    <div id="chordTimer">‚Äî</div>
    <div id="chordProgression"></div>
  </div>
  <div class="card">
    <div class="controls">
      <div class="btn-row">
        <button id="btnPlay" class="primary">‚ñ∂ Play</button>
        <button id="btnPause">‚è∏ Pause</button>
        <button id="btnStop" class="danger">‚èπ Stop</button>
      </div>
      <div class="mute-buttons">
        <button id="muteBass" data-mute="off">üé∏ Baixo</button>
        <button id="muteDrums" data-mute="off">ü•Å Bateria</button>
        <button id="muteClean" data-mute="off">üé∏ Limpa</button>
        <button id="muteDist" data-mute="off">üî• Distor√ß√£o</button>
      </div>
      <div class="row">
        <label>BPM</label>
        <input id="bpm" type="number" min="40" max="220" value="100">
      </div>
      <div class="row">
        <label>Assinatura</label>
        <select id="meter">
          <option value="auto" selected>aleat√≥ria</option>
          <option>2/4</option>
          <option>3/4</option>
          <option>4/4</option>
          <option>5/4</option>
          <option>6/4</option>
          <option>7/4</option>
        </select>
      </div>
      <div class="row">
        <label>Melodia</label>
        <select id="melodyInstrument">
          <option value="dist">Guitarra Distorcida</option>
          <option value="piano">Piano/String</option>
          <option value="baixo">Baixo</option>
          <option value="sax">Sax</option>
        </select>
      </div>
      <h3 style="color: #5eead4; margin: 15px 0 5px;">Controle de Volume</h3>
      <div class="slider-row">
        <label>Baixo</label>
        <input type="range" id="volBass" min="0" max="1" step="0.01" value="0.45">
        <span class="slider-value" id="volBassLabel">45%</span>
      </div>
      <div class="slider-row">
        <label>Bateria</label>
        <input type="range" id="volDrums" min="0" max="1" step="0.01" value="0.6">
        <span class="slider-value" id="volDrumsLabel">60%</span>
      </div>
      <div class="slider-row">
        <label>Limpa</label>
        <input type="range" id="volClean" min="0" max="1" step="0.01" value="0.45">
        <span class="slider-value" id="volCleanLabel">45%</span>
      </div>
      <div class="slider-row">
        <label>Distorcida</label>
        <input type="range" id="volDist" min="0" max="1" step="0.01" value="0.35">
        <span class="slider-value" id="volDistLabel">35%</span>
      </div>
    </div>
    <div class="panel">
      <h3>Estado Atual</h3>
      <div class="mono" id="state">Parado</div>
    </div>
    <div class="panel melody-panel">
      <h3>üé∏ Melodia Adaptativa</h3>
      <div class="melody-toolbar">
        <button id="btnExportPartitura">üìÑ Exportar Partitura</button>
        <button id="btnMelodyAdd" class="primary">‚ûï Adicionar Bloco</button>
        <button id="btnMelodyClear" class="danger">üßπ Limpar Blocos</button>
        <span style="font-size: 0.9em; color: #aaa;">Notas se estendem at√© pr√≥xima nota ou "x"</span>
      </div>
      <div class="instructions">
        Digite n√∫meros (1-49) para notas, "x" para pausa, ou deixe vazio para continuar nota anterior
      </div>
      <div id="melodyBlocks"></div>
    </div>
  </div>

  <!-- Modal para exibir a partitura -->
  <div id="sheetModal">
    <div id="sheetContent">
      <h2>Partitura Gerada</h2>
      <canvas id="sheetCanvas" width="750" height="300"></canvas>
      <br>
      <button id="downloadSheet">üíæ Baixar PNG</button>
      <button id="closeSheet">‚úñ Fechar</button>
    </div>
  </div>

  <script>
    <script>
   function transposeDown3Semitones(note) {
  const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const index = notes.indexOf(note);
  if (index === -1) return note;
  return notes[(index - 3 + 12) % 12];
}
// Fun√ß√£o para detectar se √© um dispositivo m√≥vel
function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}
const ui = {
  play: document.getElementById('btnPlay'),
  pause: document.getElementById('btnPause'),
  stop: document.getElementById('btnStop'),
  muteBass: document.getElementById('muteBass'),
  muteDrums: document.getElementById('muteDrums'),
  muteClean: document.getElementById('muteClean'),
  muteDist: document.getElementById('muteDist'),
  bpm: document.getElementById('bpm'),
  meter: document.getElementById('meter'),
  state: document.getElementById('state'),
  currentChord: document.getElementById('currentChord'),
  chordTimer: document.getElementById('chordTimer'),
  volBass: document.getElementById('volBass'),
  volDrums: document.getElementById('volDrums'),
  volClean: document.getElementById('volClean'),
  volDist: document.getElementById('volDist'),
  volBassLabel: document.getElementById('volBassLabel'),
  volDrumsLabel: document.getElementById('volDrumsLabel'),
  volCleanLabel: document.getElementById('volCleanLabel'),
  volDistLabel: document.getElementById('volDistLabel'),
  melodyBlocks: document.getElementById('melodyBlocks'),
  btnMelodyAdd: document.getElementById('btnMelodyAdd'),
  btnMelodyClear: document.getElementById('btnMelodyClear'),
  btnExportPartitura: document.getElementById('btnExportPartitura'), // Adicionado
  melodyInstrument: document.getElementById('melodyInstrument'),
  numberPicker: document.getElementById('numberPicker'),
  numberGrid: document.getElementById('numberGrid')
};
const audio = {
  ctx: null,
  master: null,
  mix: null,
  drumGain: null,
  bassGain: null,
  cleanGain: null,
  distGain: null,
  schedulerTimer: null
};
const PITCHES = ['A','AS','B','C','CS','D','DS','E','F','FS','G','GS'];
const DEGREE_TO_ROOT = { 1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11 };
const CHORD_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const DRUMS = {
  bu: 'bumbo',
  ca: 'caixa',
  ch: 'chimbal',
  ba: 'bumbo-ataque',
  cch: 'caixa-chimbal',
  co: 'conducao',
  bco: 'bumbo-conducao',
  cco: 'caixa-conducao',
  to1: 'tom-1',
  to2: 'tom-2',
  su: 'surdo',
  bch: 'bumbo-chimbal'
};
// === CRIA√á√ÉO DOS SAMPLES COM SUSTENIDOS NO FINAL (C8S) ===
const BASS_SAMPLES = {};
for (const p of PITCHES) {
  BASS_SAMPLES[p] = `assets/bass-${p}.mp3`;
  if (p.endsWith('S')) {
    const base = p.replace('S', '');
    BASS_SAMPLES[base + '8S'] = `assets/bass-${base}8S.mp3`;
  } else {
    BASS_SAMPLES[p + '8'] = `assets/bass-${p}8.mp3`;
  }
}
BASS_SAMPLES['x'] = 'assets/bass-muted.mp3';
// === PROGRESS√ïES POR ESTILO ===
const STYLE_PROGRESSIONS = {
  Rock: [[1,4,5,1], [1,5,6,4], [6,4,1,5]],
  Rock2: [[4,5,1,5], [5,4,1,4], [7,4,1,1]],
  Rock3: [[1,4,5,1], [1,3,4,5]],
  Rock4: [[6,4,1,5], [1,4,5,1,4,5,4,5], [1,5,6,4,1,5,6,7]],
  Rock5: [[1,5,7,4], [1,4,5,6], [1,5,6,4]],
  Rock6: [[1,5,6,4], [1,4,5,1], [1,5,6,7]],
  Rock7: [[2,3,5,1], [1,4,7,1], [1,5,3,4]],
  Rock_Progressivo: [[4,5,1,1,4,5,7], [1,4,1,4,5,6,5], [1,4,5,6,3,5,4]],
  Rock_Progressivo2: [[1,4,5,1,5], [4,5,3,1,3,1,4,5,7,5], [1,4,1,4,5]],
  Rock_Progressivo3: [[1,4,5,1,5,7], [1,3,4,5,2,5]],
  Rock_Progressivo4: [[4,5,1,1,4,5,7,5], [1,4,1,4,5,6,5,7], [1,4,5,6,3,5,4,5]],
  Rock_Progressivo5: [[4,5,1,1,4,5,7], [1,4,1,4,5,6,5], [1,4,5,6,3,5,4]], 
  Rock_Progressivo6: [[1,4,5,6,3,5], [1,4,1,4,5,6,5]],
  Rock_Progressivo7: [[4,5,1,1], [1,4,5,1]],      
  Blues: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]],
  Blues2: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]],
  Blues3: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,7]],
  Blues4: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]],
  Blues5: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,7]],
  Blues6: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]],
  Blues7: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]],
  Forr√≥: [[1,5,1,5,4,5,4,5]],
  Samba: [[2,5,1,1], [1,4,5,1]],
  Metal: [[1, 3, 5, 6, 1, 2, 3, 4], [1, 3, 4, 5], [2, 5, 1, 5]],
  Metal2: [[1, 3, 5, 4, 1, 2, 3, 4], [1, 3, 4, 5], [2, 5, 1, 5]],
  Metal3: [[1, 3, 5, 3, 1, 2, 4, 5], [1, 3, 4, 5], [2, 5, 1, 5]],
  Metal: [[1, 3, 5, 6, 1, 2, 3, 4], [1, 3, 4, 5], [2, 5, 1, 5]],
  Jazz: [[1,2,5,1], [2,5,1,4], [3,6,2,5]]
};
// === GROOVES ===
const ALL_GROOVES = [
  { name: "Rock", meter: "4/4", drumPattern: ["bch - ch - cch - ch - bch - ch - cch - ch bu"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8] },
  { name: "Rock2", meter: "4/4", drumPattern: ["bch - ch - cch - ch - bch - ch - cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 1, 1, 5] },
  { name: "Rock3", meter: "4/4", drumPattern: ["bch - ch bu cch bu ch - bch - ch - cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo x bo x bo x"], bassScale: [1, 1, 1, 1] },
  { name: "Rock4", meter: "4/4", drumPattern: ["ba - co - cco - co - bco - co - cco bu bco bu"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 7, 8, 7, 5, 3] },
  { name: "Rock5", meter: "4/4", drumPattern: ["bch ch ch ch cch ch ch ch bch ch ch ch cch ch ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo x bo x bo x"], bassScale: [1, 3, 1, 5] },
  { name: "Rock6", meter: "4/4", drumPattern: ["bco co co co cco co co co bco co co co cco co co co"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [8, 8, 1, 1] },
  { name: "Rock7", meter: "4/4", drumPattern: ["bch - ch - cch - ch - bch - co - cco - co -"], bassRhythm: ["bo - bo - bo bo bo bo bo - bo - bo - bo -"], bassScale: [1, 1, 1, 1] },
  { name: "Rock_Progressivo", meter: "7/4", drumPattern: ["bch - ch -  cch - ch - bch - ch - cch - ch bu bch - ch - cch - ch - bch - ch bu"], bassRhythm: ["bo - - - - - - - bo - - - - - - bo - - bo bo bo bo bo bo bo bo bo bo"], bassScale: [1, 1, 1, 3, 5, 8, 3, 5, 8, 3, 5, 8, 5] },
  { name: "Rock_Progressivo2", meter: "5/4", drumPattern: ["ba - ch - bch - ch - cch - ch - bch - ch - cch - ch bu"], bassRhythm: ["bo - x x bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 1, 1, 1, 3, 5, 8, 1, 3, 5, 8] },
  { name: "Rock_Progressivo3", meter: "6/4", drumPattern: ["ba - - - ch - - bu cch - - - ch - - - bch - - - ch - - -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 1, 1, 3, 1, 1, 1, 3, 5, 5, 5, 1] },
  { name: "Rock_Progressivo4", meter: "4/4", drumPattern: ["ba - ch bu cch - ch - bch - ch bu cch - ch bu"], bassRhythm: ["bo - - bo - - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8] },
  { name: "Rock_Progressivo5", meter: "7/4", drumPattern: ["ba - co -  cco - co - bco - co bu cco - co bu bch bu co - cch - ch - bch - ch bu"], bassRhythm: ["bo - - bo bo - - - bo - - bo bo - - bo - - bo bo - - bo bo - - bo bo"], bassScale: [1, 3, 5, 8] },
  { name: "Rock_Progressivo6", meter: "3/4", drumPattern: ["bch - - - ch - - bu cch - - -"], bassRhythm: ["bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8, 8, 8]},
  { name: "Rock_Progressivo7", meter: "4/4", drumPattern: ["bco co cch to1 cch - ch - bch - ch cch bu bu ch bu"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 1, 1, 1] },
  { name: "Blues", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 7, 8, 7, 5, 3] },
  { name: "Blues2", meter: "4/4", drumPattern: ["bch - - - cch - - - bch - - - cch - - -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8] },
  { name: "Blues3", meter: "4/4", drumPattern: ["bch - - bu cch - ch - ch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 7] },
  { name: "Blues4", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [8, 7, 5, 3, 1, 3, 5, 7] },
  { name: "Blues5", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 7, 1, 1, 1, 1] },
  { name: "Blues6", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8, 8, 8, 8, 8] },
  { name: "Blues7", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8, 7, 5, 3, 5] },
  { name: "Forr√≥", meter: "2/4", drumPattern: ["bch co ch bu bco ch cch"], bassRhythm: ["bo - - - bo - - x"], bassScale: [8, 1] },
  { name: "Forr√≥2", meter: "2/4", drumPattern: ["su co ch bu bco ch co"], bassRhythm: ["bo - - - bo - - x"], bassScale: [8,1] },
  { name: "Forr√≥3", meter: "2/4", drumPattern: ["bch co ch su bco ch su"], bassRhythm: ["bo - - - bo - - x"], bassScale: [8, 1] },
  { name: "Forr√≥4", meter: "2/4", drumPattern: ["bch co ch bu bco su cch"], bassRhythm: ["bo - - - bo - - x"], bassScale: [8, 1] },
  { name: "Metal", meter: "4/4", drumPattern: ["bch bu bch bu cch bu bch bu bch bu bch bu cch bu bch bu"], bassRhythm: ["bo bo bo bo bo bo bo bo bo bo bo bo bo bo bo bo"], guitarRhythm: ["ab ab ab ab so - - - ab - ab - so - - -"] },
  { name: "Metal2", meter: "4/4", drumPattern: ["bch bu bch bu cch bu bch bu cch - ch bu cch bu bch bu"], bassRhythm: ["bo bo bo bo bo bo bo bo bo bo bo bo bo bo bo bo"], guitarRhythm: ["ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab"] },
  { name: "Metal3", meter: "4/4", drumPattern: ["bch bu bch - cch - ch - bch bu ch bu cch - ch -"], bassRhythm: ["bo bo bo - - - - - bo bo - bo - - - -"] },
  // Groove Metal4 ATUALIZADO com guitarRhythm
  { name: "Metal4", meter: "4/4", drumPattern: ["bch bu cch - bu bu cch - bu bu cch - bu bu cch -"], bassRhythm: ["bo bo bo - bo bo bo - bo bo bo - bo bo bo -"], guitarRhythm: ["ab - ab - so - - - ab - ab - so - - -"] },
  { name: "Samba", meter: "2/4", drumPattern: ["bch - ch bu bch - ch bu"], bassRhythm: ["bo - - x bo - - x"], bassScale: [8, 5] },
  { name: "Jazz", meter: "4/4", drumPattern: ["bch co co - co co co ca bch co co - bch co co cch"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: "chromatic" },
];
const state = {
  running: false,
  paused: false,
  nextNoteTime: 0,
  meter: '4/4',
  bpm: 100,
  sixteenthDur: 0.15,
  stepIndex: 0,
  buffers: { drums: {}, bass: {}, guitar: {}, melody: {} },
  bassPlan: [],
  chordPlan: [],
  signatureTag: '',
  key: null,
  keyIdx: 0,
  quality: 'maj', // Sempre maior, como solicitado
  chordProgression: [],
  chordDurations: [],
  currentGroove: null,
  currentChordIndex: 0,
  barsInChord: 0,
  clickCount: 0,
  totalClicks: 0,
  drumSeq: [],
  lastBassSource: null,
  lastBassGainNode: null,
  lastCleanSource: null,
  lastDistSource: null,
  lastMelodySource: null,
  lastMelodyGain: null,
  melodyBlocks: [],
  melodyPlan: [],
  lastMelodyNote: null,
  guitarPlan: null, // Novo campo para armazenar o plano expandido da guitarra
  activeInput: null // Armazena o input ativo no mobile
};
const mute = { bass: false, drums: false, clean: false, dist: false };
function log(msg) {
  console.log(`[LOG] ${msg}`);
}
function meterToBeats(meter) {
  return Number(meter.split('/')[0]) || 4;
}
function setStatePanel() {
  ui.state.innerHTML = `<div>Levada: ${state.signatureTag || '‚Äî'}</div><div>Key: ${state.key || '‚Äî'} ${state.quality}</div>`;
}
let initPromise = null;
async function initAudio() {
  if (audio.ctx) return;
  if (initPromise) return initPromise;
  initPromise = (async () => {
    audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
    audio.master = audio.ctx.createGain();
    audio.mix = audio.ctx.createGain();
    audio.drumGain = audio.ctx.createGain();
    audio.bassGain = audio.ctx.createGain();
    audio.cleanGain = audio.ctx.createGain();
    audio.distGain = audio.ctx.createGain();
    audio.master.gain.value = 0.9;
    audio.drumGain.gain.value = 0.6;
    audio.bassGain.gain.value = 0.45;
    audio.cleanGain.gain.value = 0.45;
    audio.distGain.gain.value = 0.35;
    audio.master.connect(audio.mix);
    audio.mix.connect(audio.ctx.destination);
    audio.drumGain.connect(audio.master);
    audio.bassGain.connect(audio.master);
    audio.cleanGain.connect(audio.master);
    audio.distGain.connect(audio.master);
    if (!state.buffers.melody) state.buffers.melody = {};
    await ensureBasicSamples();
    function updateVolume() {
      audio.bassGain.gain.value = parseFloat(ui.volBass.value);
      audio.drumGain.gain.value = parseFloat(ui.volDrums.value);
      audio.cleanGain.gain.value = parseFloat(ui.volClean.value);
      audio.distGain.gain.value = parseFloat(ui.volDist.value);
      ui.volBassLabel.textContent = Math.round(ui.volBass.value * 100) + '%';
      ui.volDrumsLabel.textContent = Math.round(ui.volDrums.value * 100) + '%';
      ui.volCleanLabel.textContent = Math.round(ui.volClean.value * 100) + '%';
      ui.volDistLabel.textContent = Math.round(ui.volDist.value * 100) + '%';
    }
    updateVolume();
    ui.volBass.addEventListener('input', updateVolume);
    ui.volDrums.addEventListener('input', updateVolume);
    ui.volClean.addEventListener('input', updateVolume);
    ui.volDist.addEventListener('input', updateVolume);
  })();
  return initPromise;
}
async function loadBuffer(url) {
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const arrayBuffer = await res.arrayBuffer();
    return await audio.ctx.decodeAudioData(arrayBuffer);
  } catch (e) {
    console.warn(`Erro ao carregar: ${url}`);
    return null;
  }
}
async function ensureBasicSamples() {
  const promises = [];
  for (const [key, name] of Object.entries(DRUMS)) {
    const url = `assets/${name}.mp3`;
    if (!state.buffers.drums[key]) {
      promises.push(loadBuffer(url).then(buf => { if (buf) state.buffers.drums[key] = buf; }));
    }
  }
  for (const [key, url] of Object.entries(BASS_SAMPLES)) {
    if (!state.buffers.bass[key]) {
      promises.push(loadBuffer(url).then(buf => { if (buf) state.buffers.bass[key] = buf; }));
    }
  }
  await Promise.all(promises);
}
function expandRhythm(patternArray, totalSteps) {
  const joined = patternArray.join(' ').replace(/\s+/g, ' ').trim();
  const tokens = joined.split(/\s+/).filter(t => t);
  const out = [];
  let i = 0;
  while (out.length < totalSteps) {
    for (const token of tokens) {
      if (out.length >= totalSteps) break;
      out.push(token);
    }
    if (i++ > 1000) break;
  }
  return out.slice(0, totalSteps);
}
async function buildBassAndChordPlan() {
  state.currentGroove = ALL_GROOVES[Math.floor(Math.random() * ALL_GROOVES.length)];
  state.signatureTag = state.currentGroove.name;
  state.meter = ui.meter.value === 'auto' ? state.currentGroove.meter : ui.meter.value;
  if (state.currentGroove.name === "Samba") {
    ui.bpm.value = 70;
    state.bpm = 70;
  } else {
    state.bpm = Number(ui.bpm.value) || 100;
  }
  const beats = meterToBeats(state.meter);
  const sixteenthsPerBar = beats * 4;
  state.keyIdx = Math.floor(Math.random() * PITCHES.length);
  state.key = PITCHES[state.keyIdx];
  // Campo harm√¥nico √© sempre maior, como solicitado
  state.quality = 'maj';
  const grooveName = state.currentGroove.name;
  let styleKey = "Rock";
  if (grooveName.includes("Samba")) styleKey = "Samba";
  else if (grooveName.includes("Jazz")) styleKey = "Jazz";
  else if (grooveName.includes("Forr√≥")) styleKey = "Forr√≥";
  else if (grooveName.includes("Metal")) styleKey = "Metal";
  else if (grooveName.includes("Blues")) styleKey = "Blues";
  const progressions = STYLE_PROGRESSIONS[styleKey] || STYLE_PROGRESSIONS.Rock;
  // --- NOVA L√ìGICA AQUI ---
  // Seleciona uma progress√£o que N√ÉO comece com o grau 7 (diminuto)
  let availableProgressions = progressions.filter(prog => prog[0] !== 7);
  // Se todas as progress√µes come√ßarem com 7 (improv√°vel), usa a lista original como fallback
  if (availableProgressions.length === 0) {
    availableProgressions = progressions;
  }
  state.chordProgression = availableProgressions[Math.floor(Math.random() * availableProgressions.length)];
  const totalBars = Math.min(state.chordProgression.length, 64);
  const totalSteps = sixteenthsPerBar * totalBars;
  const rhythm = expandRhythm(state.currentGroove.bassRhythm, totalSteps);
  const bassPlan = [];
  const chordPlan = [];
  function getBassNotesFromScale(degree, scale, quality) {
    if (scale === "chromatic") {
      const rootIdx = (state.keyIdx + DEGREE_TO_ROOT[degree]) % 12;
      const rootNote = PITCHES[rootIdx];
      const octave = 8;
      return Array(8).fill().map((_, i) => {
        const noteIdx = (rootIdx - i + 12) % 12;
        const p = PITCHES[noteIdx];
        return p.endsWith('S') ? `${p.replace('S', '')}${octave}S` : `${p}${octave}`;
      });
    }
    if (Array.isArray(scale)) {
      const rootIdx = (state.keyIdx + DEGREE_TO_ROOT[degree]) % 12;
      return scale.map(interval => {
        const intervalOffset = DEGREE_TO_ROOT[interval] || 0;
        const noteIdx = (rootIdx + intervalOffset) % 12;
        const noteName = PITCHES[noteIdx];
        if (interval === 1) return noteName;
        return noteName.endsWith('S') ? `${noteName.replace('S', '')}8S` : `${noteName}8`;
      });
    }
    return [PITCHES[(state.keyIdx + DEGREE_TO_ROOT[degree]) % 12]];
  }
  // --- NOVA L√ìGICA AQUI ---
  // Determina a varia√ß√£o √∫nica para toda a progress√£o
  let globalChordVariation = '';
  if (styleKey === "Blues") {
    // Para Blues, for√ßa todos os acordes a serem s√©tima
    globalChordVariation = '7';
  } else {
    // Para outros estilos, sorteia UMA varia√ß√£o para toda a progress√£o
    const allVariations = ['', '11', '13', '4', '45+', '5', '5+', '6', '7', '75+', '9', '95+', 'm', 'm4', 'm5', 'm5+', 'm6', 'm7', 'm75+', 'm79', 'm9', 'dim'];
    globalChordVariation = allVariations[Math.floor(Math.random() * allVariations.length)];
  }
  for (let bar = 0; bar < totalBars; bar++) {
    const degree = state.chordProgression[bar];
    const rootOffset = DEGREE_TO_ROOT[degree] || 0;
    const rootIdx = (state.keyIdx + rootOffset) % 12;
    const rootNote = PITCHES[rootIdx];
    // Define o tipo de acorde baseado na l√≥gica do campo harm√¥nico maior: I-maj, II-min, III-min, IV-maj, V-maj, VI-min, VII-dim
    let chordType = '';
    // --- APLICA A VARIA√á√ÉO GLOBAL ---
    if (styleKey === "Blues") {
      // No Blues, todos s√£o 7, independente do grau
      chordType = globalChordVariation;
    } else {
      // Em outros estilos, aplica a varia√ß√£o global, mas respeita a natureza do grau
      switch(degree) {
        case 1:
        case 4:
        case 5:
          // Acordes maiores
          // Usa a varia√ß√£o global apenas se for compat√≠vel com acorde maior
          if (globalChordVariation === '' || globalChordVariation.startsWith('m') === false) {
            chordType = globalChordVariation;
          } else {
            // Se a varia√ß√£o global √© menor, for√ßa a ser maior (vazio ou 7, por exemplo)
            chordType = '';
          }
          break;
        case 2:
        case 3:
        case 6:
          // Acordes menores
          // Usa a varia√ß√£o global apenas se for compat√≠vel com acorde menor
          if (globalChordVariation.startsWith('m') || globalChordVariation === 'dim') {
            chordType = globalChordVariation;
          } else {
            // Se a varia√ß√£o global √© maior, for√ßa a ser menor (m ou m7, por exemplo)
            chordType = 'm';
          }
          break;
        case 7:
          // Acorde diminuto
          chordType = 'dim';
          break;
        default:
          chordType = '';
      }
    }
    const chordDisplay = CHORD_NAMES[rootIdx] + chordType;
    const displayedNote = transposeDown3Semitones(CHORD_NAMES[rootIdx]);
    const displayedChord = displayedNote + chordType;
    chordPlan.push({ note: rootNote, type: chordType, display: chordDisplay, displayed: displayedChord });
    const bassNotes = getBassNotesFromScale(degree, state.currentGroove.bassScale, state.quality);
    const stepsInBar = sixteenthsPerBar;
    const notesPerBar = Math.ceil(stepsInBar / bassNotes.length);
    const fullBassNotes = Array(stepsInBar).fill().map((_, i) => bassNotes[Math.floor(i / notesPerBar)] || bassNotes[0]);
    for (let stepInBar = 0; stepInBar < stepsInBar; stepInBar++) {
      const step = bar * stepsInBar + stepInBar;
      const sym = rhythm[step] || '-';
      let bassNote = null;
      if (sym === 'x') bassNote = 'x';
      else if (sym === '-' || sym === 'sm') bassNote = '-';
      else bassNote = fullBassNotes[stepInBar];
      bassPlan.push(bassNote);
    }
  }
  state.bassPlan = bassPlan;
  state.chordPlan = chordPlan;
  state.currentChordIndex = 0;
  state.barsInChord = 0;
  state.chordDurations = Array(state.chordPlan.length).fill(1);
  const progEl = document.getElementById('chordProgression');
  if (progEl && state.chordPlan.length > 0) {
    const chordLabels = state.chordPlan.map(ch => ch.displayed);
    progEl.innerHTML = chordLabels.map((label, i) => `<span class="chord-item" data-index="${i}">${label}</span>`).join(' ');
  }
  const drumParsed = parsePattern(state.currentGroove.drumPattern.join(' '));
  const drumSeq = [...drumParsed.intro, ...drumParsed.loop];
  const drumExpanded = [];
  while (drumExpanded.length < state.bassPlan.length) {
    for (const t of drumSeq) {
      if (drumExpanded.length >= state.bassPlan.length) break;
      drumExpanded.push(t);
    }
  }
  state.drumSeq = drumExpanded.slice(0, state.bassPlan.length);
  setStatePanel();
  // --- CORRE√á√ÉO PARA CARREGAR TODOS OS TIPOS DE SAMPLES (ab, de, so) ---
  const guitarUrls = new Set();
  for (const ch of state.chordPlan) {
    const fullChordName = ch.note + ch.type;
    // CORRE√á√ÉO AQUI: Gera as URLs usando a nota raiz (ch.note) como pasta, e o nome completo (fullChordName) como arquivo
    guitarUrls.add(`guitarraDistorcao/${ch.note}/${fullChordName}.mp3`); // "so" - solto (padr√£o)
    guitarUrls.add(`guitarraDistorcao/abafadas/${ch.note}/${fullChordName}.mp3`); // "ab" - abafado
    guitarUrls.add(`guitarraDistorcao/dedilhada/${ch.note}/${fullChordName}.mp3`); // "de" - dedilhado
  }
  const preloadPromises = [];
  guitarUrls.forEach(url => {
    if (!state.buffers.guitar) state.buffers.guitar = {};
    if (!state.buffers.guitar[url]) {
      const p = loadBuffer(url).then(buf => { if (buf) state.buffers.guitar[url] = buf; });
      preloadPromises.push(p);
    }
  });
  await Promise.all(preloadPromises);
}
function parsePattern(patternText) {
  const result = { intro: [], loop: [] };
  const introMatch = patternText.match(/\[(.*?)\]/);
  const loopMatch = patternText.match(/\((.*?)\)/);
  if (introMatch) result.intro = introMatch[1].trim().split(/\s+/).filter(s => s);
  if (loopMatch) result.loop = loopMatch[1].trim().split(/\s+/).filter(s => s);
  if (!introMatch && !loopMatch) result.loop = patternText.trim().split(/\s+/).filter(s => s);
  if (!result.loop.length) result.loop = result.intro.slice();
  return result;
}
function playClickAtTime(time, isStrong) {
  const ctx = audio.ctx;
  const osc = ctx.createOscillator();
  const g = ctx.createGain();
  osc.connect(g);
  g.connect(audio.drumGain);
  osc.frequency.value = isStrong ? 880 : 440;
  g.gain.setValueAtTime(0.0, time);
  g.gain.linearRampToValueAtTime(isStrong ? 0.18 : 0.09, time + 0.002);
  g.gain.linearRampToValueAtTime(0.0, time + 0.06);
  osc.start(time);
  osc.stop(time + 0.07);
}
async function onPlay() {
  if (!audio.ctx) await initAudio();
  if (state.running && !state.paused) return;
  state.bpm = Number(ui.bpm.value) || 100;
  state.sixteenthDur = 60 / state.bpm / 4;
  try {
    await buildBassAndChordPlan();
  } catch (e) {
    console.error('Erro ao gerar plano:', e);
  }
  try {
    buildMelodyPlanFromBlocks();
    await ensureMelodySamplesNeeded();
  } catch (e) {
    console.error('Erro na melodia:', e);
  }
  if (state.paused) {
    state.paused = false;
    return;
  }
  state.running = false;
  state.stepIndex = 0;
  state.nextNoteTime = audio.ctx.currentTime + 0.05;
  const beats = meterToBeats(state.meter);
  const quarterDur = 60 / state.bpm;
  const startTime = audio.ctx.currentTime + 0.05;
  for (let i = 0; i < beats; i++) {
    const t = startTime + i * quarterDur;
    const isStrong = (i % beats) === 0;
    playClickAtTime(t, isStrong);
  }
  const schedulerStartTime = startTime + beats * quarterDur;
  setTimeout(() => {
    state.running = true;
    state.nextNoteTime = schedulerStartTime;
    startScheduler();
  }, Math.max(0, (schedulerStartTime - audio.ctx.currentTime) * 1000 + 10));
}
function scheduler() {
  if (!state.running || state.paused) return;
  const lookahead = 0.20;
  const currentTime = audio.ctx.currentTime;
  while (state.nextNoteTime < currentTime + lookahead) {
    scheduleStep();
  }
}
function scheduleStep() {
  const time = state.nextNoteTime;
  const stepIdx = state.stepIndex;
  const beats = meterToBeats(state.meter);
  const sixteenthsPerBar = beats * 4;
  const isNewBar = (stepIdx % sixteenthsPerBar) === 0;
  // üéµ DRUMS
  const drumToken = state.drumSeq[stepIdx % state.drumSeq.length];
  if (drumToken && !mute.drums) {
    let drumKey = null;
    if (['bu', 'bumbo'].includes(drumToken)) drumKey = 'bu';
    else if (['ca', 'caixa'].includes(drumToken)) drumKey = 'ca';
    else if (['ch', 'chimbal'].includes(drumToken)) drumKey = 'ch';
    else if (['ba', 'bumbo-ataque'].includes(drumToken)) drumKey = 'ba';
    else if (['cch', 'caixa-chimbal'].includes(drumToken)) drumKey = 'cch';
    else if (['bco', 'bumbo-conducao'].includes(drumToken)) drumKey = 'bco';
    else if (['co', 'conducao'].includes(drumToken)) drumKey = 'co';
    else if (['cco', 'caixa-conducao'].includes(drumToken)) drumKey = 'cco';
    else if (['to1', 'tom-1'].includes(drumToken)) drumKey = 'to1';
    else if (['to2', 'tom-2'].includes(drumToken)) drumKey = 'to2';
    else if (['su', 'surdo'].includes(drumToken)) drumKey = 'su';
    else if (['bch', 'bumbo-chimbal'].includes(drumToken)) drumKey = 'bch';
    if (drumKey && state.buffers.drums[drumKey]) {
      const src = audio.ctx.createBufferSource();
      const g = audio.ctx.createGain();
      src.buffer = state.buffers.drums[drumKey];
      src.connect(g);
      g.connect(audio.drumGain);
      g.gain.setValueAtTime(0.0, time);
      g.gain.linearRampToValueAtTime(1.0, time + 0.005);
      src.start(time);
    }
  }
  // üé∏ BASS
  const bassCommand = state.bassPlan[stepIdx % state.bassPlan.length];
  if (!mute.bass && state.lastBassSource) {
    state.lastBassSource.stop(time);
    state.lastBassSource = null;
  }
  if (!mute.bass && bassCommand !== '-' && bassCommand !== 'x') {
    const buf = state.buffers.bass[bassCommand];
    if (buf) {
      const src = audio.ctx.createBufferSource();
      const g = audio.ctx.createGain();
      src.buffer = buf;
      src.connect(g);
      g.connect(audio.bassGain);
      g.gain.setValueAtTime(0.0, time);
      g.gain.linearRampToValueAtTime(1.0, time + 0.01);
      src.start(time);
      state.lastBassSource = src;
    }
  }
  // üé∏ GUITAR
  if (state.currentGroove && state.currentGroove.guitarRhythm) {
    if (!state.guitarPlan) {
      state.guitarPlan = expandRhythm(state.currentGroove.guitarRhythm, state.bassPlan.length);
    }
    const guitarCommand = state.guitarPlan[state.stepIndex % state.guitarPlan.length];
    if (guitarCommand && guitarCommand !== '-' && !mute.dist) {
      const chord = state.chordPlan[state.currentChordIndex];
      if (chord) {
        let baseFolder = 'guitarraDistorcao';
        if (guitarCommand === 'ab') baseFolder = 'guitarraDistorcao/abafadas';
        else if (guitarCommand === 'de') baseFolder = 'guitarraDistorcao/dedilhada';
        else if (guitarCommand === 'so') baseFolder = 'guitarraDistorcao';
        const fullChordName = chord.note + chord.type;
        const url = `${baseFolder}/${chord.note}/${fullChordName}.mp3`;
        const buf = state.buffers.guitar?.[url] || null;
        if (buf && time >= audio.ctx.currentTime - 0.02) {
          if (state.lastDistSource) state.lastDistSource.stop(time);
          const src = audio.ctx.createBufferSource();
          const g = audio.ctx.createGain();
          src.buffer = buf;
          src.connect(g);
          g.connect(audio.distGain);
          g.gain.setValueAtTime(0.0, time);
          g.gain.linearRampToValueAtTime(1.0, time + 0.01);
          src.start(time);
          state.lastDistSource = src;
        }
      }
    }
  } else {
    if (isNewBar) {
      if (state.lastCleanSource) state.lastCleanSource.stop(time);
      if (state.lastDistSource) state.lastDistSource.stop(time);
      const chord = state.chordPlan[state.currentChordIndex];
      if (chord && !mute.dist) {
        playChord(time, chord.note, chord.type, true);
      }
    }
  }
  // üéº MELODY
  const melodyEvent = state.melodyPlan[stepIdx % state.melodyPlan.length];
  if (melodyEvent && melodyEvent.type === 'start') {
    if (melodyEvent.adaptedNumber === null) {
      const chord = state.chordPlan[state.currentChordIndex];
      const adaptedNumber = adaptNumberToChord(
        melodyEvent.originalNumber,
        chord.note,
        chord.type,
        state.lastMelodyNote
      );
      melodyEvent.adaptedNumber = adaptedNumber;
      state.lastMelodyNote = adaptedNumber;
    }
    playMelodyNumber(time, melodyEvent.adaptedNumber, melodyEvent.instrument);
  } else if (melodyEvent && melodyEvent.type === 'mute') {
    stopMelodyAt(time);
    state.lastMelodyNote = null;
  }
  state.stepIndex++;
  // ‚è© Troca de compasso
  if (isNewBar) {
    state.currentChordIndex = (state.currentChordIndex + 1) % state.chordPlan.length;
    state.barsInChord = 0;
    // üëâ readapta nota sustentada
    if (state.lastMelodyNote !== null) {
      const chordNow = state.chordPlan[state.currentChordIndex];
      if (chordNow) {
        state.lastMelodyNote = adaptNumberToChord(
          state.lastMelodyNote,
          chordNow.note,
          chordNow.type
        );
      }
    }
    state.guitarPlan = null;
  }
  state.nextNoteTime += state.sixteenthDur;
}
// --- CORRE√á√ÉO DA FUN√á√ÉO playChord PARA O COMPORTAMENTO ANTIGO ---
// Esta fun√ß√£o √© usada apenas quando o groove N√ÉO tem `guitarRhythm` definido.
function playChord(time, note, type, isDistorted) {
  // Constr√≥i o nome completo do acorde
  const fullChordName = note + type;
  // Monta a URL: pasta da nota raiz, nome do arquivo completo
  const folder = 'guitarraDistorcao';
  const url = `${folder}/${note}/${fullChordName}.mp3`;
  const buf = state.buffers.guitar?.[url] || null;
  if (buf && time >= audio.ctx.currentTime - 0.02) {
    const src = audio.ctx.createBufferSource();
    const g = audio.ctx.createGain();
    src.buffer = buf;
    src.connect(g);
    g.connect(audio.distGain);
    g.gain.setValueAtTime(0.0, time);
    g.gain.linearRampToValueAtTime(1.0, time + 0.01);
    src.start(time);
    state.lastDistSource = src;
  } else {
    console.warn(`Buffer n√£o carregado para o acorde: ${fullChordName} | URL: ${url}`);
  }
}
function onPause() {
  if (state.running && !state.paused) state.paused = true;
}
function onStop() {
  state.running = false;
  state.paused = false;
  ui.currentChord.textContent = '‚Äî';
  ui.chordTimer.textContent = '‚Äî';
  if (state.lastBassSource) state.lastBassSource.stop(0);
  if (state.lastDistSource) state.lastDistSource.stop(0);
  if (state.lastMelodySource) state.lastMelodySource.stop(0);
  state.lastBassSource = null;
  state.lastDistSource = null;
  state.lastMelodySource = null;
  state.lastMelodyGain = null;
  state.lastMelodyNote = null;
  state.guitarPlan = null; // Reseta ao parar
  document.querySelectorAll('.chord-item.current').forEach(el => el.classList.remove('current'));
}
function startScheduler() {
  function tick() {
    if (state.running && !state.paused) scheduler();
    requestAnimationFrame(tick);
  }
  tick();
}
function toggleMute(type, button) {
  mute[type] = !mute[type];
  const icon = mute[type] ? 'üîá' : (type === 'bass' ? 'üé∏' : (type === 'drums' ? 'ü•Å' : (type === 'clean' ? 'üé∏' : 'üî•')));
  const labelMap = { bass: 'Baixo', drums: 'Bateria', clean: 'Limpa', dist: 'Distor√ß√£o' };
  button.textContent = `${icon} ${labelMap[type]}`;
  button.classList.toggle('muted', mute[type]);
}
ui.play.addEventListener('click', onPlay);
ui.pause.addEventListener('click', onPause);
ui.stop.addEventListener('click', onStop);
ui.muteBass.addEventListener('click', () => toggleMute('bass', ui.muteBass));
ui.muteDrums.addEventListener('click', () => toggleMute('drums', ui.muteDrums));
ui.muteClean.addEventListener('click', () => toggleMute('clean', ui.muteClean));
ui.muteDist.addEventListener('click', () => toggleMute('dist', ui.muteDist));
// --- MELODY SYSTEM ---
const ORDER_E_UP = ['E','F','FS','G','GS','A','AS','B','C','CS','D','DS'];
const NUM_TO_NAME = (() => {
  const map = {};
  let n = 1, i = 0;
  while (n <= 49) {
    map[n] = ORDER_E_UP[i % ORDER_E_UP.length];
    n++; i++;
  }
  return map;
})();
function chordTriad(rootPitchName, quality) {
  const rootIdx = PITCHES.indexOf(rootPitchName);
  if (rootIdx === -1) return [rootPitchName]; // fallback
  // Extrai a qualidade b√°sica (maj, min, dim) e as extens√µes (7, 9, etc)
  let basicQuality = 'maj';
  let hasSeventh = false;
  let hasNinth = false;
  if (quality.includes('m') && !quality.includes('maj')) {
    basicQuality = 'min';
  } else if (quality.includes('dim')) {
    basicQuality = 'dim';
  }
  // Verifica se o acorde tem s√©tima (7, m7, dim7, etc.)
  if (quality.includes('7')) {
    hasSeventh = true;
  }
  // Verifica se o acorde tem nona (9, m9, 79, m79, etc.)
  // Procura por '9' que n√£o seja precedido por '1' (para evitar confundir com '19')
  if (/[^1]9/.test(quality) || quality.endsWith('9')) {
    hasNinth = true;
  }
  let chordNotes = [];
  // Constr√≥i a tr√≠ade b√°sica
  if (basicQuality === 'min') {
    chordNotes = [
      PITCHES[rootIdx], // 1¬™
      PITCHES[(rootIdx + 3) % 12], // 3¬™ menor
      PITCHES[(rootIdx + 7) % 12] // 5¬™ justa
    ];
  } else if (basicQuality === 'dim') {
    chordNotes = [
      PITCHES[rootIdx], // 1¬™
      PITCHES[(rootIdx + 3) % 12], // 3¬™ menor
      PITCHES[(rootIdx + 6) % 12] // 5¬™ diminuta
    ];
  } else {
    chordNotes = [
      PITCHES[rootIdx], // 1¬™
      PITCHES[(rootIdx + 4) % 12], // 3¬™ maior
      PITCHES[(rootIdx + 7) % 12] // 5¬™ justa
    ];
  }
  // Adiciona a 7¬™, se presente
  if (hasSeventh) {
    if (basicQuality === 'min' || basicQuality === 'dim') {
      // Para acordes menores e diminutos, a 7¬™ √© menor (10 semitons da t√¥nica)
      chordNotes.push(PITCHES[(rootIdx + 10) % 12]);
    } else {
      // Para acordes maiores, a 7¬™ √© maior (11 semitons da t√¥nica)
      chordNotes.push(PITCHES[(rootIdx + 11) % 12]);
    }
  }
  // Adiciona a 9¬™, se presente
  if (hasNinth) {
    // A 9¬™ √© a mesma nota da 2¬™, uma oitava acima (2 semitons da t√¥nica)
    chordNotes.push(PITCHES[(rootIdx + 2) % 12]);
  }
  return chordNotes;
}
function distanceBetweenNotes(n1, n2) {
  const i1 = ORDER_E_UP.indexOf(n1);
  const i2 = ORDER_E_UP.indexOf(n2);
  return i1 === -1 || i2 === -1 ? 100 : Math.abs(i1 - i2);
}
function adaptNumberToChord(number, root, type, lastPlayedNote = null) {
  const baseName = NUM_TO_NAME[number]; // nota que o usu√°rio "quer"
  const chordNotes = chordTriad(root, type); // notas do acorde em vigor
  // 1. Se a nota j√° est√° no acorde, mant√©m
  if (chordNotes.includes(baseName)) {
    return findClosestNumber(number, baseName);
  }
  // 2. Se n√£o est√°, pega a nota do acorde mais pr√≥xima
  const noteDistances = chordNotes.map(note => ({
    note,
    distance: distanceBetweenNotes(baseName, note)
  }));
  noteDistances.sort((a, b) => a.distance - b.distance);
  // 3. Se houver √∫ltima nota tocada e a mais pr√≥xima for igual, pega a segunda
  if (lastPlayedNote && noteDistances.length > 1) {
    const lastNoteName = NUM_TO_NAME[lastPlayedNote];
    if (noteDistances[0].note === lastNoteName) {
      return findClosestNumber(number, noteDistances[1].note);
    }
  }
  // 4. Retorna a mais pr√≥xima
  return findClosestNumber(number, noteDistances[0].note);
}
function findClosestNumber(targetNumber, targetNote) {
  let bestNum = targetNumber;
  let bestDist = 100;
  for (let n = 1; n <= 49; n++) {
    const name = NUM_TO_NAME[n];
    if (name === targetNote) {
      const dist = Math.abs(n - targetNumber);
      if (dist < bestDist) {
        bestDist = dist;
        bestNum = n;
      }
    }
  }
  return bestNum;
}
function addMelodyBlock() {
  const beats = meterToBeats(state.meter || '4/4');
  const cols = beats * 4;
  const blockIdx = state.melodyBlocks.length;
  const div = document.createElement('div');
  div.className = 'melody-block';
  const caption = document.createElement('div');
  caption.className = 'melody-caption';
  caption.textContent = `Bloco #${blockIdx + 1} ‚Äî ${beats}/4 (${cols} colunas)`;
  div.appendChild(caption);
  const table = document.createElement('table');
  table.className = 'melody-table';
  const tr = document.createElement('tr');
  tr.innerHTML = '<th>Notas</th>' + Array(cols).fill().map((_, i) => `<th>${i+1}</th>`).join('');
  table.appendChild(tr);
  const inputRow = document.createElement('tr');
  const tdLabel = document.createElement('td');
  tdLabel.innerHTML = `<span class="line-label">Notas (1-49) ou "x"</span>`;
  inputRow.appendChild(tdLabel);
  for (let c = 0; c < cols; c++) {
    const td = document.createElement('td');
    const input = document.createElement('input');
    input.type = 'text';
    input.placeholder = '1‚Äì49/x';
    input.dataset.block = String(blockIdx);
    input.dataset.col = String(c);
    td.appendChild(input);
    inputRow.appendChild(td);
    // Adiciona o evento de foco apenas se for um dispositivo m√≥vel
    if (isMobileDevice()) {
      input.addEventListener('focus', (e) => {
        state.activeInput = e.target;
        showNumberPicker();
      });
      // Evento de duplo clique para limpar o campo (j√° estava aqui, mantido)
      input.addEventListener('dblclick', (e) => { e.target.value = ''; });
    }
  }
  table.appendChild(inputRow);
  div.appendChild(table);
  ui.melodyBlocks.appendChild(div);
  state.melodyBlocks.push(div);
}
function clearMelodyBlocks() {
  state.melodyBlocks = [];
  ui.melodyBlocks.innerHTML = '';
}
ui.btnMelodyAdd.addEventListener('click', addMelodyBlock);
ui.btnMelodyClear.addEventListener('click', clearMelodyBlocks);
// --- FUN√á√ïES DO PICKER DE N√öMEROS PARA MOBILE ---
function initializeNumberPicker() {
  // Cria os bot√µes de 1 a 49
  for (let i = 1; i <= 49; i++) {
    const btn = document.createElement('button');
    btn.className = 'number-btn';
    btn.textContent = i;
    btn.dataset.number = i;
    btn.addEventListener('click', handleNumberSelection);
    ui.numberGrid.appendChild(btn);
  }
  // Cria o bot√£o de fechar
  const closeBtn = document.createElement('button');
  closeBtn.className = 'number-btn close-btn';
  closeBtn.textContent = 'Fechar';
  closeBtn.addEventListener('click', hideNumberPicker);
  ui.numberGrid.appendChild(closeBtn);
}
function showNumberPicker() {
  if (!isMobileDevice()) return;
  ui.numberPicker.style.display = 'grid'; // Alterado de 'block' para 'grid' para melhor controle do layout
}
function hideNumberPicker() {
  ui.numberPicker.style.display = 'none';
}
function handleNumberSelection(e) {
  const number = e.target.dataset.number;
  if (state.activeInput) {
    state.activeInput.value = number;
    // Dispara o evento 'input' ou 'change' para garantir que o valor seja processado
    state.activeInput.dispatchEvent(new Event('input', { bubbles: true }));
    state.activeInput.dispatchEvent(new Event('change', { bubbles: true }));
    // Remove o foco
    state.activeInput.blur();
    state.activeInput = null;
  }
  hideNumberPicker(); // Fecha o picker automaticamente ap√≥s a sele√ß√£o
}
function buildMelodyPlanFromBlocks() {
  const plan = [];
  let chordIdx = 0; // √≠ndice para sincronizar melodia com acorde
  const stepsPerBar = meterToBeats(state.meter) * 4;
  for (const block of state.melodyBlocks) {
    const inputs = block.querySelectorAll('input');
    inputs.forEach((input, step) => {
      const value = input.value.trim();
      if (value === '') {
        plan.push(null);
      } else if (value.toLowerCase() === 'x') {
        plan.push({ type: 'mute' });
      } else {
        const num = parseInt(value, 10);
        if (!isNaN(num) && num >= 1 && num <= 49) {
          // üîë Pega o acorde correspondente ao passo
          chordIdx = Math.floor(plan.length / stepsPerBar) % state.chordPlan.length;
          const chord = state.chordPlan[chordIdx];
          // üîë J√° adapta o n√∫mero de acordo com o acorde
          const adapted = adaptNumberToChord(num, chord.note, chord.type);
          plan.push({
            type: 'start',
            originalNumber: num,
            adaptedNumber: adapted,
            instrument: ui.melodyInstrument.value
          });
        }
      }
    });
  }
  state.melodyPlan = plan;
}
async function ensureMelodySamplesNeeded() {
  const need = new Set();
  for (let i = 1; i <= 49; i++) {
    const name = NUM_TO_NAME[i];
    const folders = {
      dist: 'guitarraDistorcao/Melodia',
      piano: 'assets/PianoString',
      baixo: 'assets/BaixoMelodia',
      sax: 'assets/SaxMelodia'
    };
    Object.values(folders).forEach(folder => {
      need.add(`${folder}/${i}${name}.mp3`);
    });
  }
  const promises = [];
  for (const url of need) {
    if (!state.buffers.melody[url]) {
      promises.push(loadBuffer(url).then(buf => {
        if (buf) state.buffers.melody[url] = buf;
      }));
    }
  }
  await Promise.all(promises);
}
function stopMelodyAt(time) {
  if (state.lastMelodyGain) {
    state.lastMelodyGain.gain.cancelScheduledValues(time);
    state.lastMelodyGain.gain.setValueAtTime(state.lastMelodyGain.gain.value, time);
    state.lastMelodyGain.gain.linearRampToValueAtTime(0.0, time + 0.02);
  }
  state.lastMelodySource = null;
  state.lastMelodyGain = null;
}
function playMelodyNumber(time, number, instrumentType) {
  const name = NUM_TO_NAME[number];
  let folder, targetGain = audio.distGain;
  if (instrumentType === 'dist') {
    folder = 'guitarraDistorcao/Melodia';
  } else if (instrumentType === 'piano') {
    folder = 'assets/PianoString';
  } else if (instrumentType === 'baixo') {
    folder = 'assets/BaixoMelodia';
  } else if (instrumentType === 'sax') {
    folder = 'assets/SaxMelodia';
  } else {
    folder = 'guitarraDistorcao/Melodia';
  }
  const url = `${folder}/${number}${name}.mp3`;
  const buf = state.buffers.melody[url];
  if (!buf) {
    console.warn(`[Melodia] Arquivo n√£o carregado: ${url}`);
    return;
  }
  if (state.lastMelodySource && !state.lastMelodySource.finished) {
    state.lastMelodySource.stop(time);
  }
  const src = audio.ctx.createBufferSource();
  const g = audio.ctx.createGain();
  src.buffer = buf;
  src.connect(g);
  g.connect(targetGain);
  g.gain.setValueAtTime(0.0, time);
  g.gain.linearRampToValueAtTime(1.0, time + 0.01);
  const maxDur = state.sixteenthDur * 16;
  src.start(time);
  src.stop(time + Math.min(buf.duration, maxDur));
  state.lastMelodySource = src;
  state.lastMelodyGain = g;
  src.finished = false;
  src.onended = () => { src.finished = true; };
}
// ===============================
// FUN√á√ÉO DE EXPORTA√á√ÉO DE PARTITURA
// ===============================
function exportarPartitura() {
  // Coleta todos os inputs de melodia
  const allInputs = Array.from(document.querySelectorAll('#melodyBlocks input'));
  if (allInputs.length === 0) {
    alert('Adicione pelo menos um bloco de melodia primeiro.');
    return;
  }
  // Agrupa os inputs por bloco (linha)
  const blocks = [];
  let currentBlock = [];
  let currentBlockLength = 0;
  for (const input of allInputs) {
    const blockIdx = parseInt(input.dataset.block, 10);
    const colIdx = parseInt(input.dataset.col, 10);
    // Se √© um novo bloco, salva o anterior e come√ßa um novo
    if (blocks.length <= blockIdx) {
      if (currentBlock.length > 0) {
        blocks.push(currentBlock);
        currentBlock = [];
      }
      // Calcula o n√∫mero de colunas deste bloco
      currentBlockLength = document.querySelectorAll(`input[data-block="${blockIdx}"]`).length;
    }
    // Adiciona o valor ao bloco atual
    currentBlock.push(input.value.trim());
  }
  // Adiciona o √∫ltimo bloco
  if (currentBlock.length > 0) {
    blocks.push(currentBlock);
  }
  // Traduz os valores para notas VexFlow
  const vexflowVoices = [];
  for (const block of blocks) {
    const notes = [];
    for (const val of block) {
      if (val === '' || val === null) {
        // Nota de ligadura (continua√ß√£o da anterior)
        notes.push("b/4"); // Placeholder, ser√° tratado depois
      } else if (val.toLowerCase() === 'x') {
        // Pausa
        notes.push("r/4");
      } else {
        const num = parseInt(val, 10);
        if (!isNaN(num) && num >= 1 && num <= 49) {
          const noteName = NUM_TO_NAME[num];
          // Converte para nota√ß√£o VexFlow (ex: C/4, D/4)
          // Assumindo oitava 4 para simplifica√ß√£o
          let vexNote = noteName.replace('S', '#') + "/4";
          notes.push(vexNote);
        } else {
          // Valor inv√°lido, trata como pausa
          notes.push("r/4");
        }
      }
    }
    vexflowVoices.push(notes);
  }
  // Cria o modal e o canvas
  const modal = document.getElementById('sheetModal');
  const canvas = document.getElementById('sheetCanvas');
  const ctx = canvas.getContext('2d');
  const renderer = new Vex.Flow.Renderer(canvas, Vex.Flow.Renderer.Backends.CANVAS);
  // Configura o renderizador
  renderer.resize(750, 300);
  const context = renderer.getContext();
  context.setFont("Arial", 10, "").setBackgroundFillStyle("#ffffff");
  // Cria a partitura
  const staveWidth = 600;
  let yOffset = 20;
  for (let blockIdx = 0; blockIdx < vexflowVoices.length; blockIdx++) {
    const notes = vexflowVoices[blockIdx];
    // Cria o pentagrama
    const stave = new Vex.Flow.Stave(50, yOffset, staveWidth);
    stave.addClef("treble").addTimeSignature("4/4");
    stave.setContext(context).draw();
    // Processa as notas para lidar com ligaduras
    const processedNotes = [];
    let currentNote = null;
    for (let i = 0; i < notes.length; i++) {
      const note = notes[i];
      if (note === "b/4") {
        // √â uma ligadura, aumenta a dura√ß√£o da nota anterior
        if (currentNote) {
          // Aumenta a dura√ß√£o da √∫ltima nota
          const durations = {
            "4": 2, // sem√≠nima vira m√≠nima
            "2": 1, // m√≠nima vira semibreve
            "1": 0.5 // semibreve vira breve (n√£o suportado, mant√©m semibreve)
          };
          const currentDur = currentNote.split("/")[1];
          const newDur = durations[currentDur] || currentDur;
          currentNote = currentNote.split("/")[0] + "/" + newDur;
          // Atualiza a √∫ltima nota no array
          processedNotes[processedNotes.length - 1] = currentNote;
        } else {
          // Se n√£o h√° nota anterior, trata como pausa
          processedNotes.push("r/4");
          currentNote = "r/4";
        }
      } else {
        processedNotes.push(note);
        currentNote = note;
      }
    }
    // Cria as notas do VexFlow
    const vexNotes = processedNotes.map(noteStr => new Vex.Flow.StaveNote({
      clef: "treble",
      keys: [noteStr.split("/")[0]],
      duration: noteStr.split("/")[1]
    }));
    // Cria a voz
    const voice = new Vex.Flow.Voice({
      num_beats: 4,
      beat_value: 4,
      resolution: Vex.Flow.RESOLUTION
    });
    voice.addTickables(vexNotes);
    // Formata e desenha
    const formatter = new Vex.Flow.Formatter().joinVoices([voice]).format([voice], staveWidth - 100);
    voice.draw(context, stave);
    // Atualiza o offset Y para o pr√≥ximo bloco
    yOffset += 120;
  }
  // Mostra o modal
  modal.style.display = "block";
  // Configura os bot√µes do modal
  document.getElementById('closeSheet').onclick = function() {
    modal.style.display = "none";
  };
  document.getElementById('downloadSheet').onclick = function() {
    const link = document.createElement('a');
    link.download = 'partitura-jam-on.png';
    link.href = canvas.toDataURL();
    link.click();
  };
  // Fecha ao clicar fora
  window.onclick = function(event) {
    if (event.target == modal) {
      modal.style.display = "none";
    }
  };
}

// Vincula a fun√ß√£o ao bot√£o SOMENTE quando a biblioteca VexFlow estiver pronta
function waitForVexFlow() {
  if (typeof Vex !== 'undefined' && Vex.Flow) {
    ui.btnExportPartitura.addEventListener('click', exportarPartitura);
    console.log('VexFlow carregado! Bot√£o de exporta√ß√£o ativado.');
  } else {
    console.log('VexFlow ainda n√£o carregou. Tentando novamente em 100ms...');
    setTimeout(waitForVexFlow, 100);
  }
}
waitForVexFlow();

// Inicializa o picker de n√∫meros se for mobile
if (isMobileDevice()) {
  initializeNumberPicker();
}
window.addEventListener('load', function() {
  // C√≥digo de inicializa√ß√£o, se necess√°rio
});
  </script>
  
</body>
</html>

