<!DOCTYPE html>
<html lang="pt-BR">
<head>
  
  <meta charset="UTF-8" />
  <title>Jam On ‚Äì Playback Aleat√≥rio</title>
  <style>
    body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
  background: #121212;
  color: #e0e0e0;
  margin: 0;
  padding: 20px;
}
header {
  text-align: center;
  margin-bottom: 20px;
}
h1 {
  color: #5eead4;
  font-size: 1.8em;
  margin: 0;
}
.pill {
  display: inline-block;
  background: #333;
  color: #aaa;
  font-size: 0.75em;
  padding: 4px 10px;
  border-radius: 12px;
}
.card {
  max-width: 800px;
  margin: 0 auto;
  background: #1e1e1e;
  border-radius: 16px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  overflow: hidden;
  padding: 20px;
  text-align: left;
}
.chord-display {
  text-align: center;
  margin: 20px 0;
}
.chord-name {
  font-size: 3em;
  color: #5eead4;
  margin: 0;
  font-weight: bold;
}
#chordTimer {
  font-size: 1.1em;
  color: #aaa;
}
#chordProgression {
  margin-top: 12px;
  font-family: monospace;
  font-size: 1.1em;
  white-space: nowrap;
  overflow-x: auto;
  padding: 8px 0;
}
.chord-item {
  display: inline-block;
  padding: 6px 10px;
  margin: 0 4px;
  border-radius: 6px;
  background: #333;
  transition: background 0.3s;
}
.chord-item.current {
  background: #5eead4;
  color: #121212;
  font-weight: bold;
}
.controls {
  display: grid;
  gap: 15px;
  margin-bottom: 20px;
}
.btn-row {
  display: flex;
  justify-content: center;
  gap: 12px;
  flex-wrap: wrap;
}
button {
  padding: 12px 20px;
  border: none;
  border-radius: 8px;
  font-weight: bold;
  cursor: pointer;
  font-size: 1em;
}
button.primary {
  background: #5eead4;
  color: #121212;
}
button.danger {
  background: #f44336;
  color: white;
}
button:hover {
  opacity: 0.9;
}
.mute-buttons {
  display: flex;
  justify-content: center;
  gap: 10px;
  flex-wrap: wrap;
  margin: 10px 0;
}
.mute-buttons button {
  padding: 8px 14px;
  font-size: 0.9em;
}
.mute-buttons button.muted {
  opacity: 0.5;
}
.row {
  display: flex;
  align-items: center;
  gap: 10px;
  justify-content: center;
}
.row label {
  width: 100px;
  text-align: right;
  color: #ccc;
}
input[type="number"], select {
  padding: 8px;
  border-radius: 6px;
  border: 1px solid #444;
  background: #2a2a2a;
  color: #fff;
  width: 90px;
}
select {
  width: auto;
  min-width: 120px;
}
.slider-row {
  display: flex;
  align-items: center;
  gap: 10px;
  justify-content: center;
}
.slider-row label {
  width: 80px;
  text-align: right;
  font-size: 0.9em;
}
input[type="range"] {
  width: 180px;
  accent-color: #5eead4;
}
.slider-value {
  width: 40px;
  text-align: left;
  font-size: 0.9em;
  color: #aaa;
}
.panel {
  margin-top: 20px;
}
.panel h3 {
  color: #5eead4;
  margin-top: 0;
}
.melody-panel {
  margin-top: 20px;
}
.melody-toolbar {
  display: flex;
  gap: 10px;
  align-items: center;
  flex-wrap: wrap;
  justify-content: center;
  margin-bottom: 10px;
}
.melody-block {
  border: 1px solid #444;
  border-radius: 8px;
  padding: 10px;
  margin-bottom: 12px;
  background: #222;
}
.melody-caption {
  font-size: 0.9em;
  color: #ccc;
  margin-bottom: 6px;
}
.melody-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85em;
}
.melody-table th, .melody-table td {
  border: 1px solid #555;
  padding: 2px;
}
.melody-table input {
  width: 100%;
  padding: 4px;
  text-align: center;
  background: #333;
  border: 1px solid #555;
  color: white;
  border-radius: 4px;
}
.line-label {
  font-size: 0.8em;
  color: #aaa;
}
.instructions {
  font-size: 0.85em;
  color: #aaa;
  margin-top: 8px;
  text-align: center;
}
/* === ESTILOS PARA MOBILE === */
@media (max-width: 768px) {
  body {
    padding: 10px;
  }
  .card {
    padding: 15px;
    border-radius: 12px;
  }
  h1 {
    font-size: 1.5em;
  }
  .chord-name {
    font-size: 2em;
  }
  button {
    padding: 14px 22px; /* Aumentado para toque */
    font-size: 1em;
  }
  .row label {
    width: 80px;
    font-size: 0.9em;
  }
  input[type="number"], select {
    width: 70px;
    font-size: 0.9em;
    padding: 10px; /* Aumentado para toque */
  }
  .slider-row label {
    width: 60px;
    font-size: 0.8em;
  }
  input[type="range"] {
    width: 140px;
  }
  .slider-value {
    width: 35px;
    font-size: 0.8em;
  }
  .melody-table {
    font-size: 0.9em; /* Aumentado para melhor leitura */
  }
  .melody-table input {
    height: 40px; /* Aumentado para toque */
    font-size: 0.9em;
    padding: 8px; /* Aumentado para toque */
  }
  .melody-caption {
    font-size: 0.85em;
  }
}
/* === ESTILOS DO PICKER DE N√öMEROS === */
#numberPicker {
  display: none;
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background: #1e1e1e;
  border-top: 2px solid #5eead4;
  padding: 15px;
  box-shadow: 0 -4px 10px rgba(0,0,0,0.5);
  z-index: 1000;
  animation: slideUp 0.3s ease-out;
  /* --- NOVO: Usa grid para 4 colunas --- */
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 10px;
}
@keyframes slideUp {
  from {
    transform: translateY(100%);
  }
  to {
    transform: translateY(0);
  }
}
#numberPicker h3 {
  color: #5eead4;
  text-align: center;
  margin-top: 0;
  margin-bottom: 15px;
  /* --- NOVO: Ocupa todas as 4 colunas --- */
  grid-column: span 4;
}
#numberGrid {
  /* --- REMOVIDO: O grid agora est√° no #numberPicker --- */
}
.number-btn {
  background: #333;
  color: #e0e0e0;
  border: 1px solid #444;
  border-radius: 6px;
  padding: 12px 0; /* Aumentado para toque */
  font-size: 1em;
  cursor: pointer;
  transition: all 0.1s ease;
}
.number-btn:hover {
  background: #444;
}
.number-btn:active {
  transform: scale(0.95);
  background: #5eead4;
  color: #121212;
}
.close-btn {
  /* --- NOVO: Ocupa todas as 4 colunas --- */
  grid-column: span 4;
  background: #f44336;
  color: white;
  font-weight: bold;
}
  </style>
</head>
<body>
  <header>
    <h1>Jam On ‚Äì Playback Aleat√≥rio</h1>
    <div class="pill">Cada pulso do BPM = sem√≠nima</div>
  </header>
  <div class="chord-display">
    <h2 class="chord-name" id="currentChord">‚Äî</h2>
    <div id="chordTimer">‚Äî</div>
    <div id="chordProgression"></div>
  </div>
  <div class="card">
    <div class="controls">
      <div class="btn-row">
        <button id="btnPlay" class="primary">‚ñ∂ Play</button>
        <button id="btnPause">‚è∏ Pause</button>
        <button id="btnStop" class="danger">‚èπ Stop</button>
         <button id="btnSaveWAV" class="primary">üíæ Salvar como WAV</button>

      </div>
      <div class="mute-buttons">
        <button id="muteBass" data-mute="off">üé∏ Baixo</button>
        <button id="muteDrums" data-mute="off">ü•Å Bateria</button>
        <button id="muteClean" data-mute="off">üé∏ Limpa</button>
        <button id="muteDist" data-mute="off">üî• Distor√ß√£o</button>
      </div>
      <div class="row">
        <label>BPM</label>
        <input id="bpm" type="number" min="40" max="220" value="100">
      </div>
      <div class="row">
        <label>Assinatura</label>
        <select id="meter">
          <option value="auto" selected>aleat√≥ria</option>
          <option>2/4</option>
          <option>3/4</option>
          <option>4/4</option>
          <option>5/4</option>
          <option>6/4</option>
          <option>7/4</option>
        </select>
      </div>
      <div class="row">
        <label>Melodia</label>
        <select id="melodyInstrument">
  <option value="dist">Guitarra Distorcida</option>
  <option value="piano">Piano/String</option>
  <option value="baixo">Baixo</option>
  <option value="sax">Sax</option>
  <!-- Novos Instrumentos -->
  <option value="acordeon">Acordeon</option>
  <option value="sinos">Sinos</option>
  <option value="violao_aco">Viol√£o A√ßo</option>
  <option value="violao_nylon">Viol√£o Nylon</option>
  <option value="cordas">Cordas</option>
</select>
      </div>
      <h3 style="color: #5eead4; margin: 15px 0 5px;">Controle de Volume</h3>
      <div class="slider-row">
        <label>Baixo</label>
        <input type="range" id="volBass" min="0" max="1" step="0.01" value="0.45">
        <span class="slider-value" id="volBassLabel">45%</span>
      </div>
      <div class="slider-row">
        <label>Bateria</label>
        <input type="range" id="volDrums" min="0" max="1" step="0.01" value="0.6">
        <span class="slider-value" id="volDrumsLabel">60%</span>
      </div>
      <div class="slider-row">
        <label>Limpa</label>
        <input type="range" id="volClean" min="0" max="1" step="0.01" value="0.45">
        <span class="slider-value" id="volCleanLabel">45%</span>
      </div>
            <div class="slider-row">
        <label>Distorcida</label>
        <input type="range" id="volDist" min="0" max="1" step="0.01" value="0.35">
        <span class="slider-value" id="volDistLabel">35%</span>
      </div>
      <!-- NOVO: Controle de Volume para Melodia -->
      <div class="slider-row">
        <label>Melodia</label>
        <input type="range" id="volMelody" min="0" max="1" step="0.01" value="0.50">
        <span class="slider-value" id="volMelodyLabel">50%</span>
      </div>
    </div>
    <div class="panel">
      <h3>Estado Atual</h3>
      <div class="mono" id="state">Parado</div>
    </div>
    <div class="panel melody-panel">
      <h3>üé∏ Melodia Adaptativa</h3>
      <div class="melody-toolbar">
        <!-- Bot√£o de exportar partitura REMOVIDO -->
        <button id="btnMelodyAdd" class="primary">‚ûï Adicionar Bloco</button>
        <button id="btnMelodyClear" class="danger">üßπ Limpar Blocos</button>
        <span style="font-size: 0.9em; color: #aaa;">Notas se estendem at√© pr√≥xima nota ou "x"</span>
      </div>
      <div class="instructions">
        Digite n√∫meros (1-49) para notas, "x" para pausa, ou deixe vazio para continuar nota anterior
      </div>
      <div id="melodyBlocks"></div>
    </div>
  </div>
    <script>
   function transposeDown3Semitones(note) {
  const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const index = notes.indexOf(note);
  if (index === -1) return note;
  return notes[(index - 3 + 12) % 12];
}
// Fun√ß√£o para detectar se √© um dispositivo m√≥vel
function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}
const ui = {
  play: document.getElementById('btnPlay'),
  pause: document.getElementById('btnPause'),
  stop: document.getElementById('btnStop'),
  muteBass: document.getElementById('muteBass'),
  muteDrums: document.getElementById('muteDrums'),
  muteClean: document.getElementById('muteClean'),
  muteDist: document.getElementById('muteDist'),
  bpm: document.getElementById('bpm'),
  meter: document.getElementById('meter'),
  state: document.getElementById('state'),
  currentChord: document.getElementById('currentChord'),
  chordTimer: document.getElementById('chordTimer'),
  volBass: document.getElementById('volBass'),
  volDrums: document.getElementById('volDrums'),
  volClean: document.getElementById('volClean'),
  volDist: document.getElementById('volDist'),
  volBassLabel: document.getElementById('volBassLabel'),
  volDrumsLabel: document.getElementById('volDrumsLabel'),
  volCleanLabel: document.getElementById('volCleanLabel'),
  volDistLabel: document.getElementById('volDistLabel'),
  // --- ADICIONE ESTAS DUAS LINHAS ---
  volMelody: document.getElementById('volMelody'),
  volMelodyLabel: document.getElementById('volMelodyLabel'),
  // --- FIM DA ADI√á√ÉO ---
  melodyBlocks: document.getElementById('melodyBlocks'),
  btnMelodyAdd: document.getElementById('btnMelodyAdd'),
  btnMelodyClear: document.getElementById('btnMelodyClear'),
  melodyInstrument: document.getElementById('melodyInstrument'),
  numberPicker: document.getElementById('numberPicker'),
  numberGrid: document.getElementById('numberGrid')
};
// --- NOVO: REFER√äNCIA AO BOT√ÉO DE SALVAR ---
ui.btnSaveWAV = document.getElementById('btnSaveWAV');
let mediaRecorder;


const audio = {
  ctx: null,
  master: null,
  mix: null,
  drumGain: null,
  bassGain: null,
  cleanGain: null,
  distGain: null,
  schedulerTimer: null
};
const PITCHES = ['A','AS','B','C','CS','D','DS','E','F','FS','G','GS'];
const DEGREE_TO_ROOT = { 1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11 };
const CHORD_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const DRUMS = {
  bu: 'bumbo',
  ca: 'caixa',
  ch: 'chimbal',
  ba: 'bumbo-ataque',
  cch: 'caixa-chimbal',
  co: 'conducao',
  bco: 'bumbo-conducao',
  cco: 'caixa-conducao',
  to1: 'tom-1',
  to2: 'tom-2',
  su: 'surdo',
  bch: 'bumbo-chimbal'
};
// === CRIA√á√ÉO DOS SAMPLES COM SUSTENIDOS NO FINAL (C8S) ===
const BASS_SAMPLES = {};
for (const p of PITCHES) {
  BASS_SAMPLES[p] = `assets/bass-${p}.mp3`;
  if (p.endsWith('S')) {
    const base = p.replace('S', '');
    BASS_SAMPLES[base + '8S'] = `assets/bass-${base}8S.mp3`;
  } else {
    BASS_SAMPLES[p + '8'] = `assets/bass-${p}8.mp3`;
  }
}
BASS_SAMPLES['x'] = 'assets/bass-muted.mp3';
// === PROGRESS√ïES POR ESTILO ===
const STYLE_PROGRESSIONS = {
  Rock: [[1,4,5,1], [1,5,6,4], [6,4,1,5]],
  Rock2: [[4,5,1,5], [5,4,1,4], [7,4,1,1]],
  Rock3: [[1,4,5,1], [1,3,4,5]],
  Rock4: [[6,4,1,5], [1,4,5,1,4,5,4,5], [1,5,6,4,1,5,6,7]],
  Rock5: [[1,5,7,4], [1,4,5,6], [1,5,6,4]],
  Rock6: [[1,5,6,4], [1,4,5,1], [1,5,6,7]],
  Rock7: [[2,3,5,1], [1,4,7,1], [1,5,3,4]],
  Rock_Progressivo: [[4,5,1,1,4,5,7], [1,4,1,4,5,6,5], [1,4,5,6,3,5,4]],
  Rock_Progressivo2: [[1,4,5,1,5], [4,5,3,1,3,1,4,5,7,5], [1,4,1,4,5]],
  Rock_Progressivo3: [[1,4,5,1,5,7], [1,3,4,5,2,5]],
  Rock_Progressivo4: [[4,5,1,1,4,5,7,5], [1,4,1,4,5,6,5,7], [1,4,5,6,3,5,4,5]],
  Rock_Progressivo5: [[4,5,1,1,4,5,7], [1,4,1,4,5,6,5], [1,4,5,6,3,5,4]], 
  Rock_Progressivo6: [[1,4,5,6,3,5], [1,4,1,4,5,6,5]],
  Rock_Progressivo7: [[4,5,1,1], [1,4,5,1]],      
  Blues: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]],
  Blues2: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]],
  Blues3: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,7]],
  Blues4: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]],
  Blues5: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,7]],
  Blues6: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]],
  Blues7: [[1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]],
  Forr√≥: [[1,5,1,5,4,5,4,5]],
  Samba: [[2,5,1,1], [1,4,5,1]],
  Metal: [[1, 3, 5, 6, 1, 2, 3, 4], [1, 3, 4, 5], [2, 5, 1, 5]],
  Metal2: [[1, 3, 5, 4, 1, 2, 3, 4], [1, 3, 4, 5], [2, 5, 1, 5]],
  Metal3: [[1, 3, 5, 3, 1, 2, 4, 5], [1, 3, 4, 5], [2, 5, 1, 5]],
  Metal: [[1, 3, 5, 6, 1, 2, 3, 4], [1, 3, 4, 5], [2, 5, 1, 5]],
  Jazz: [[1,2,5,1], [2,5,1,4], [3,6,2,5]]
};
// === GROOVES ===
const ALL_GROOVES = [
  { name: "Rock", meter: "4/4", drumPattern: ["bch - ch - cch - ch - bch - ch - cch - ch bu"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8] },
  { name: "Rock2", meter: "4/4", drumPattern: ["bch - ch - cch - ch - bch - ch - cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 1, 1, 5] },
  { name: "Rock3", meter: "4/4", drumPattern: ["bch - ch bu cch bu ch - bch - ch - cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo x bo x bo x"], bassScale: [1, 1, 1, 1] },
  { name: "Rock4", meter: "4/4", drumPattern: ["ba - co - cco - co - bco - co - cco bu bco bu"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 7, 8, 7, 5, 3] },
  { name: "Rock5", meter: "4/4", drumPattern: ["bch ch ch ch cch ch ch ch bch ch ch ch cch ch ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo x bo x bo x"], bassScale: [1, 3, 1, 5] },
  { name: "Rock6", meter: "4/4", drumPattern: ["bco co co co cco co co co bco co co co cco co co co"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [8, 8, 1, 1] },
  { name: "Rock7", meter: "4/4", drumPattern: ["bch - ch - cch - ch - bch - co - cco - co -"], bassRhythm: ["bo - bo - bo bo bo bo bo - bo - bo - bo -"], bassScale: [1, 1, 1, 1] },
  { name: "Rock_Progressivo", meter: "7/4", drumPattern: ["bch - ch -  cch - ch - bch - ch - cch - ch bu bch - ch - cch - ch - bch - ch bu"], bassRhythm: ["bo - - - - - - - bo - - - - - - bo - - bo bo bo bo bo bo bo bo bo bo"], bassScale: [1, 1, 1, 3, 5, 8, 3, 5, 8, 3, 5, 8, 5] },
  { name: "Rock_Progressivo2", meter: "5/4", drumPattern: ["ba - ch - bch - ch - cch - ch - bch - ch - cch - ch bu"], bassRhythm: ["bo - x x bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 1, 1, 1, 3, 5, 8, 1, 3, 5, 8] },
  { name: "Rock_Progressivo3", meter: "6/4", drumPattern: ["ba - - - ch - - bu cch - - - ch - - - bch - - - ch - - -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 1, 1, 3, 1, 1, 1, 3, 5, 5, 5, 1] },
  { name: "Rock_Progressivo4", meter: "4/4", drumPattern: ["ba - ch bu cch - ch - bch - ch bu cch - ch bu"], bassRhythm: ["bo - - bo - - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8] },
  { name: "Rock_Progressivo5", meter: "7/4", drumPattern: ["ba - co -  cco - co - bco - co bu cco - co bu bch bu co - cch - ch - bch - ch bu"], bassRhythm: ["bo - - bo bo - - - bo - - bo bo - - bo - - bo bo - - bo bo - - bo bo"], bassScale: [1, 3, 5, 8] },
  { name: "Rock_Progressivo6", meter: "3/4", drumPattern: ["bch - - - ch - - bu cch - - -"], bassRhythm: ["bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8, 8, 8]},
  { name: "Rock_Progressivo7", meter: "4/4", drumPattern: ["bco co cch to1 cch - ch - bch - ch cch bu bu ch bu"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 1, 1, 1] },
  { name: "Blues", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 7, 8, 7, 5, 3] },
  { name: "Blues2", meter: "4/4", drumPattern: ["bch - - - cch - - - bch - - - cch - - -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8] },
  { name: "Blues3", meter: "4/4", drumPattern: ["bch - - bu cch - ch - ch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 7] },
  { name: "Blues4", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [8, 7, 5, 3, 1, 3, 5, 7] },
  { name: "Blues5", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 7, 1, 1, 1, 1] },
  { name: "Blues6", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8, 8, 8, 8, 8] },
  { name: "Blues7", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8, 7, 5, 3, 5] },
  { name: "Forr√≥", meter: "2/4", drumPattern: ["bch co ch bu bco ch cch"], bassRhythm: ["bo - - - bo - - x"], bassScale: [8, 1] },
  { name: "Forr√≥2", meter: "2/4", drumPattern: ["su co ch bu bco ch co"], bassRhythm: ["bo - - - bo - - x"], bassScale: [8,1] },
  { name: "Forr√≥3", meter: "2/4", drumPattern: ["bch co ch su bco ch su"], bassRhythm: ["bo - - - bo - - x"], bassScale: [8, 1] },
  { name: "Forr√≥4", meter: "2/4", drumPattern: ["bch co ch bu bco su cch"], bassRhythm: ["bo - - - bo - - x"], bassScale: [8, 1] },
  { name: "Metal", meter: "4/4", drumPattern: ["bch bu bch bu cch bu bch bu bch bu bch bu cch bu bch bu"], bassRhythm: ["bo bo bo bo bo bo bo bo bo bo bo bo bo bo bo bo"], guitarRhythm: ["ab ab ab ab so - - - ab - ab - so - - -"] },
  { name: "Metal2", meter: "4/4", drumPattern: ["bch bu bch bu cch bu bch bu cch - ch bu cch bu bch bu"], bassRhythm: ["bo bo bo bo bo bo bo bo bo bo bo bo bo bo bo bo"], guitarRhythm: ["ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab"] },
  { name: "Metal3", meter: "4/4", drumPattern: ["bch bu bch - cch - ch - bch bu ch bu cch - ch -"], bassRhythm: ["bo bo bo - - - - - bo bo - bo - - - -"] },
  // Groove Metal4 ATUALIZADO com guitarRhythm
  { name: "Metal4", meter: "4/4", drumPattern: ["bch bu cch - bu bu cch - bu bu cch - bu bu cch -"], bassRhythm: ["bo bo bo - bo bo bo - bo bo bo - bo bo bo -"], guitarRhythm: ["ab - ab - so - - - ab - ab - so - - -"] },
  { name: "Samba", meter: "2/4", drumPattern: ["bch - ch bu bch - ch bu"], bassRhythm: ["bo - - x bo - - x"], bassScale: [8, 5] },
  { name: "Jazz", meter: "4/4", drumPattern: ["bch co co - co co co ca bch co co - bch co co cch"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: "chromatic" },
];
const state = {
  running: false,
  paused: false,
  nextNoteTime: 0,
  meter: '4/4',
  bpm: 100,
  sixteenthDur: 0.15,
  stepIndex: 0,
  buffers: { drums: {}, bass: {}, guitar: {}, melody: {} },
  bassPlan: [],
  chordPlan: [],
  signatureTag: '',
  key: null,
  keyIdx: 0,
  quality: 'maj', // Sempre maior, como solicitado
  chordProgression: [],
  chordDurations: [],
  currentGroove: null,
  currentChordIndex: 0,
  barsInChord: 0,
  clickCount: 0,
  totalClicks: 0,
  drumSeq: [],
  lastBassSource: null,
  lastBassGainNode: null,
  lastCleanSource: null,
  lastDistSource: null,
  lastMelodySource: null,
  lastMelodyGain: null,
  melodyBlocks: [],
  melodyPlan: [],
  lastMelodyNote: null,
  guitarPlan: null, // Novo campo para armazenar o plano expandido da guitarra
  activeInput: null // Armazena o input ativo no mobile
};
const mute = { bass: false, drums: false, clean: false, dist: false };
function log(msg) {
  console.log(`[LOG] ${msg}`);
}
function meterToBeats(meter) {
  return Number(meter.split('/')[0]) || 4;
}
function setStatePanel() {
  ui.state.innerHTML = `<div>Levada: ${state.signatureTag || '‚Äî'}</div><div>Key: ${state.key || '‚Äî'} ${state.quality}</div>`;
}
let initPromise = null;
function updateVolume() {
  // Volumes individuais
  audio.bassGain.gain.value = parseFloat(ui.volBass.value);
  audio.drumGain.gain.value = parseFloat(ui.volDrums.value);
  audio.cleanGain.gain.value = parseFloat(ui.volClean.value);
  audio.distGain.gain.value = parseFloat(ui.volDist.value);
  if (audio.melodyGain) {
    audio.melodyGain.gain.value = parseFloat(ui.volMelody.value);
  }
    // Atualiza labels
  ui.volBassLabel.textContent = Math.round(ui.volBass.value * 100) + '%';
  ui.volDrumsLabel.textContent = Math.round(ui.volDrums.value * 100) + '%';
  ui.volCleanLabel.textContent = Math.round(ui.volClean.value * 100) + '%';
  ui.volDistLabel.textContent = Math.round(ui.volDist.value * 100) + '%';
  ui.volMelodyLabel.textContent = Math.round(ui.volMelody.value * 100) + '%';
  }
async function initAudio() {
  if (audio.ctx) return;
  if (initPromise) return initPromise;
  initPromise = (async () => {
    audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
    audio.master = audio.ctx.createGain();
    audio.mix = audio.ctx.createGain();
    audio.drumGain = audio.ctx.createGain();
    audio.bassGain = audio.ctx.createGain();
    audio.cleanGain = audio.ctx.createGain();
    audio.distGain = audio.ctx.createGain();
    audio.melodyGain = audio.ctx.createGain();
    audio.melodyGain.gain.value = 0.50; // Valor inicial
    audio.melodyGain.connect(audio.master); // Conecta ao mix principal
    audio.master.gain.value = 0.9;
    audio.drumGain.gain.value = 0.6;
    audio.bassGain.gain.value = 0.45;
    audio.cleanGain.gain.value = 0.45;
    audio.distGain.gain.value = 0.35;
    audio.master.connect(audio.mix);
    audio.mix.connect(audio.ctx.destination);
    audio.drumGain.connect(audio.master);
    audio.bassGain.connect(audio.master);
    audio.cleanGain.connect(audio.master);
    audio.distGain.connect(audio.master);
    if (!state.buffers.melody) state.buffers.melody = {};
    await ensureBasicSamples();
    // Conecta todos os sliders √† fun√ß√£o de atualiza√ß√£o
ui.volBass.addEventListener('input', updateVolume);
ui.volDrums.addEventListener('input', updateVolume);
ui.volClean.addEventListener('input', updateVolume);
ui.volDist.addEventListener('input', updateVolume);
ui.volMelody.addEventListener('input', updateVolume);
// Aplica os valores iniciais dos sliders
updateVolume();
  })();
  return initPromise;
}
async function loadBuffer(url) {
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const arrayBuffer = await res.arrayBuffer();
    return await audio.ctx.decodeAudioData(arrayBuffer);
  } catch (e) {
    console.warn(`Erro ao carregar: ${url}`);
    return null;
  }
}
async function ensureBasicSamples() {
  const promises = [];
  for (const [key, name] of Object.entries(DRUMS)) {
    const url = `assets/${name}.mp3`;
    if (!state.buffers.drums[key]) {
      promises.push(loadBuffer(url).then(buf => { if (buf) state.buffers.drums[key] = buf; }));
    }
  }
  for (const [key, url] of Object.entries(BASS_SAMPLES)) {
    if (!state.buffers.bass[key]) {
      promises.push(loadBuffer(url).then(buf => { if (buf) state.buffers.bass[key] = buf; }));
    }
  }
  await Promise.all(promises);
}
function expandRhythm(patternArray, totalSteps) {
  const joined = patternArray.join(' ').replace(/\s+/g, ' ').trim();
  const tokens = joined.split(/\s+/).filter(t => t);
  const out = [];
  let i = 0;
  while (out.length < totalSteps) {
    for (const token of tokens) {
      if (out.length >= totalSteps) break;
      out.push(token);
    }
    if (i++ > 1000) break;
  }
  return out.slice(0, totalSteps);
}
async function buildBassAndChordPlan() {
  state.currentGroove = ALL_GROOVES[Math.floor(Math.random() * ALL_GROOVES.length)];
  state.signatureTag = state.currentGroove.name;
  state.meter = ui.meter.value === 'auto' ? state.currentGroove.meter : ui.meter.value;
  if (state.currentGroove.name === "Samba") {
    ui.bpm.value = 70;
    state.bpm = 70;
  } else {
    state.bpm = Number(ui.bpm.value) || 100;
  }
  const beats = meterToBeats(state.meter);
  const sixteenthsPerBar = beats * 4;
  state.keyIdx = Math.floor(Math.random() * PITCHES.length);
  state.key = PITCHES[state.keyIdx];
  // Campo harm√¥nico √© sempre maior, como solicitado
  state.quality = 'maj';
  const grooveName = state.currentGroove.name;
  let styleKey = "Rock";
  if (grooveName.includes("Samba")) styleKey = "Samba";
  else if (grooveName.includes("Jazz")) styleKey = "Jazz";
  else if (grooveName.includes("Forr√≥")) styleKey = "Forr√≥";
  else if (grooveName.includes("Metal")) styleKey = "Metal";
  else if (grooveName.includes("Blues")) styleKey = "Blues";
  const progressions = STYLE_PROGRESSIONS[styleKey] || STYLE_PROGRESSIONS.Rock;
  // --- NOVA L√ìGICA AQUI ---
  // Seleciona uma progress√£o que N√ÉO comece com o grau 7 (diminuto)
  let availableProgressions = progressions.filter(prog => prog[0] !== 7);
  // Se todas as progress√µes come√ßarem com 7 (improv√°vel), usa a lista original como fallback
  if (availableProgressions.length === 0) {
    availableProgressions = progressions;
  }
  state.chordProgression = availableProgressions[Math.floor(Math.random() * availableProgressions.length)];
  const totalBars = Math.min(state.chordProgression.length, 64);
  const totalSteps = sixteenthsPerBar * totalBars;
  const rhythm = expandRhythm(state.currentGroove.bassRhythm, totalSteps);
  const bassPlan = [];
  const chordPlan = [];
  function getBassNotesFromScale(degree, scale, quality) {
    if (scale === "chromatic") {
      const rootIdx = (state.keyIdx + DEGREE_TO_ROOT[degree]) % 12;
      const rootNote = PITCHES[rootIdx];
      const octave = 8;
      return Array(8).fill().map((_, i) => {
        const noteIdx = (rootIdx - i + 12) % 12;
        const p = PITCHES[noteIdx];
        return p.endsWith('S') ? `${p.replace('S', '')}${octave}S` : `${p}${octave}`;
      });
    }
    if (Array.isArray(scale)) {
      const rootIdx = (state.keyIdx + DEGREE_TO_ROOT[degree]) % 12;
      return scale.map(interval => {
        const intervalOffset = DEGREE_TO_ROOT[interval] || 0;
        const noteIdx = (rootIdx + intervalOffset) % 12;
        const noteName = PITCHES[noteIdx];
        if (interval === 1) return noteName;
        return noteName.endsWith('S') ? `${noteName.replace('S', '')}8S` : `${noteName}8`;
      });
    }
    return [PITCHES[(state.keyIdx + DEGREE_TO_ROOT[degree]) % 12]];
  }
  // --- NOVA L√ìGICA AQUI ---
  // Determina a varia√ß√£o √∫nica para toda a progress√£o
  let globalChordVariation = '';
  if (styleKey === "Blues") {
    // Para Blues, for√ßa todos os acordes a serem s√©tima
    globalChordVariation = '7';
  } else {
    // Para outros estilos, sorteia UMA varia√ß√£o para toda a progress√£o
    const allVariations = ['', '11', '13', '4', '45+', '5', '5+', '6', '7', '75+', '9', '95+', 'm', 'm4', 'm5', 'm5+', 'm6', 'm7', 'm75+', 'm79', 'm9', 'dim'];
    globalChordVariation = allVariations[Math.floor(Math.random() * allVariations.length)];
  }
  for (let bar = 0; bar < totalBars; bar++) {
    const degree = state.chordProgression[bar];
    const rootOffset = DEGREE_TO_ROOT[degree] || 0;
    const rootIdx = (state.keyIdx + rootOffset) % 12;
    const rootNote = PITCHES[rootIdx];
    // Define o tipo de acorde baseado na l√≥gica do campo harm√¥nico maior: I-maj, II-min, III-min, IV-maj, V-maj, VI-min, VII-dim
    let chordType = '';
    // --- APLICA A VARIA√á√ÉO GLOBAL ---
    if (styleKey === "Blues") {
      // No Blues, todos s√£o 7, independente do grau
      chordType = globalChordVariation;
    } else {
      // Em outros estilos, aplica a varia√ß√£o global, mas respeita a natureza do grau
      switch(degree) {
        case 1:
        case 4:
        case 5:
          // Acordes maiores
          // Usa a varia√ß√£o global apenas se for compat√≠vel com acorde maior
          if (globalChordVariation === '' || globalChordVariation.startsWith('m') === false) {
            chordType = globalChordVariation;
          } else {
            // Se a varia√ß√£o global √© menor, for√ßa a ser maior (vazio ou 7, por exemplo)
            chordType = '';
          }
          break;
        case 2:
        case 3:
        case 6:
          // Acordes menores
          // Usa a varia√ß√£o global apenas se for compat√≠vel com acorde menor
          if (globalChordVariation.startsWith('m') || globalChordVariation === 'dim') {
            chordType = globalChordVariation;
          } else {
            // Se a varia√ß√£o global √© maior, for√ßa a ser menor (m ou m7, por exemplo)
            chordType = 'm';
          }
          break;
        case 7:
          // Acorde diminuto
          chordType = 'dim';
          break;
        default:
          chordType = '';
      }
    }
    const chordDisplay = CHORD_NAMES[rootIdx] + chordType;
    const displayedNote = transposeDown3Semitones(CHORD_NAMES[rootIdx]);
    const displayedChord = displayedNote + chordType;
    chordPlan.push({ note: rootNote, type: chordType, display: chordDisplay, displayed: displayedChord });
    const bassNotes = getBassNotesFromScale(degree, state.currentGroove.bassScale, state.quality);
    const stepsInBar = sixteenthsPerBar;
    const notesPerBar = Math.ceil(stepsInBar / bassNotes.length);
    const fullBassNotes = Array(stepsInBar).fill().map((_, i) => bassNotes[Math.floor(i / notesPerBar)] || bassNotes[0]);
    for (let stepInBar = 0; stepInBar < stepsInBar; stepInBar++) {
      const step = bar * stepsInBar + stepInBar;
      const sym = rhythm[step] || '-';
      let bassNote = null;
      if (sym === 'x') bassNote = 'x';
      else if (sym === '-' || sym === 'sm') bassNote = '-';
      else bassNote = fullBassNotes[stepInBar];
      bassPlan.push(bassNote);
    }
  }
  state.bassPlan = bassPlan;
  state.chordPlan = chordPlan;
  state.currentChordIndex = 0;
  state.barsInChord = 0;
  state.chordDurations = Array(state.chordPlan.length).fill(1);
  const progEl = document.getElementById('chordProgression');
  if (progEl && state.chordPlan.length > 0) {
    const chordLabels = state.chordPlan.map(ch => ch.displayed);
    progEl.innerHTML = chordLabels.map((label, i) => `<span class="chord-item" data-index="${i}">${label}</span>`).join(' ');
  }
  const drumParsed = parsePattern(state.currentGroove.drumPattern.join(' '));
  const drumSeq = [...drumParsed.intro, ...drumParsed.loop];
  const drumExpanded = [];
  while (drumExpanded.length < state.bassPlan.length) {
    for (const t of drumSeq) {
      if (drumExpanded.length >= state.bassPlan.length) break;
      drumExpanded.push(t);
    }
  }
  state.drumSeq = drumExpanded.slice(0, state.bassPlan.length);
  setStatePanel();

  // --- CORRE√á√ÉO PARA CARREGAR TODOS OS TIPOS DE SAMPLES (ab, de, so) ---
    // --- CORRE√á√ÉO PARA CARREGAR TODOS OS TIPOS DE SAMPLES (ab, de, so) ---
    // --- CORRE√á√ÉO PARA CARREGAR TODOS OS TIPOS DE SAMPLES (ab, de, so) ---
  const guitarUrls = new Set();
  for (const ch of state.chordPlan) {
    let fullChordName = ch.note;
    if (ch.type) fullChordName += ch.type; // concatena s√≥ se tiver tipo (m, 7, dim...)
    // Guitarra Distorcida
    guitarUrls.add(`guitarraDistorcao/${ch.note}/${fullChordName}.mp3`);
    guitarUrls.add(`guitarraDistorcao/abafadas/${ch.note}/${fullChordName}.mp3`);
    guitarUrls.add(`guitarraDistorcao/dedilhada/${ch.note}/${fullChordName}.mp3`);
    // Guitarra Limpa
    guitarUrls.add(`guitarraLimpa/${ch.note}/${fullChordName}.mp3`);
  }
  const preloadPromises = [];
  guitarUrls.forEach(url => {
    if (!state.buffers.guitar) state.buffers.guitar = {};
    if (!state.buffers.guitar[url]) {
      const p = loadBuffer(url).then(buf => { if (buf) state.buffers.guitar[url] = buf; });
      preloadPromises.push(p);
    }
  });
  await Promise.all(preloadPromises);

    // --- DIAGN√ìSTICO: Verifica se pelo menos UM sample de guitarra foi carregado ---
  const guitarSamplesLoaded = Object.keys(state.buffers.guitar || {}).length;
  console.log(`üé∏ Samples de guitarra carregados: ${guitarSamplesLoaded}`);
  if (guitarSamplesLoaded === 0) {
    alert("‚ö†Ô∏è Nenhum sample de guitarra foi carregado. Verifique se as pastas 'guitarraDistorcao' e 'guitarraLimpa' existem e cont√™m os arquivos MP3.");
  }
  // --- FIM DO DIAGN√ìSTICO ---
} // <-- ESTA CHAVE DEVE SER A √öNICA QUE FECHA A FUN√á√ÉO buildBassAndChordPlan
function parsePattern(patternText) {
  const result = { intro: [], loop: [] };
  const introMatch = patternText.match(/\[(.*?)\]/);
  const loopMatch = patternText.match(/\((.*?)\)/);
  if (introMatch) result.intro = introMatch[1].trim().split(/\s+/).filter(s => s);
  if (loopMatch) result.loop = loopMatch[1].trim().split(/\s+/).filter(s => s);
  if (!introMatch && !loopMatch) result.loop = patternText.trim().split(/\s+/).filter(s => s);
  if (!result.loop.length) result.loop = result.intro.slice();
  return result;
}
function playClickAtTime(time, isStrong) {
  const ctx = audio.ctx;
  const osc = ctx.createOscillator();
  const g = ctx.createGain();
  osc.connect(g);
  g.connect(audio.drumGain);
  osc.frequency.value = isStrong ? 880 : 440;
  g.gain.setValueAtTime(0.0, time);
  g.gain.linearRampToValueAtTime(isStrong ? 0.18 : 0.09, time + 0.002);
  g.gain.linearRampToValueAtTime(0.0, time + 0.06);
  osc.start(time);
  osc.stop(time + 0.07);
}
async function onPlay() {
  try {
    // üîä Garante que o AudioContext exista
    if (!audio.ctx) {
      await initAudio();
    }

    // üéµ Alguns navegadores iniciam o ctx suspenso
    if (audio.ctx.state === "suspended") {
      await audio.ctx.resume();
    }

    // ‚èØ Se estava apenas pausado, retoma sem nova contagem
    if (state.paused) {
      state.paused = false;
      state.running = true;
      console.log("‚èØ Playback retomado");
      return;
    }

    // ‚ñ∂Ô∏è Reinicia o sequenciador do zero
    state.running = true;
    state.stepIndex = 0;
    state.nextNoteTime = audio.ctx.currentTime + 0.05;

    const beats = meterToBeats(state.meter);
    const quarterDur = 60 / state.bpm;
    const startTime = audio.ctx.currentTime + 0.05;

    // üîî Toca os cliques de contagem antes de come√ßar
    for (let i = 0; i < beats; i++) {
      const t = startTime + i * quarterDur;
      const isStrong = (i % beats) === 0;
      playClickAtTime(t, isStrong);
    }

    const schedulerStartTime = startTime + beats * quarterDur;

    // üöÄ Inicia o scheduler ap√≥s a contagem
    setTimeout(() => {
      state.running = true;
      state.nextNoteTime = schedulerStartTime;
      startScheduler();
      console.log("‚ñ∂Ô∏è Playback iniciado com sucesso.");
    }, Math.max(0, (schedulerStartTime - audio.ctx.currentTime) * 1000 + 10));

  } catch (err) {
    console.error("‚ùå Falha cr√≠tica ao inicializar √°udio:", err);
  }
}


function scheduler() {
  if (!state.running || state.paused) return;
  const lookahead = 0.20;
  const currentTime = audio.ctx.currentTime;
  while (state.nextNoteTime < currentTime + lookahead) {
    scheduleStep();
  }
}
function scheduleStep() {
  const time = state.nextNoteTime;
  const stepIdx = state.stepIndex;
  const beats = meterToBeats(state.meter);
  const sixteenthsPerBar = beats * 4;
  const isNewBar = (stepIdx % sixteenthsPerBar) === 0;
  // üéµ DRUMS (mantido igual)
  const drumToken = state.drumSeq[stepIdx % state.drumSeq.length];
  if (drumToken && !mute.drums) {
    let drumKey = null;
    if (['bu', 'bumbo'].includes(drumToken)) drumKey = 'bu';
    else if (['ca', 'caixa'].includes(drumToken)) drumKey = 'ca';
    else if (['ch', 'chimbal'].includes(drumToken)) drumKey = 'ch';
    else if (['ba', 'bumbo-ataque'].includes(drumToken)) drumKey = 'ba';
    else if (['cch', 'caixa-chimbal'].includes(drumToken)) drumKey = 'cch';
    else if (['bco', 'bumbo-conducao'].includes(drumToken)) drumKey = 'bco';
    else if (['co', 'conducao'].includes(drumToken)) drumKey = 'co';
    else if (['cco', 'caixa-conducao'].includes(drumToken)) drumKey = 'cco';
    else if (['to1', 'tom-1'].includes(drumToken)) drumKey = 'to1';
    else if (['to2', 'tom-2'].includes(drumToken)) drumKey = 'to2';
    else if (['su', 'surdo'].includes(drumToken)) drumKey = 'su';
    else if (['bch', 'bumbo-chimbal'].includes(drumToken)) drumKey = 'bch';
    if (drumKey && state.buffers.drums[drumKey]) {
      const src = audio.ctx.createBufferSource();
      const g = audio.ctx.createGain();
      src.buffer = state.buffers.drums[drumKey];
      src.connect(g);
      g.connect(audio.drumGain);
      g.gain.setValueAtTime(0.0, time);
      g.gain.linearRampToValueAtTime(1.0, time + 0.005);
      src.start(time);
    }
  }
  // üé∏ BASS (mantido igual)
  const bassCommand = state.bassPlan[stepIdx % state.bassPlan.length];
  if (!mute.bass && state.lastBassSource) {
    state.lastBassSource.stop(time);
    state.lastBassSource = null;
  }
  if (!mute.bass && bassCommand !== '-' && bassCommand !== 'x') {
    const buf = state.buffers.bass[bassCommand];
    if (buf) {
      const src = audio.ctx.createBufferSource();
      const g = audio.ctx.createGain();
      src.buffer = buf;
      src.connect(g);
      g.connect(audio.bassGain);
      g.gain.setValueAtTime(0.0, time);
      g.gain.linearRampToValueAtTime(1.0, time + 0.01);
      src.start(time);
      state.lastBassSource = src;
    }
  }
  // üé∏ GUITAR (mantido igual)
  if (state.currentGroove && state.currentGroove.guitarRhythm) {
    if (!state.guitarPlan) {
      state.guitarPlan = expandRhythm(state.currentGroove.guitarRhythm, state.bassPlan.length);
    }
    const guitarCommand = state.guitarPlan[state.stepIndex % state.guitarPlan.length];
    if (guitarCommand && guitarCommand !== '-' && !mute.dist) {
      const chord = state.chordPlan[state.currentChordIndex];
      if (chord) {
        let baseFolder = 'guitarraDistorcao';
        if (guitarCommand === 'ab') baseFolder = 'guitarraDistorcao/abafadas';
        else if (guitarCommand === 'de') baseFolder = 'guitarraDistorcao/dedilhada';
        else if (guitarCommand === 'so') baseFolder = 'guitarraDistorcao';
        let fullChordName = chord.note;
        if (chord.type) fullChordName += chord.type;
        const url = `${baseFolder}/${chord.note}/${fullChordName}.mp3`;

        const buf = state.buffers.guitar?.[url] || null;
        if (buf && time >= audio.ctx.currentTime - 0.02) {
          if (state.lastDistSource) state.lastDistSource.stop(time);
          const src = audio.ctx.createBufferSource();
          const g = audio.ctx.createGain();
          src.buffer = buf;
          src.connect(g);
          g.connect(audio.distGain);
          g.gain.setValueAtTime(0.0, time);
          g.gain.linearRampToValueAtTime(1.0, time + 0.01);
          src.start(time);
          state.lastDistSource = src;
        }
      }
    }
 } else {
  if (isNewBar) {
    if (state.lastCleanSource) state.lastCleanSource.stop(time);
    if (state.lastDistSource) state.lastDistSource.stop(time);
    const chord = state.chordPlan[state.currentChordIndex];
    if (chord) {
      // Toca a guitarra limpa, se n√£o estiver mutada
      if (!mute.clean) {
        playCleanChord(time, chord.note, chord.type);
      }
      // Toca a guitarra distorcida, se n√£o estiver mutada
      if (!mute.dist) {
        // --- SUBSTITUI√á√ÉO: L√≥gica inline para tocar acorde distorcido ---
        const fullChordName = chord.note + chord.type;
        const url = `guitarraDistorcao/${chord.note}/${fullChordName}.mp3`;
        const buf = state.buffers.guitar?.[url] || null;
        if (buf && time >= audio.ctx.currentTime - 0.02) {
          const src = audio.ctx.createBufferSource();
          const g = audio.ctx.createGain();
          src.buffer = buf;
          src.connect(g);
          g.connect(audio.distGain);
          g.gain.setValueAtTime(0.0, time);
          g.gain.linearRampToValueAtTime(1.0, time + 0.01);
          src.start(time);
          state.lastDistSource = src;
        } else {
          console.warn(`Buffer n√£o carregado para o acorde DISTORCIDO: ${fullChordName} | URL: ${url}`);
        }
        // --- FIM DA SUBSTITUI√á√ÉO ---
      }
    }
  }
}
  // üéº MELODY ‚Äî L√ìGICA APRIMORADA
  const melodyEvent = state.melodyPlan[stepIdx % state.melodyPlan.length];
  if (melodyEvent && melodyEvent.type === 'start') {
    // Nova nota come√ßa
    if (melodyEvent.adaptedNumber === null) {
      const chord = state.chordPlan[state.currentChordIndex];
      const adaptedNumber = adaptNumberToChord(
        melodyEvent.originalNumber,
        chord.note,
        chord.type,
        state.lastMelodyNote
      );
      melodyEvent.adaptedNumber = adaptedNumber;
      state.lastMelodyNote = adaptedNumber;
    }
    playMelodyNumber(time, melodyEvent.adaptedNumber, melodyEvent.instrument);
  } else if (melodyEvent && melodyEvent.type === 'mute') {
    // Evento de pausa: para a nota e limpa o estado
    stopMelodyAt(time);
    state.lastMelodyNote = null;
  } else if (state.lastMelodyNote !== null) {
    // --- NOVO: Se N√ÉO h√° evento, mas H√Å uma nota sustentada, ela se readapta ao acorde atual ---
    const chord = state.chordPlan[state.currentChordIndex];
    if (chord) {
      const newlyAdaptedNumber = adaptNumberToChord(
        state.lastMelodyNote,
        chord.note,
        chord.type,
        null // For√ßa readapta√ß√£o ignorando a nota anterior
      );
      // S√≥ toca se a nota mudou (evita glitches de sobreposi√ß√£o)
      if (newlyAdaptedNumber !== state.lastMelodyNote) {
        playMelodyNumber(time, newlyAdaptedNumber, ui.melodyInstrument.value);
        state.lastMelodyNote = newlyAdaptedNumber;
      }
    }
  }
  state.stepIndex++;
  // ‚è© Troca de compasso (mantido, mas removemos a readapta√ß√£o redundante)
  if (isNewBar) {
    state.currentChordIndex = (state.currentChordIndex + 1) % state.chordPlan.length;
    state.barsInChord = 0;
    // üëâ A readapta√ß√£o agora √© feita continuamente em `scheduleStep`, n√£o apenas no in√≠cio do compasso
    state.guitarPlan = null;
  }
  state.nextNoteTime += state.sixteenthDur;
}
// --- CORRE√á√ÉO DA FUN√á√ÉO playChord PARA O COMPORTAMENTO ANTIGO ---
// Esta fun√ß√£o √© usada apenas quando o groove N√ÉO tem `guitarRhythm` definido.
// --- NOVA FUN√á√ÉO: Toca um acorde na guitarra limpa ---
function playCleanChord(time, note, type) {
let fullChordName = note;
if (type) fullChordName += type;
const folder = 'guitarraLimpa';
const url = `${folder}/${note}/${fullChordName}.mp3`;

  const buf = state.buffers.guitar?.[url] || null;
  if (buf && time >= audio.ctx.currentTime - 0.02) {
    const src = audio.ctx.createBufferSource();
    const g = audio.ctx.createGain();
    src.buffer = buf;
    src.connect(g);
    g.connect(audio.cleanGain); // Conecta ao ganho da guitarra LIMPA
    g.gain.setValueAtTime(0.0, time);
    g.gain.linearRampToValueAtTime(1.0, time + 0.01);
    src.start(time);
    state.lastCleanSource = src;
  } else {
    console.warn(`Buffer n√£o carregado para o acorde LIMPO: ${fullChordName} | URL: ${url}`);
  }
}
function onPause() {
  if (!state.running) return;
  state.paused = true;
  state.running = false;
  console.log("‚è∏ Playback pausado");
}
function onStop() {
  state.running = false;
  state.paused = false;
  state.stepIndex = 0;
  state.nextNoteTime = 0;
  console.log("‚èπ Playback parado");
}
function startScheduler() {
  function tick() {
    if (state.running && !state.paused) scheduler();
    requestAnimationFrame(tick);
  }
  tick();
}
function toggleMute(type, button) {
  mute[type] = !mute[type];
  const icon = mute[type] ? 'üîá' : (type === 'bass' ? 'üé∏' : (type === 'drums' ? 'ü•Å' : (type === 'clean' ? 'üé∏' : 'üî•')));
  const labelMap = { bass: 'Baixo', drums: 'Bateria', clean: 'Limpa', dist: 'Distor√ß√£o' };
  button.textContent = `${icon} ${labelMap[type]}`;
  button.classList.toggle('muted', mute[type]);
}
ui.play.addEventListener('click', onPlay);
ui.pause.addEventListener('click', onPause);
ui.stop.addEventListener('click', onStop);
ui.muteBass.addEventListener('click', () => toggleMute('bass', ui.muteBass));
ui.muteDrums.addEventListener('click', () => toggleMute('drums', ui.muteDrums));
ui.muteClean.addEventListener('click', () => toggleMute('clean', ui.muteClean));
ui.muteDist.addEventListener('click', () => toggleMute('dist', ui.muteDist));
// --- MELODY SYSTEM ---
const ORDER_E_UP = ['E','F','FS','G','GS','A','AS','B','C','CS','D','DS'];
const NUM_TO_NAME = (() => {
  const map = {};
  let n = 1, i = 0;
  while (n <= 49) {
    map[n] = ORDER_E_UP[i % ORDER_E_UP.length];
    n++; i++;
  }
  return map;
})();
function chordTriad(rootPitchName, quality) {
  const rootIdx = PITCHES.indexOf(rootPitchName);
  if (rootIdx === -1) return [rootPitchName]; // fallback
  // Extrai a qualidade b√°sica (maj, min, dim) e as extens√µes (7, 9, etc)
  let basicQuality = 'maj';
  let hasSeventh = false;
  let hasNinth = false;
  if (quality.includes('m') && !quality.includes('maj')) {
    basicQuality = 'min';
  } else if (quality.includes('dim')) {
    basicQuality = 'dim';
  }
  // Verifica se o acorde tem s√©tima (7, m7, dim7, etc.)
  if (quality.includes('7')) {
    hasSeventh = true;
  }
  // Verifica se o acorde tem nona (9, m9, 79, m79, etc.)
  // Procura por '9' que n√£o seja precedido por '1' (para evitar confundir com '19')
  if (/[^1]9/.test(quality) || quality.endsWith('9')) {
    hasNinth = true;
  }
  let chordNotes = [];
  // Constr√≥i a tr√≠ade b√°sica
  if (basicQuality === 'min') {
    chordNotes = [
      PITCHES[rootIdx], // 1¬™
      PITCHES[(rootIdx + 3) % 12], // 3¬™ menor
      PITCHES[(rootIdx + 7) % 12] // 5¬™ justa
    ];
  } else if (basicQuality === 'dim') {
    chordNotes = [
      PITCHES[rootIdx], // 1¬™
      PITCHES[(rootIdx + 3) % 12], // 3¬™ menor
      PITCHES[(rootIdx + 6) % 12] // 5¬™ diminuta
    ];
  } else {
    chordNotes = [
      PITCHES[rootIdx], // 1¬™
      PITCHES[(rootIdx + 4) % 12], // 3¬™ maior
      PITCHES[(rootIdx + 7) % 12] // 5¬™ justa
    ];
  }
  // Adiciona a 7¬™, se presente
  if (hasSeventh) {
    if (basicQuality === 'min' || basicQuality === 'dim') {
      // Para acordes menores e diminutos, a 7¬™ √© menor (10 semitons da t√¥nica)
      chordNotes.push(PITCHES[(rootIdx + 10) % 12]);
    } else {
      // Para acordes maiores, a 7¬™ √© maior (11 semitons da t√¥nica)
      chordNotes.push(PITCHES[(rootIdx + 11) % 12]);
    }
  }
  // Adiciona a 9¬™, se presente
  if (hasNinth) {
    // A 9¬™ √© a mesma nota da 2¬™, uma oitava acima (2 semitons da t√¥nica)
    chordNotes.push(PITCHES[(rootIdx + 2) % 12]);
  }
  return chordNotes;
}
function distanceBetweenNotes(n1, n2) {
  const i1 = ORDER_E_UP.indexOf(n1);
  const i2 = ORDER_E_UP.indexOf(n2);
  return i1 === -1 || i2 === -1 ? 100 : Math.abs(i1 - i2);
}
function adaptNumberToChord(number, root, type, lastPlayedNote = null) {
  const baseName = NUM_TO_NAME[number]; // nota que o usu√°rio "quer"
  const chordNotes = chordTriad(root, type); // notas do acorde em vigor
  // 1. Se a nota j√° est√° no acorde, mant√©m
  if (chordNotes.includes(baseName)) {
    return findClosestNumber(number, baseName);
  }
  // 2. Se n√£o est√°, pega a nota do acorde mais pr√≥xima
  const noteDistances = chordNotes.map(note => ({
    note,
    distance: distanceBetweenNotes(baseName, note)
  }));
  noteDistances.sort((a, b) => a.distance - b.distance);
  // 3. Se houver √∫ltima nota tocada e a mais pr√≥xima for igual, pega a segunda
  if (lastPlayedNote && noteDistances.length > 1) {
    const lastNoteName = NUM_TO_NAME[lastPlayedNote];
    if (noteDistances[0].note === lastNoteName) {
      return findClosestNumber(number, noteDistances[1].note);
    }
  }
  // 4. Retorna a mais pr√≥xima
  return findClosestNumber(number, noteDistances[0].note);
}
function findClosestNumber(targetNumber, targetNote) {
  let bestNum = targetNumber;
  let bestDist = 100;
  for (let n = 1; n <= 49; n++) {
    const name = NUM_TO_NAME[n];
    if (name === targetNote) {
      const dist = Math.abs(n - targetNumber);
      if (dist < bestDist) {
        bestDist = dist;
        bestNum = n;
      }
    }
  }
  return bestNum;
}
function addMelodyBlock() {
  const beats = meterToBeats(state.meter || '4/4');
  const cols = beats * 4;
  const blockIdx = state.melodyBlocks.length;
  const div = document.createElement('div');
  div.className = 'melody-block';
  const caption = document.createElement('div');
  caption.className = 'melody-caption';
  caption.textContent = `Bloco #${blockIdx + 1} ‚Äî ${beats}/4 (${cols} colunas)`;
  div.appendChild(caption);
  const table = document.createElement('table');
  table.className = 'melody-table';
  const tr = document.createElement('tr');
  tr.innerHTML = '<th>Notas</th>' + Array(cols).fill().map((_, i) => `<th>${i+1}</th>`).join('');
  table.appendChild(tr);
  const inputRow = document.createElement('tr');
  const tdLabel = document.createElement('td');
  tdLabel.innerHTML = `<span class="line-label">Notas (1-49) ou "x"</span>`;
  inputRow.appendChild(tdLabel);
  for (let c = 0; c < cols; c++) {
    const td = document.createElement('td');
    const input = document.createElement('input');
    input.type = 'text';
    input.placeholder = '1‚Äì49/x';
    input.dataset.block = String(blockIdx);
    input.dataset.col = String(c);
    td.appendChild(input);
    inputRow.appendChild(td);
    // Adiciona o evento de foco apenas se for um dispositivo m√≥vel
    if (isMobileDevice()) {
      input.addEventListener('focus', (e) => {
        state.activeInput = e.target;
        showNumberPicker();
      });
      // Evento de duplo clique para limpar o campo (j√° estava aqui, mantido)
      input.addEventListener('dblclick', (e) => { e.target.value = ''; });
    }
  }
  table.appendChild(inputRow);
  div.appendChild(table);
  ui.melodyBlocks.appendChild(div);
  state.melodyBlocks.push(div);
}
function clearMelodyBlocks() {
  state.melodyBlocks = [];
  ui.melodyBlocks.innerHTML = '';
}
ui.btnMelodyAdd.addEventListener('click', addMelodyBlock);
ui.btnMelodyClear.addEventListener('click', clearMelodyBlocks);
// --- FUN√á√ïES DO PICKER DE N√öMEROS PARA MOBILE ---
function initializeNumberPicker() {
  // Cria os bot√µes de 1 a 49
  for (let i = 1; i <= 49; i++) {
    const btn = document.createElement('button');
    btn.className = 'number-btn';
    btn.textContent = i;
    btn.dataset.number = i;
    btn.addEventListener('click', handleNumberSelection);
    ui.numberGrid.appendChild(btn);
  }
  // Cria o bot√£o de fechar
  const closeBtn = document.createElement('button');
  closeBtn.className = 'number-btn close-btn';
  closeBtn.textContent = 'Fechar';
  closeBtn.addEventListener('click', hideNumberPicker);
  ui.numberGrid.appendChild(closeBtn);
}
function showNumberPicker() {
  if (!isMobileDevice()) return;
  ui.numberPicker.style.display = 'grid'; // Alterado de 'block' para 'grid' para melhor controle do layout
}
function hideNumberPicker() {
  ui.numberPicker.style.display = 'none';
}
function handleNumberSelection(e) {
  const number = e.target.dataset.number;
  if (state.activeInput) {
    state.activeInput.value = number;
    // Dispara o evento 'input' ou 'change' para garantir que o valor seja processado
    state.activeInput.dispatchEvent(new Event('input', { bubbles: true }));
    state.activeInput.dispatchEvent(new Event('change', { bubbles: true }));
    // Remove o foco
    state.activeInput.blur();
    state.activeInput = null;
  }
  hideNumberPicker(); // Fecha o picker automaticamente ap√≥s a sele√ß√£o
}
function buildMelodyPlanFromBlocks() {
  const plan = [];
  const stepsPerBar = meterToBeats(state.meter) * 4;
  for (const block of state.melodyBlocks) {
    const inputs = block.querySelectorAll('input');
    inputs.forEach((input, step) => {
      const value = input.value.trim();
      if (value === '') {
        plan.push(null);
      } else if (value.toLowerCase() === 'x') {
        plan.push({ type: 'mute' });
      } else {
        const num = parseInt(value, 10);
        if (!isNaN(num) && num >= 1 && num <= 49) {
          // üîë Armazena APENAS o n√∫mero original.
          // A adapta√ß√£o ser√° feita em tempo real em `scheduleStep`.
          plan.push({
            type: 'start',
            originalNumber: num,
            adaptedNumber: null, // Ser√° calculado dinamicamente
            instrument: ui.melodyInstrument.value
          });
        }
      }
    });
  }
  state.melodyPlan = plan;
}
// --- NOVO: MAPA DE INSTRUMENTOS DE MELODIA ---
const MELODY_INSTRUMENTS = {
  dist: "guitarraDistorcao/Melodia",
  piano: "assets/PianoString",
  baixo: "assets/BaixoMelodia",
  sax: "assets/SaxMelodia",
  acordeon: "assets/AcordeonMelodia",
  sinos: "assets/SinosMelodia",
  violao_aco: "assets/ViolaoAcoMelodia",
  violao_nylon: "assets/ViolaoNylonMelodia",
  cordas: "assets/Cordas"
};
// --- ATUALIZADO: Garante que os samples de melodia necess√°rios estejam carregados ---
async function ensureMelodySamplesNeeded() {
  const instrument = ui.melodyInstrument.value;
  const folder = MELODY_INSTRUMENTS[instrument];
  if (!folder) return;
  const promises = [];
  for (let i = 1; i <= 49; i++) {
    const noteName = NUM_TO_NAME[i]; // ‚úÖ Obt√©m o nome da nota (ex: 'E', 'F', 'FS')
    const url = `${folder}/${i}${noteName}.mp3`; // ‚úÖ Constr√≥i o nome correto do arquivo
    if (!state.buffers.melody[url]) {
      promises.push(
        loadBuffer(url).then(buf => { if (buf) state.buffers.melody[url] = buf; })
      );
    }
  }
  await Promise.all(promises);
}
// --- ATUALIZADO: Toca uma nota de melodia ---
function playMelodyNumber(time, number, instrumentType) {
  const folder = MELODY_INSTRUMENTS[instrumentType];
  if (!folder) {
    console.warn(`[Melodia] Instrumento desconhecido: ${instrumentType}`);
    return;
  }
  // ‚úÖ CORRE√á√ÉO: Usa o nome da nota real (ex: "1E", "2F", "3FS") em vez de apenas o n√∫mero
  const noteName = NUM_TO_NAME[number]; // Ex: 'E', 'F', 'FS', etc.
  const url = `${folder}/${number}${noteName}.mp3`; // ‚úÖ Agora o nome do arquivo ser√° "1E.mp3", "2F.mp3", etc.
  const buf = state.buffers.melody[url];
  if (!buf) {
    console.warn(`[Melodia] Arquivo n√£o carregado: ${url}`);
    return;
  }
  if (state.lastMelodySource && !state.lastMelodySource.finished) {
    state.lastMelodySource.stop(time);
  }
  const src = audio.ctx.createBufferSource();
  const g = audio.ctx.createGain();
  src.buffer = buf;
  src.connect(g);
  // --- NOVO: Conecta ao ganho da melodia ---
  if (!audio.melodyGain) {
    // Cria o n√≥ de ganho da melodia se ele n√£o existir
    audio.melodyGain = audio.ctx.createGain();
    audio.melodyGain.gain.value = 0.50; // Valor inicial
    audio.melodyGain.connect(audio.master); // Conecta ao mix principal
  }
  g.connect(audio.melodyGain);
  g.gain.setValueAtTime(0.0, time);
  g.gain.linearRampToValueAtTime(1.0, time + 0.01);
  const maxDur = state.sixteenthDur * 16;
  src.start(time);
  src.stop(time + Math.min(buf.duration, maxDur));
  state.lastMelodySource = src;
  state.lastMelodyGain = g;
  src.finished = false;
  src.onended = () => { src.finished = true; };
}
// Inicializa o picker de n√∫meros se for mobile
if (isMobileDevice()) {
  initializeNumberPicker();
}
// --- NOVA FUN√á√ÉO: Para a nota de melodia atual ---
function stopMelodyAt(time) {
  if (state.lastMelodySource && !state.lastMelodySource.finished) {
    state.lastMelodySource.stop(time);
    state.lastMelodySource = null;
  }
  if (state.lastMelodyGain) {
    state.lastMelodyGain.gain.cancelScheduledValues(time);
    state.lastMelodyGain.gain.setValueAtTime(state.lastMelodyGain.gain.value, time);
    state.lastMelodyGain.gain.linearRampToValueAtTime(0.0, time + 0.05);
  }
}
// --- NOVAS VARI√ÅVEIS E FUN√á√ïES PARA GRAVA√á√ÉO ---
let isRecording = false;
let recordedChunks = [];

// Fun√ß√£o para iniciar a grava√ß√£o da mixagem principal
// Fun√ß√£o para iniciar a grava√ß√£o da mixagem principal (VERS√ÉO PARA 4 MINUTOS)
async function startRecording() {
  if (!audio.ctx) {
    console.error('Contexto de √°udio n√£o inicializado.');
    isRecording = false;
    return;
  }

  if (!audio.mix) {
    console.error('N√≥ de mixagem n√£o encontrado.');
    isRecording = false;
    return;
  }

  // Cria um stream a partir do n√≥ de mixagem
  const streamDestination = audio.ctx.createMediaStreamDestination();
  audio.mix.connect(streamDestination);

  const stream = streamDestination.stream;

  if (!stream || stream.getAudioTracks().length === 0) {
    console.error('Nenhum track de √°udio dispon√≠vel para grava√ß√£o.');
    isRecording = false;
    return;
  }

  // Configura o MediaRecorder
  mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
  recordedChunks = [];

  mediaRecorder.ondataavailable = function(event) {
    if (event.data && event.data.size > 0) {
      recordedChunks.push(event.data);
    }
  };

  mediaRecorder.onstop = async function() {
    if (recordedChunks.length === 0) {
      alert('A grava√ß√£o n√£o capturou nenhum √°udio.');
      return;
    }
    const blob = new Blob(recordedChunks, { type: 'audio/webm' });
    try {
      const mp3Blob = await webmToMP3(blob);
      downloadBlob(mp3Blob, 'jam_on_4min_loop.mp3');
    } catch (err) {
      console.error('Erro ao converter para MP3:', err);
      alert('Erro ao salvar o arquivo MP3: ' + err.message);
    }
  };

  mediaRecorder.onerror = function(event) {
    console.error('Erro no MediaRecorder:', event.error);
    isRecording = false;
    alert('Erro durante a grava√ß√£o: ' + event.error.message);
  };

  mediaRecorder.start();
  console.log('‚úÖ Grava√ß√£o de 4 minutos iniciada.');

  // --- NOVO: Para a grava√ß√£o ap√≥s exatamente 4 minutos (240.000 milissegundos) ---
  setTimeout(() => {
    if (isRecording && mediaRecorder && mediaRecorder.state !== 'inactive') {
      console.log('‚úÖ Grava√ß√£o de 4 minutos finalizada.');
      mediaRecorder.stop();
      isRecording = false;
      
      // Para a reprodu√ß√£o automaticamente ap√≥s a grava√ß√£o
      if (state.running) {
        onStop();
      }
    }
  }, 240000); // 4 minutos = 240.000 ms
}

// Fun√ß√£o para converter Blob WebM para MP3 (VERS√ÉO CORRIGIDA)
// Fun√ß√£o para converter Blob WebM para MP3 (VERS√ÉO FINAL E ROBUSTA)
// Fun√ß√£o para converter Blob WebM para MP3 (VERS√ÉO FINAL E ROBUSTA)
async function webmToMP3(webmBlob) {
  return new Promise((resolve, reject) => {
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const reader = new FileReader();

    reader.onload = function() {
      audioCtx.decodeAudioData(reader.result)
        .then(buffer => {
          // --- VERIFICA√á√ÉO 1: Buffer existe e tem canais? ---
          if (!buffer || buffer.numberOfChannels === 0 || buffer.length === 0) {
            reject(new Error('√Åudio decodificado √© inv√°lido ou vazio.'));
            return;
          }

          // --- VERIFICA√á√ÉO 2: Os dados dos canais s√£o v√°lidos? ---
          let hasValidAudio = false;
          for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
            const channelData = buffer.getChannelData(channel);
            // Verifica se channelData √© um Float32Array v√°lido
            if (!(channelData instanceof Float32Array) || channelData.length === 0) {
              continue;
            }
            // Verifica se h√° pelo menos um valor de √°udio n√£o-zero
            for (let i = 0; i < Math.min(channelData.length, 1000); i++) { // Verifica os primeiros 1000 samples
              if (Math.abs(channelData[i]) > 0.00001) {
                hasValidAudio = true;
                break;
              }
            }
            if (hasValidAudio) break;
          }

          if (!hasValidAudio) {
            reject(new Error('O √°udio gravado est√° completamente silencioso. Verifique os volumes e tente novamente.'));
            return;
          }

          // --- CODIFICA√á√ÉO PARA MP3 ---
          const mp3encoder = new lamejs.Mp3Encoder(buffer.numberOfChannels, buffer.sampleRate, 128);
          const mp3Data = [];
          const sampleBlockSize = 1152;

          for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
            const channelData = buffer.getChannelData(channel);
            if (!(channelData instanceof Float32Array) || channelData.length === 0) {
              continue;
            }
            for (let i = 0; i < channelData.length; i += sampleBlockSize) {
              const sampleChunk = channelData.subarray(i, i + sampleBlockSize);
              const mp3buf = mp3encoder.encodeBuffer(sampleChunk);
              if (mp3buf.length > 0) {
                mp3Data.push(mp3buf);
              }
            }
          }

          const mp3buf = mp3encoder.flush();
          if (mp3buf.length > 0) {
            mp3Data.push(mp3buf);
          }

          if (mp3Data.length === 0) {
            reject(new Error('Falha ao gerar dados MP3.'));
            return;
          }

          const mp3Blob = new Blob(mp3Data, { type: 'audio/mp3' });
          resolve(mp3Blob);
        })
        .catch(err => {
          console.error('Erro ao decodificar √°udio:', err);
          reject(new Error('Falha ao processar o √°udio gravado. Tente novamente.'));
        });
    };

    reader.onerror = (err) => {
      console.error('Erro ao ler Blob:', err);
      reject(new Error('Falha ao ler o √°udio gravado.'));
    };

    reader.readAsArrayBuffer(webmBlob);
  });
}


// Evento atualizado para o bot√£o "Salvar como MP3" (4 MINUTOS)
ui.btnSaveWAV.addEventListener('click', async () => {
  if (!audio.ctx) await initAudio();
  // Cria destino de grava√ß√£o
  const dest = audio.ctx.createMediaStreamDestination();
  // Conecta o destino ao mix principal para capturar todo o √°udio
  audio.master.connect(dest);
  // Usa um formato suportado
  const mimeType = 'audio/webm;codecs=opus';
  mediaRecorder = new MediaRecorder(dest.stream, { mimeType });
  recordedChunks = []; // <-- CORRE√á√ÉO: Removeu 'let', apenas zera o array global.
  mediaRecorder.ondataavailable = e => {
    if (e.data.size > 0) recordedChunks.push(e.data);
  };

      mediaRecorder.onstop = async () => {
    const webmBlob = new Blob(recordedChunks, { type: mimeType });
    try {
      // Converte o Blob WebM para um ArrayBuffer
      const arrayBuffer = await webmBlob.arrayBuffer();
      // Decodifica o √°udio
      const audioBuffer = await audio.ctx.decodeAudioData(arrayBuffer);
      // Converte o AudioBuffer para WAV
      const wavBlob = audioBufferToWav(audioBuffer);
      // Faz o download usando a fun√ß√£o helper
      downloadBlob(wavBlob, 'jam-on.wav');
      console.log("‚úÖ Arquivo WAV salvo com sucesso.");
    } catch (err) {
      console.error('Erro ao processar o √°udio:', err);
      alert('Erro ao salvar o arquivo WAV: ' + err.message);
    }
  };

  mediaRecorder.onerror = (e) => {
    console.error('Erro no MediaRecorder:', e);
    alert('Erro ao iniciar a grava√ß√£o.');
  };

  mediaRecorder.start();
  console.log("üéôÔ∏è Grava√ß√£o para WAV iniciada...");

  // Define a dura√ß√£o da grava√ß√£o (por exemplo, 2 minutos)
  setTimeout(() => {
    if (mediaRecorder && mediaRecorder.state === "recording") {
      mediaRecorder.stop();
      console.log("‚èπÔ∏è Grava√ß√£o finalizada.");
    }
  }, 2 * 60 * 1000); // 2 minutos
});

// Fun√ß√£o para converter AudioBuffer para Blob WAV
function audioBufferToWav(buffer) {
  const numOfChan = buffer.numberOfChannels;
  const length = buffer.length * numOfChan * 2 + 44;
  const arrayBuffer = new ArrayBuffer(length);
  const view = new DataView(arrayBuffer);
  const channels = [];
  let i, sample, offset = 0;

  // String 'RIFF'
  writeString(view, 0, 'RIFF');
  // comprimento do arquivo - 8
  view.setUint32(4, length - 8, true);
  // String 'WAVE'
  writeString(view, 8, 'WAVE');
  // String 'fmt '
  writeString(view, 12, 'fmt ');
  // comprimento do bloco fmt
  view.setUint32(16, 16, true);
  // formato de √°udio (1 para PCM)
  view.setUint16(20, 1, true);
  // n√∫mero de canais
  view.setUint16(22, numOfChan, true);
  // taxa de amostragem
  view.setUint32(24, buffer.sampleRate, true);
  // byteRate (taxa de amostragem * blocos por amostra * canais)
  view.setUint32(28, buffer.sampleRate * 2 * numOfChan, true);
  // blocos por amostra (bits por amostra / 8)
  view.setUint16(32, 2 * numOfChan, true);
  // bits por amostra
  view.setUint16(34, 16, true);
  // String 'data'
  writeString(view, 36, 'data');
  // comprimento dos dados
  view.setUint32(40, length - 44, true);

  // coleta os dados dos canais
  for (i = 0; i < buffer.numberOfChannels; i++) {
    channels.push(buffer.getChannelData(i));
  }

  offset = 44;
  // escreve os dados PCM
  for (i = 0; i < buffer.length; i++) {
    for (let channel = 0; channel < numOfChan; channel++) {
      sample = Math.max(-1, Math.min(1, channels[channel][i]));
      sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF);
      view.setInt16(offset, sample, true);
      offset += 2;
    }
  }

  return new Blob([view], { type: 'audio/wav' });
}

function writeString(view, offset, string) {
  for (let i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}
// Fun√ß√£o para fazer o download de qualquer Blob
function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.style.display = 'none';
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 100);
}

// --- FOR√áA A HABILITA√á√ÉO DOS BOT√ïES ---
window.addEventListener('load', () => {
  console.log("üîß P√°gina carregada. Verificando bot√µes...");
  const buttons = document.querySelectorAll('button');
  buttons.forEach(btn => {
    btn.disabled = false;
    btn.style.opacity = '1';
    console.log(`‚úÖ Bot√£o '${btn.textContent.trim()}' habilitado.`);
  });
});
  </script>
</body>
</html>
