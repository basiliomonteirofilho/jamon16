<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jam on ‚Äì Playback Aleat√≥rio</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121822;
      --accent: #5eead4;
      --muted: #7a89a6;
      --text: #e6edf6;
      --danger: #f87171;
      --ok: #86efac;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; background: var(--bg); color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      min-height: 100vh; display: grid; place-items: center;
    }
    .wrap { width: min(1100px, 92vw); }
    header { display:flex; align-items:center; justify-content:space-between; gap:1rem; margin: 2rem 0 1.25rem; }
    h1 { font-size: clamp(1.4rem, 2.2vw, 2rem); margin: 0; letter-spacing: .3px; }
    
    .chord-display {
      grid-column: span 12;
      text-align: center;
      margin: 1rem 0;
    }
    .chord-name {
      font-size: 4rem;
      font-weight: bold;
      color: var(--accent);
      margin: 0;
    }
    .chord-timer {
      font-size: 1.5rem;
      color: var(--ok);
    }

    .card { background: linear-gradient(180deg, #121822, #0d131c); border: 1px solid #1e293b; border-radius: 18px; padding: 1rem; box-shadow: 0 10px 40px rgba(0,0,0,.25); }
    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 12px; }
    .controls { grid-column: span 12; display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .controls button, .controls select, .controls input[type="number"] {
      background: #0f172a; color: var(--text); border: 1px solid #1f2937; border-radius: 12px; padding: .65rem .9rem; font-size: .95rem; outline: none;
    }
    .controls button { cursor: pointer; border-color:#334155; transition: transform .06s ease, background .2s ease, border-color .2s ease; }
    .controls button:hover { transform: translateY(-1px); }
    .controls button.primary { background: #0b3b39; border-color:#134e4a; }
    .controls button.primary[data-state="on"] { background:#065f46; border-color:#0f766e; }
    .controls button.danger { background:#3b0b0b; border-color:#7f1d1d; }
    
    .pill { background:#0b1320; border:1px solid #1f2a44; padding:.4rem .6rem; border-radius:999px; font-size:.85rem; color: var(--muted); }
    .split { grid-column: span 12; display:grid; grid-template-columns: repeat(12, 1fr); gap:12px; }
    .panel { grid-column: span 6; background:#0b0f16; border:1px solid #1b2538; border-radius:12px; padding:12px; }
    .panel h3 { margin:0 0 8px; font-size:1rem; color:#a6b4cf; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:.92rem; }
    .log { grid-column: span 12; background:#080c12; border:1px dashed #1b283b; border-radius:12px; padding:10px; height: 170px; overflow:auto; white-space: pre-wrap; font-size:.9rem; color:#cbd5e1; }
    .footer { margin: .75rem 0 0; color: var(--muted); font-size:.85rem; }
    .badge { display:inline-block; padding:.15rem .45rem; border-radius:6px; border:1px solid #294256; background:#0b1826; color:#9bd5f0; font-size:.8rem; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .spacer { flex: 1 1 auto; }
    .muted { opacity: 0.5; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Jam on ‚Äì Playback Aleat√≥rio (baixo + bateria + guitarra)</h1>
      <div class="pill">Cada pulso do BPM = sem√≠nima</div>
    </header>

    <!-- Visor de acorde -->
    <div class="chord-display">
      <h2 class="chord-name" id="currentChord">‚Äî</h2>
      <div class="chord-timer" id="chordTimer">‚Äî</div>
    </div>

    <section class="card">
      <div class="grid">
        <div class="controls">
          <button id="btnRestart">‚èÆÔ∏è Reiniciar</button>
          <button id="btnPrev">‚è™ Anterior</button>
          <button id="btnPlay" class="primary">‚ñ∂Ô∏è Play</button>
          <button id="btnPause">‚è∏Ô∏è Pause</button>
          <button id="btnStop" class="danger">‚èπÔ∏è Stop</button>
          <button id="btnSave" class="primary">üíæ Salvar 4 min (MP3)</button>

          <!-- Bot√µes de mute -->
          <span class="spacer"></span>
          <button id="muteBass" data-mute="off">üé∏ Baixo</button>
          <button id="muteDrums" data-mute="off">ü•Å Bateria</button>
          <button id="muteClean" data-mute="off">üé∏ Limpa</button>
          <button id="muteDist" data-mute="off">üî• Distor√ß√£o</button>

          <label class="row">BPM <input id="bpm" type="number" min="40" max="220" value="100" style="width:90px"></label>
          <label class="row">Assinatura
            <select id="meter">
              <option value="auto" selected>aleat√≥ria</option>
              <option>2/4</option>
              <option>3/4</option>
              <option>4/4</option>
              <option>5/4</option>
              <option>6/4</option>
              <option>7/4</option>
            </select>
          </label>
        </div>

        <div class="split">
          <div class="panel" style="grid-column: span 6;">
            <h3>Estado atual</h3>
            <div class="mono" id="state"></div>
            <div class="footer">Ao clicar em <b>Play</b>, gera um novo playback aleat√≥rio.</div>
          </div>
          <div class="panel" style="grid-column: span 6;">
            <h3>Arquivos esperados</h3>
            <div class="mono">
              <div>Coloque os √°udios nas pastas:</div>
              <ul>
                <li><b>guitarraLimpa/[nota]/acorde.mp3</b> (ex: <code>guitarraLimpa/A/A.mp3</code>, <code>guitarraLimpa/A/Am.mp3</code>)</li>
                <li><b>guitarraDistorcao/[nota]/acorde.mp3</b> (ex: <code>guitarraDistorcao/AS/AS7.mp3</code>, <code>guitarraDistorcao/C/C.mp3</code>)</li>
                <li>Pe√ßas de bateria: <b>bumbo.mp3</b>, <b>caixa.mp3</b>, etc.</li>
                <li>Baixo: <b>bass-A.mp3</b>, <b>bass-AS.mp3</b>, etc.</li>
              </ul>
            </div>
          </div>
          <div class="log mono" id="log"></div>
        </div>
      </div>
    </section>
  </div>

  <!-- ‚úÖ CORRIGIDO: <<script ‚Üí <script -->
  <script>
    // =============================
    // Jam on ‚Äì Playback Personalizado
    // =============================
    const ui = {
      play: document.getElementById('btnPlay'),
      pause: document.getElementById('btnPause'),
      stop: document.getElementById('btnStop'),
      save: document.getElementById('btnSave'),
      muteBass: document.getElementById('muteBass'),
      muteDrums: document.getElementById('muteDrums'),
      muteClean: document.getElementById('muteClean'),
      muteDist: document.getElementById('muteDist'),
      bpm: document.getElementById('bpm'),
      meter: document.getElementById('meter'),
      log: document.getElementById('log'),
      state: document.getElementById('state'),
      currentChord: document.getElementById('currentChord'),
      chordTimer: document.getElementById('chordTimer'),
      btnRestart: document.getElementById('btnRestart'),
      btnPrev: document.getElementById('btnPrev'),
    };

    const audio = {
      ctx: null,
      master: null,
      mix: null,
      drumGain: null,
      bassGain: null,
      cleanGain: null,
      distGain: null,
      schedulerTimer: null,
      lookahead: 0.1,
      scheduleHorizon: 0.25,
    };

    const PITCHES = ['A','AS','B','C','CS','D','DS','E','F','FS','G','GS'];

    const PITCH_TO_NAME = {
      'A': 'A',   'AS': 'A#',
      'B': 'B',
      'C': 'C',   'CS': 'C#',
      'D': 'D',   'DS': 'D#',
      'E': 'E',
      'F': 'F',   'FS': 'F#',
      'G': 'G',   'GS': 'G#'
    };

    const NAME_TO_PITCH = {
      'A': 'A',   'A#': 'AS',
      'B': 'B',
      'C': 'C',   'C#': 'CS',
      'D': 'D',   'D#': 'DS',
      'E': 'E',
      'F': 'F',   'F#': 'FS',
      'G': 'G',   'G#': 'GS'
    };

    // Mapeamento de graus para √≠ndices
    const DEGREE_TO_ROOT = {
      1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11
    };

    const DRUMS = {
  bumbo: 'assets/bumbo.mp3',
  caixa: 'assets/caixa.mp3',
  chimbal: 'assets/chimbal.mp3',
  conducao: 'assets/conducao.mp3',
  ataque: 'assets/ataque.mp3',
  
  // Combina√ß√µes
  ba: 'assets/bumbo-ataque.mp3',       // bumbo + ataque
  bch: 'assets/bumbo-chimbal.mp3',     // bumbo + chimbal
  cch: 'assets/caixa-chimbal.mp3',     // caixa + chimbal
  bc: 'assets/bumbo-conducao.mp3',     // bumbo + condu√ß√£o
  cc: 'assets/caixa-conducao.mp3'      // caixa + condu√ß√£o
};

    const BASS_SAMPLES = (() => {
      const octaves = ['', '8', '16'];
      const table = {};

      for (const p of PITCHES) {
        const letter = p[0]; // A, B, C, D, E, F, G
        const isSharp = p.includes('S');

        for (const o of octaves) {
          const key = p + o; // ex: FS, FS8, FS16
          let fileName;
          if (o === '') {
            fileName = `bass-${p}.mp3`; // bass-FS.mp3
          } else {
            fileName = `bass-${letter}${o}${isSharp ? 'S' : ''}.mp3`; // bass-F16S.mp3
          }
          table[key] = `assets/${fileName}`;
        }
      }

      table['X'] = 'assets/bass-muted.mp3';
      return table;
    })();

    const PROGRESSIONS = [
      [1, 1, 1, 1, 4, 4, 5, 5, 6, 6],
      [1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5],
      [1, 1, 7, 6, 5, 4, 3, 2, 1, 1, 4, 1],
      [1, 1, 1, 1, 5, 5, 5, 5, 6, 6, 6, 4, 4, 5, 5, 1, 1],
      [1, 1, 1, 1, 4, 4, 5, 5],
      [1, 1, 1, 3, 4, 5, 7, 4],
      [6, 4, 1, 1, 1, 5, 5, 4, 4, 5, 5],
      [1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 4, 4, 4, 4, 1, 1, 1, 1],
      [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 1, 1, 1],
      [4, 4, 4, 4, 5, 5, 6, 6, 1, 1, 1, 1, 3, 4],
      [1, 1, 1, 1, 2, 2, 4, 4, 5, 5],
      [1, 1, 1, 3, 4, 1, 1, 1, 3, 4, 5, 4, 5, 1, 1, 1, 1],
      [4, 4, 4, 4, 5, 5, 5, 5, 3, 3, 3, 3, 6, 6, 2, 5, 1, 5, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 5, 5, 1, 1, 1, 1, 4, 4, 5, 5, 1, 1, 1, 1]
    ];

    const CUSTOM_GROOVES = [
      {
        name: "pop rock 1",
        meter: "4/4",
        drumPattern: [
          "ba - - - ch - - - cch - - - ch - bch - "
        ],
        bassRhythm: [
          "S - - - S - - - S ¬∞ S ¬∞ S ¬∞ S ¬∞"
        ]
      }
    ];

    // Armazenar o √∫ltimo estado para "voltar"
    const lastState = {
      chordProgression: [],
      key: null,
      quality: null,
      currentGroove: null,
      meter: null
    };

    const state = {
      running: false,
      paused: false,
      nextNoteTime: 0,
      meter: '4/4',
      bpm: 100,
      sixteenthDur: 0.15,
      stepIndex: 0,
      pattern: [],
      buffers: { drums: {}, bass: {}, guitar: {} },
      lastBassSrc: null,
      bassPlan: [],
      signatureTag: '',
      key: null,
      keyIdx: 0,
      quality: 'maj',
      chordProgression: [],
      chordDurations: [],
      currentGroove: null,
      currentChordIndex: 0,
      barsInChord: 0,
      bassMode: 'arpejo',
      bassCycleCount: 0,
      recordingTimer: null
    };

    const mute = { bass: false, drums: false, clean: false, dist: false };

    // Fun√ß√£o principal de agendamento
    function scheduler() {
      const now = audio.ctx.currentTime;
      while (state.nextNoteTime < now + audio.scheduleHorizon) {
        scheduleStep(state.nextNoteTime, state.stepIndex);
        state.nextNoteTime += state.sixteenthDur;
        state.stepIndex++;
      }
    }

    // Controle do scheduler
    function startScheduler() {
      stopScheduler();
      audio.schedulerTimer = setInterval(scheduler, audio.lookahead * 1000);
    }

    function stopScheduler() {
      if (audio.schedulerTimer) {
        clearInterval(audio.schedulerTimer);
        audio.schedulerTimer = null;
      }
    }

    function log(msg){ ui.log.textContent += `\n${msg}`; ui.log.scrollTop = ui.log.scrollHeight; }

    function setStatePanel(){
      ui.state.innerHTML = `
        <div>Estilo: <b>${state.signatureTag}</b></div>
        <div>Compasso: <b>${state.meter}</b></div>
        <div>BPM: <b>${state.bpm}</b> (semicolcheia = ${(state.sixteenthDur * 1000).toFixed(0)} ms)</div>
        <div>Tom: <b>${state.key} ${state.quality}</b></div>
        <div>Progress√£o: <b>${state.chordProgression.join('-')}</b></div>
      `;
    }

    async function loadBuffer(url) {
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        const arrayBuffer = await res.arrayBuffer();
        const audioBuffer = await audio.ctx.decodeAudioData(arrayBuffer);
        return audioBuffer;
      } catch (e) {
        log(`[ERRO] Falha ao carregar: ${url} ‚Üí ${e.message}`);
        return null;
      }
    }

    async function ensureSamples() {
  const allDrums = [
    'bumbo', 'caixa', 'chimbal', 'conducao', 'ataque',
    'ba', 'bch', 'cch', 'bc', 'cc'
  ];
  const promises = [];

  // Carrega todas as pe√ßas de bateria
  for (const k of allDrums) {
    if (!state.buffers.drums[k] && DRUMS[k]) {
      promises.push(
        loadBuffer(DRUMS[k]).then(buf => {
          if (buf) {
            state.buffers.drums[k] = buf;
            log(`[DRUM] ‚úîÔ∏è Carregado: ${k}`);
          }
        })
      );
    }
  }

  // Carrega amostras de baixo
  for (const [k, url] of Object.entries(BASS_SAMPLES)) {
    if (!state.buffers.bass[k]) {
      promises.push(
        loadBuffer(url).then(buf => {
          if (buf) state.buffers.bass[k] = buf;
        })
      );
    }
  }

  await Promise.all(promises);
}

    function initAudio(){
      if (audio.ctx) return;
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      audio.ctx = ctx;
      audio.master = ctx.createGain();
      audio.master.gain.value = 0.9;

      audio.drumGain = ctx.createGain();
      audio.drumGain.gain.value = 0.85;

      audio.bassGain = ctx.createGain();
      audio.bassGain.gain.value = 0.9;

      audio.cleanGain = ctx.createGain();
      audio.cleanGain.gain.value = 0.8;

      audio.distGain = ctx.createGain();
      audio.distGain.gain.value = 0.8;

      audio.mix = ctx.createMediaStreamDestination();

      audio.drumGain.connect(audio.master);
      audio.bassGain.connect(audio.master);
      audio.cleanGain.connect(audio.master);
      audio.distGain.connect(audio.master);
      audio.master.connect(audio.mix);
      audio.master.connect(ctx.destination);
    }

    function randItem(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
    function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }

    function meterToBeats(meter) {
      const [num, den] = meter.split('/').map(Number);
      return [num, den];
    }

    function playClick(isStrong) {
      const ctx = audio.ctx;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain); gain.connect(audio.drumGain);
      osc.frequency.setValueAtTime(isStrong ? 880 : 440, ctx.currentTime);
      gain.gain.setValueAtTime(0.3, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);
      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.08);
    }

    function selectRandomGroove() {
      return randItem(CUSTOM_GROOVES);
    }

    async function playChord(time, note, type, isDistorted) {
      const folder = isDistorted ? 'guitarraDistorcao' : 'guitarraLimpa';
      const rootFolder = note;
      const chordFileName = note + type;
      const key = `${folder}_${chordFileName}`;
      const url = `${folder}/${rootFolder}/${chordFileName}.mp3`;

      if (state.buffers.guitar[key]) {
        const src = audio.ctx.createBufferSource();
        const gainNode = isDistorted ? audio.distGain : audio.cleanGain;
        src.buffer = state.buffers.guitar[key];
        src.connect(gainNode);
        src.start(time);
        return;
      }

      log(`[CHORD] Carregando: ${url}`);
      try {
        const buf = await loadBuffer(url);
        if (!buf) throw new Error('Falha ao decodificar');
        state.buffers.guitar[key] = buf;
        const src = audio.ctx.createBufferSource();
        src.buffer = buf;
        src.connect(isDistorted ? audio.distGain : audio.cleanGain);
        src.start(time);
      } catch (e) {
        log(`[ERRO] Falha ao carregar acorde: ${url}`);
      }
    }

    function getCurrentChord() {
      const chordNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const degree = state.chordProgression[state.currentChordIndex];
      const quality = state.quality;

      const rootOffset = DEGREE_TO_ROOT[degree] || 0;
      const noteIndex = (state.keyIdx + rootOffset) % 12;
      const noteSharp = chordNames[noteIndex];
      const noteWithS = noteSharp.replace('#', 'S');

      const chordTypes = {
        'maj': ['', '7'],
        'min': ['m', 'm7']
      };
      const chordType = randItem(chordTypes[quality]);
      const fileName = noteWithS + chordType;

      return {
        note: noteWithS,
        type: chordType,
        displayName: noteSharp + chordType,
        fileName: fileName
      };
    }

    async function preloadCommonChords() {
      const commonTypes = ['', '7', 'm', 'm7'];
      const folders = ['guitarraLimpa', 'guitarraDistorcao'];
      const notes = ['A', 'AS', 'B', 'C', 'CS', 'D', 'DS', 'E', 'F', 'FS', 'G', 'GS'];

      const promises = [];
      for (const folder of folders) {
        for (const note of notes) {
          for (const type of commonTypes) {
            const chordName = note + type;
            const key = `${folder}_${chordName}`;
            const url = `${folder}/${note}/${chordName}.mp3`;

            if (!state.buffers.guitar[key]) {
              promises.push(
                loadBuffer(url).then(buf => {
                  if (buf) {
                    state.buffers.guitar[key] = buf;
                    log(`[PRELOAD] ‚úîÔ∏è ${chordName}.mp3`);
                  }
                })
              );
            }
          }
        }
      }
      await Promise.all(promises);
      log('[PRELOAD] Pr√©-carregamento conclu√≠do.');
    }

    function buildBassPlan() {
  const groove = state.currentGroove;
  state.meter = ui.meter.value === 'auto' ? groove.meter : ui.meter.value;
  const [num, den] = meterToBeats(state.meter);
  const sixteenthsPerBar = num * 4;

  const totalBars = groove.drumPattern.length;
  const totalSteps = totalBars * sixteenthsPerBar;

  state.keyIdx = randInt(0, PITCHES.length - 1);
  state.key = PITCHES[state.keyIdx];
  state.quality = randItem(['maj', 'min']);

  const progression = randItem(PROGRESSIONS);
  state.chordProgression = progression;

  const durations = [];
  let current = progression[0], count = 1;
  for (let i = 1; i < progression.length; i++) {
    if (progression[i] === current) count++;
    else { durations.push(count); current = progression[i]; count = 1; }
  }
  durations.push(count);
  state.chordDurations = durations;
  state.currentChordIndex = 0;
  state.barsInChord = 0;
  state.bassMode = 'tonica'; // Come√ßa com t√¥nica
  state.bassCycleCount = 0;

  // Mapeia cada acorde para suas notas reais (raiz, ter√ßa, quinta)
  const chordMap = progression.map(degree => {
    const rootOffset = DEGREE_TO_ROOT[degree] || 0;
    const rootIdx = (state.keyIdx + rootOffset) % 12;
    return state.quality === 'maj'
      ? [rootIdx, (rootIdx + 4) % 12, (rootIdx + 7) % 12]
      : [rootIdx, (rootIdx + 3) % 12, (rootIdx + 7) % 12];
  });

  // Padr√£o r√≠tmico do baixo
  const rhythmLines = groove.bassRhythm.flatMap(line => line.split('|').map(s => s.trim()).filter(Boolean));
  const rhythmPattern = [];
  for (let i = 0; i < totalBars; i++) {
    const line = rhythmLines[i % rhythmLines.length];
    const parts = line.split(/\s+/).filter(Boolean);
    rhythmPattern.push(...parts);
  }

  const plan = [];
  let barsInChord = 0;
  let chordIndex = 0;

  for (let step = 0; step < totalSteps; step++) {
    const sixteenthInBar = step % sixteenthsPerBar;
    if (sixteenthInBar === 0) {
      barsInChord++;
      if (barsInChord >= state.chordDurations[chordIndex]) {
        chordIndex = (chordIndex + 1) % progression.length;
        barsInChord = 0;

        // Ciclo: 4 de t√¥nica, 1 de arpejo
        if (state.bassCycleCount < 4) {
          state.bassMode = 'tonica';
          state.bassCycleCount++;
        } else {
          state.bassMode = 'arpejo';
          state.bassCycleCount = 0; // Reinicia ap√≥s 5 ciclos
        }
      }
    }

    const chordNotes = chordMap[chordIndex];
    const root = PITCHES[chordNotes[0]];
    const third = PITCHES[chordNotes[1]];
    const fifth = PITCHES[chordNotes[2]];

    const rhythm = rhythmPattern[step % rhythmPattern.length];
    let note = '-';

    if (rhythm === 'S') {
      if (state.bassMode === 'tonica') {
        note = root;
      } else {
        note = randItem([root, third, fifth]);
      }
    } else if (rhythm === 'x') {
      note = 'X';
    } else if (rhythm === '¬∞' || rhythm === '¬∫') {
      note = '-';
    }

    plan.push(note);
  }

  state.bassPlan = plan;
  state.signatureTag = groove.name;
  updateChordDisplay();
}
    function buildDrumPattern() {
      const groove = state.currentGroove;
      const [num, den] = meterToBeats(state.meter);
      const sixteenthsPerBar = num * 4;
      const totalSteps = 16 * sixteenthsPerBar;

      const patternLines = groove.drumPattern.flatMap(line =>
        line.split('|').map(s => s.trim()).filter(Boolean)
      );
      const expandedPattern = [];

      for (let i = 0; i < 16; i++) {
        const line = patternLines[i % patternLines.length];
        const parts = line.split(/\s+/).filter(Boolean);
        expandedPattern.push(...parts);
      }

      const result = [];
      for (let i = 0; i < totalSteps; i++) {
        let cell = expandedPattern[i % expandedPattern.length];
        if (!cell || cell === '-' || cell === '----') {
          result.push('-');
          continue;
        }

        cell = cell
          .replace(/\(bu\s+at\)|\(at\s+bu\)/gi, 'ba')
          .replace(/\(bu\s+ch\)|\(ch\s+bu\)/gi, 'bch')
          .replace(/\(ch\s+ca\)|\(ca\s+ch\)/gi, 'cch')
          .replace(/\(bu\s+co\)|\(co\s+bu\)/gi, 'bc')
          .replace(/\(ca\s+co\)|\(co\s+ca\)/gi, 'cc');

        cell = cell.replace(/\([^)]*\)/g, '').trim();
        if (!cell) {
          result.push('-');
          continue;
        }

        const drumMap = {
  bu: 'bumbo',        // bumbo
  ca: 'caixa',        // caixa
  ch: 'chimbal',      // chimbal
  cha: 'chimbalAberto', 
  co: 'conducao',     // condu√ß√£o
  at: 'ataque',       // ataque
  to1: 'tom1', to2: 'tom2', su: 'surdo',
  ba: 'ba',           // mapeia para 'ba' ‚Üí 'bumbo-ataque.mp3'
  bch: 'bch',         // bumbo + chimbal
  cch: 'cch',         // caixa + chimbal
  bc: 'bc',           // bumbo + condu√ß√£o
  cc: 'cc'            // caixa + condu√ß√£o
};

        const pieces = cell.split(/\s+/).filter(Boolean).map(key => drumMap[key]).filter(Boolean);
        result.push(pieces.length ? pieces.join(',') : '-');
      }
      return result;
    }

    function updateChordDisplay() {
      const chordNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const degree = state.chordProgression[state.currentChordIndex];
      const rootOffset = DEGREE_TO_ROOT[degree] || 0;
      const rootIdx = (state.keyIdx + rootOffset) % 12;
      const rootNote = chordNames[rootIdx];
      const chordType = state.quality === 'maj' ? '' : 'm';
      const currentChord = rootNote + chordType;
      const barsLeft = state.chordDurations[state.currentChordIndex] - state.barsInChord;

      ui.currentChord.textContent = currentChord;
      ui.chordTimer.textContent = `Pr√≥x: ${barsLeft} compasso(s)`;
    }

    async function onPlay() {
      if (state.running) { onStop(); setTimeout(onPlay, 100); return; }
      initAudio();
      await ensureSamples();

      state.currentGroove = selectRandomGroove();

      lastState.chordProgression = [...state.chordProgression];
      lastState.key = state.key;
      lastState.quality = state.quality;
      lastState.currentGroove = state.currentGroove;
      lastState.meter = state.meter;

      buildBassPlan();
      state.pattern = buildDrumPattern();
      state.bpm = Number(ui.bpm.value) || 100;
      state.sixteenthDur = (60 / state.bpm) / 4;
      state.stepIndex = 0;
      state.currentChordIndex = 0;
      state.barsInChord = 0;
      state.bassMode = 'arpejo';
      state.bassCycleCount = 0;

      const [num] = meterToBeats(state.meter);
      const quarterDur = 60 / state.bpm;
      const totalClicks = num * 2;
      const playbackStartTime = audio.ctx.currentTime + 0.1 + totalClicks * quarterDur;
      state.nextNoteTime = playbackStartTime;

      for (let i = 0; i < totalClicks; i++) {
        const isStrong = i % num === 0;
        const clickTime = audio.ctx.currentTime + 0.1 + i * quarterDur;
        setTimeout(() => playClick(isStrong), (clickTime - audio.ctx.currentTime) * 1000);
      }

      setTimeout(() => {
        state.running = true;
        startScheduler();
        ui.play.dataset.state = 'on';
        log(`[PLAY] Estilo: ${state.signatureTag} | ${state.meter} @ ${state.bpm} BPM`);
      }, (playbackStartTime - audio.ctx.currentTime) * 1000);

      setStatePanel();
      updateChordDisplay();
    }

    function onPause() {
      if (state.running && !state.paused) {
        audio.ctx.suspend();
        state.paused = true;
        stopScheduler();
        ui.play.textContent = '‚ñ∂Ô∏è Retomar';
      } else if (state.paused) {
        audio.ctx.resume();
        state.paused = false;
        ui.play.textContent = '‚è∏Ô∏è Pause';
        startScheduler();
      }
    }

    async function onStop() {
      stopScheduler();
      stopRecording();

      if (audio.ctx && audio.ctx.state !== 'closed') {
        try { await audio.ctx.close(); } catch (e) {}
      }
      audio.ctx = null;

      state.running = false;
      state.paused = false;
      state.stepIndex = 0;
      state.pattern = [];
      state.bassPlan = [];
      state.currentGroove = null;

      ui.currentChord.textContent = '‚Äî';
      ui.chordTimer.textContent = '‚Äî';

      ui.play.dataset.state = '';
      ui.play.textContent = '‚ñ∂Ô∏è Play';
      log('[STOP] Pronto.');
    }

    function onRestart() {
  if (!state.running) return;
  onStop();
  setTimeout(() => {
    initAudio();
    ensureSamples();
    state.stepIndex = 0;
    state.nextNoteTime = audio.ctx.currentTime + 0.1;
    state.barsInChord = 0;
    state.currentChordIndex = 0;
    state.bassMode = 'tonica';
    state.bassCycleCount = 0;

    // Recarrega padr√µes
    buildBassPlan();
    state.pattern = buildDrumPattern();

    startScheduler();
    log('[RESTART] Playback reiniciado.');
  }, 100);
}
    function onPrev() {
  if (!lastState.currentGroove) return log('[INFO] Nenhum playback anterior.');

  onStop();
  setTimeout(() => {
    state.currentGroove = lastState.currentGroove;
    state.key = lastState.key;
    state.keyIdx = PITCHES.indexOf(lastState.key);
    state.quality = lastState.quality;
    state.chordProgression = [...lastState.chordProgression];
    state.meter = lastState.meter;
    state.bpm = Number(ui.bpm.value) || 100;

    buildBassPlan();
    state.pattern = buildDrumPattern();
    state.sixteenthDur = (60 / state.bpm) / 4;

    initAudio();
    ensureSamples();

    state.stepIndex = 0;
    state.nextNoteTime = audio.ctx.currentTime + 0.1;
    state.barsInChord = 0;
    state.currentChordIndex = 0;
    state.bassMode = 'tonica';
    state.bassCycleCount = 0;

    startScheduler();
    setStatePanel();
    updateChordDisplay();
    log('[PREV] Playback anterior restaurado.');
  }, 100);
}

    function onSave() {
      if (!audio.ctx) return;
      startRecording();
    }

    // Adicione estes bot√µes no HTML
    ui.play.addEventListener('click', onPlay);
    ui.pause.addEventListener('click', onPause);
    ui.stop.addEventListener('click', onStop);
    ui.save.addEventListener('click', onSave);
    ui.btnRestart.addEventListener('click', onRestart);
    ui.btnPrev.addEventListener('click', onPrev);

    window.addEventListener('load', () => {
      log('üîß Pr√©-carregando acordes...');
      initAudio();
      preloadCommonChords();
    });

    // Fun√ß√£o faltante: scheduleStep
    function scheduleStep(time, stepIdx) {
  const cell = state.pattern[stepIdx % state.pattern.length];

  // Bateria
  if (cell && cell !== '-' && !mute.drums) {
    const isSixteenth = stepIdx % 4 !== 0;
    const dynamicGain = isSixteenth ? 0.6 + Math.random() * 0.3 : 1.0;
    cell.split(',').forEach(p => {
      const buf = state.buffers.drums[p];
      if (!buf) return;
      const src = audio.ctx.createBufferSource();
      const gainNode = audio.ctx.createGain();
      src.buffer = buf;
      src.connect(gainNode);
      gainNode.connect(audio.drumGain);
      gainNode.gain.value = 0.8 * dynamicGain;
      src.start(time);
      if (p !== 'ataque' && p !== 'ba') src.stop(time + 0.15);
    });
  }

  // Mudan√ßa de acorde
  const [num, den] = meterToBeats(state.meter);
  const sixteenthsPerBar = num * 4;
  const isNewBar = stepIdx % sixteenthsPerBar === 0;

  if (isNewBar && stepIdx > 0) {
    state.barsInChord++;
    if (state.barsInChord >= state.chordDurations[state.currentChordIndex]) {
      state.currentChordIndex = (state.currentChordIndex + 1) % state.chordProgression.length;
      state.barsInChord = 0;

      const chord = getCurrentChord();
      if (!mute.clean) playChord(time, chord.note, chord.type, false);
      if (!mute.dist) playChord(time, chord.note, chord.type, true);

      // Atualiza modo do baixo: 4x t√¥nica, 1x arpejo
      if (state.bassMode === 'tonica') {
        if (state.bassCycleCount < 4) {
          state.bassCycleCount++;
        } else {
          state.bassMode = 'arpejo';
          state.bassCycleCount = 0;
        }
      } else if (state.bassMode === 'arpejo') {
        state.bassMode = 'tonica';
        state.bassCycleCount = 1; // 1¬∫ ciclo de t√¥nica
      }

      ui.currentChord.textContent = chord.displayName;
    }
    updateChordDisplay();
  }

  // Baixo
  const rhythmLines = state.currentGroove.bassRhythm.flatMap(line => line.split('|').map(s => s.trim()).filter(Boolean));
  const rhythmPattern = [];
  for (let i = 0; i < 16; i++) {
    const line = rhythmLines[i % rhythmLines.length];
    const parts = line.split(/\s+/).filter(Boolean);
    rhythmPattern.push(...parts);
  }

  const symbol = rhythmPattern[stepIdx % rhythmPattern.length];
  const bassKey = state.bassPlan[stepIdx % state.bassPlan.length];

  if (symbol === '¬∞' || symbol === '¬∫') {
    if (state.lastBassSrc) try { state.lastBassSrc.stop(time + 0.005); } catch(e){}
    return;
  }

  if (symbol === 'x' && state.buffers.bass['X'] && !mute.bass) {
    if (state.lastBassSrc) try { state.lastBassSrc.stop(time + 0.005); } catch(e){}
    const src = audio.ctx.createBufferSource();
    src.buffer = state.buffers.bass['X'];
    src.connect(audio.bassGain);
    src.start(time);
    src.stop(time + 0.1);
    src.onended = () => { if (state.lastBassSrc === src) state.lastBassSrc = null; };
    state.lastBassSrc = src;
    return;
  }

  if (symbol === 'S' && bassKey && bassKey !== '-' && bassKey !== 'X' && !mute.bass) {
    if (state.lastBassSrc) try { state.lastBassSrc.stop(time + 0.005); } catch(e){}
    const run = async () => {
      if (!state.buffers.bass[bassKey]) {
        try { state.buffers.bass[bassKey] = await loadBuffer(BASS_SAMPLES[bassKey]); }
        catch(e) { return; }
      }
      const src = audio.ctx.createBufferSource();
      src.buffer = state.buffers.bass[bassKey];
      src.connect(audio.bassGain);
      src.start(time);
      src.onended = () => { if (state.lastBassSrc === src) state.lastBassSrc = null; };
      state.lastBassSrc = src;
    };
    run();
  }
}

    // Fun√ß√£o faltante: stopRecording
    function stopRecording() {
      if (recorder && recorder.state !== 'inactive') recorder.stop();
    }

    // Vari√°veis faltantes: recorder, recChunks
    let recorder = null;
    let recChunks = [];

    // Fun√ß√£o faltante: startRecording
    function startRecording() {
      if (!audio.mix) return;
      try {
        recorder = new MediaRecorder(audio.mix.stream, { mimeType: 'audio/webm' });
      } catch (e) {
        log('[REC] Erro ao iniciar grava√ß√£o: ' + e.message);
        return;
      }

      recChunks = [];
      recorder.ondataavailable = e => { if (e.data.size) recChunks.push(e.data); };

      recorder.onstop = async () => {
        const webmBlob = new Blob(recChunks, { type: 'audio/webm' });
        log('[REC] WebM gravado. Convertendo para MP3...');

        const arrayBuffer = await webmBlob.arrayBuffer();
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

        const samples = audioBuffer.getChannelData(0);
        const samplesRight = audioBuffer.numberOfChannels > 1 ? audioBuffer.getChannelData(1) : samples;

        const mp3Encoder = new lamejs.Mp3Encoder(2, 44100, 128);
        const mp3Data = [];

        const frameSize = 1152;
        for (let i = 0; i < samples.length; i += frameSize) {
          const left = samples.subarray(i, i + frameSize);
          const right = samplesRight.subarray(i, i + frameSize);
          const mp3buf = mp3Encoder.encodeBuffer(left, right);
          if (mp3buf.length > 0) mp3Data.push(new Int8Array(mp3buf));
        }

        const final = mp3Encoder.flush();
        if (final.length > 0) mp3Data.push(new Int8Array(final));

        const mp3Blob = new Blob(mp3Data, { type: 'audio/mp3' });
        downloadMp3(mp3Blob);
      };

      recorder.start();

      const fixedDuration = 4 * 60 * 1000;
      const startTime = Date.now();
      const finalTimer = setInterval(() => {
        const now = Date.now();
        if (now >= startTime + fixedDuration) {
          if (recorder && recorder.state !== 'inactive') recorder.stop();
          clearInterval(finalTimer);
          log('[‚úÖ] Grava√ß√£o de 4 minutos conclu√≠da!');
        } else {
          const progress = ((now - startTime) / fixedDuration) * 100;
          const progressFill = document.getElementById('progressFill');
          if (progressFill) progressFill.style.width = `${progress}%`;
        }
      }, 1000);

      if (state.recordingTimer) clearInterval(state.recordingTimer);
      state.recordingTimer = finalTimer;

      log('[REC] Grava√ß√£o iniciada. Dura√ß√£o fixa: 4 minutos (ser√° convertido para MP3).');
      ui.save.disabled = true;
      ui.save.textContent = '‚è≥ Gravando... (4 min)';
    }

    // Fun√ß√£o faltante: downloadMp3
    function downloadMp3(blob) {
      const audioPreview = new Audio();
      audioPreview.src = URL.createObjectURL(blob);
      audioPreview.controls = true;
      audioPreview.style.display = 'block';
      audioPreview.style.margin = '10px 0';
      audioPreview.style.width = '100%';
      audioPreview.addEventListener('ended', () => URL.revokeObjectURL(audioPreview.src));

      const previewDiv = document.createElement('div');
      previewDiv.innerHTML = '<div><b>üéß Pr√©via do seu playback:</b></div>';
      previewDiv.appendChild(audioPreview);
      ui.log.parentNode.insertBefore(previewDiv, ui.log);

      const now = new Date();
      const dateStr = now.getFullYear() +
        String(now.getMonth() + 1).padStart(2, '0') +
        String(now.getDate()).padStart(2, '0') + '-' +
        String(now.getHours()).padStart(2, '0') +
        String(now.getMinutes()).padStart(2, '0');

      const filename = `jam-${state.signatureTag}-${dateStr}.mp3`;

      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(a.href);

      log(`[‚úÖ] Arquivo salvo: ${filename}`);
      ui.save.disabled = false;
      ui.save.textContent = 'üíæ Salvar 4 min (MP3)';
    }
  </script>
</body>
</html>