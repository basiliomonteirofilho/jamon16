<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jam on ‚Äì Playback Aleat√≥rio</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121822;
      --accent: #5eead4;
      --muted: #7a89a6;
      --text: #e6edf6;
      --danger: #f87171;
      --ok: #86efac;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; background: var(--bg); color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      min-height: 100vh; display: grid; place-items: center;
    }
    .wrap { width: min(1100px, 92vw); }
    header { display:flex; align-items:center; justify-content:space-between; gap:1rem; margin: 2rem 0 1.25rem; }
    h1 { font-size: clamp(1.4rem, 2.2vw, 2rem); margin: 0; letter-spacing: .3px; }
    
    .chord-display {
      grid-column: span 12;
      text-align: center;
      margin: 1rem 0;
    }
    .chord-name {
      font-size: 4rem;
      font-weight: bold;
      color: var(--accent);
      margin: 0;
    }
    .chord-timer {
      font-size: 1.5rem;
      color: var(--ok);
    }

    .card { background: linear-gradient(180deg, #121822, #0d131c); border: 1px solid #1e293b; border-radius: 18px; padding: 1rem; box-shadow: 0 10px 40px rgba(0,0,0,.25); }
    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 12px; }
    .controls { grid-column: span 12; display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .controls button, .controls select, .controls input[type="number"] {
      background: #0f172a; color: var(--text); border: 1px solid #1f2937; border-radius: 12px; padding: .65rem .9rem; font-size: .95rem; outline: none;
    }
    .controls button { cursor: pointer; border-color:#334155; transition: transform .06s ease, background .2s ease, border-color .2s ease; }
    .controls button:hover { transform: translateY(-1px); }
    .controls button.primary { background: #0b3b39; border-color:#134e4a; }
    .controls button.primary[data-state="on"] { background:#065f46; border-color:#0f766e; }
    .controls button.danger { background:#3b0b0b; border-color:#7f1d1d; }
    .pill { background:#0b1320; border:1px solid #1f2a44; padding:.4rem .6rem; border-radius:999px; font-size:.85rem; color: var(--muted); }
    .split { grid-column: span 12; display:grid; grid-template-columns: repeat(12, 1fr); gap:12px; }
    .panel { grid-column: span 6; background:#0b0f16; border:1px solid #1b2538; border-radius:12px; padding:12px; }
    .panel h3 { margin:0 0 8px; font-size:1rem; color:#a6b4cf; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:.92rem; }
    .log { grid-column: span 12; background:#080c12; border:1px dashed #1b283b; border-radius:12px; padding:10px; height: 170px; overflow:auto; white-space: pre-wrap; font-size:.9rem; color:#cbd5e1; }
    .footer { margin: .75rem 0 0; color: var(--muted); font-size:.85rem; }
    .badge { display:inline-block; padding:.15rem .45rem; border-radius:6px; border:1px solid #294256; background:#0b1826; color:#9bd5f0; font-size:.8rem; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .spacer { flex: 1 1 auto; }
    .muted { opacity: 0.5; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Jam on ‚Äì Playback Aleat√≥rio (baixo + bateria + guitarra)</h1>
      <div class="pill">Cada pulso do BPM = sem√≠nima</div>
    </header>

    <!-- Visor de acorde -->
    <div class="chord-display">
      <h2 class="chord-name" id="currentChord">‚Äî</h2>
      <div class="chord-timer" id="chordTimer">‚Äî</div>
    </div>

    <section class="card">
      <div class="grid">
        <div class="controls">
          <button id="btnPlay" class="primary">‚ñ∂Ô∏è Play</button>
          <button id="btnPause">‚è∏Ô∏è Pause</button>
          <button id="btnStop" class="danger">‚èπÔ∏è Stop</button>
          <button id="btnSave" class="primary">üíæ Salvar 4 min (MP3)</button>

          <!-- Bot√µes de mute -->
          <span class="spacer"></span>
          <button id="muteBass" data-mute="off">üé∏ Baixo</button>
          <button id="muteDrums" data-mute="off">ü•Å Bateria</button>
          <button id="muteClean" data-mute="off">üé∏ Limpa</button>
          <button id="muteDist" data-mute="off">üî• Distor√ß√£o</button>

          <label class="row">BPM <input id="bpm" type="number" min="40" max="220" value="100" style="width:90px"></label>
          <label class="row">Assinatura
            <select id="meter">
              <option value="auto" selected>aleat√≥ria</option>
              <option>2/4</option>
              <option>3/4</option>
              <option>4/4</option>
              <option>5/4</option>
              <option>6/4</option>
              <option>7/4</option>
            </select>
          </label>
        </div>

        <div class="split">
          <div class="panel" style="grid-column: span 6;">
            <h3>Estado atual</h3>
            <div class="mono" id="state"></div>
            <div class="footer">Ao clicar em <b>Play</b>, gera um novo playback aleat√≥rio.</div>
          </div>
          <div class="panel" style="grid-column: span 6;">
            <h3>Arquivos esperados</h3>
            <div class="mono">
              <div>Coloque os √°udios nas pastas:</div>
              <ul>
                <li><b>guitarraLimpa/[nota]/acorde.mp3</b> (ex: <code>guitarraLimpa/A/A.mp3</code>, <code>guitarraLimpa/A/Am.mp3</code>)</li>
                <li><b>guitarraDistorcao/[nota]/acorde.mp3</b> (ex: <code>guitarraDistorcao/AS/AS7.mp3</code>, <code>guitarraDistorcao/C/C.mp3</code>)</li>
                <li>Pe√ßas de bateria: <b>bumbo.mp3</b>, <b>caixa.mp3</b>, etc.</li>
                <li>Baixo: <b>bass-A.mp3</b>, <b>bass-AS.mp3</b>, etc.</li>
              </ul>
            </div>
          </div>
          <div class="log mono" id="log"></div>
        </div>
      </div>
    </section>
  </div>

<script>
  // =============================
  // Jam on ‚Äì Playback Personalizado
  // =============================
  const ui = {
    play: document.getElementById('btnPlay'),
    pause: document.getElementById('btnPause'),
    stop: document.getElementById('btnStop'),
    save: document.getElementById('btnSave'),
    muteBass: document.getElementById('muteBass'),
    muteDrums: document.getElementById('muteDrums'),
    muteClean: document.getElementById('muteClean'),
    muteDist: document.getElementById('muteDist'),
    bpm: document.getElementById('bpm'),
    meter: document.getElementById('meter'),
    log: document.getElementById('log'),
    state: document.getElementById('state'),
    currentChord: document.getElementById('currentChord'),
    chordTimer: document.getElementById('chordTimer'),
  };

  const audio = {
    ctx: null,
    master: null,
    mix: null,
    drumGain: null,
    bassGain: null,
    cleanGain: null,
    distGain: null,
    schedulerTimer: null,
    lookahead: 0.1,
    scheduleHorizon: 0.25,
  };

  const PITCHES = ['A','AS','B','C','CS','D','DS','E','F','FS','G','GS'];

  // Mapeamento de graus para notas
  const DEGREE_TO_ROOT = {
    1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11
  };

  // Mapeia PITCHES para nomes com #
  const PITCH_TO_NAME = {
    'A': 'A',   'AS': 'A#',
    'B': 'B',
    'C': 'C',   'CS': 'C#',
    'D': 'D',   'DS': 'D#',
    'E': 'E',
    'F': 'F',   'FS': 'F#',
    'G': 'G',   'GS': 'G#'
  };

  const NAME_TO_PITCH = {
    'A': 'A',   'A#': 'AS',
    'B': 'B',
    'C': 'C',   'C#': 'CS',
    'D': 'D',   'D#': 'DS',
    'E': 'E',
    'F': 'F',   'F#': 'FS',
    'G': 'G',   'G#': 'GS'
  };

  // Pe√ßas de bateria (s√≥ carrega o essencial)
  const DRUMS = {
    bumbo: 'assets/bumbo.mp3',
    caixa: 'assets/caixa.mp3',
    chimbal: 'assets/chimbal.mp3',
    conducao: 'assets/conducao.mp3'
  };

  // Gera todos os samples de baixo
  const BASS_SAMPLES = (() => {
    const baseOctaves = ['', '8', '16'];
    const table = {};
    for (const p of PITCHES) {
      for (const o of baseOctaves) {
        const note = p.replace('S', '');
        const sharp = p.includes('S') ? 'S' : '';
        const key = o + sharp;
        const filename = `bass-${note}${key || ''}.mp3`;
        table[p + o] = `assets/${filename}`;
      }
    }
    return table;
  })();

  BASS_SAMPLES['X'] = 'assets/bass-muted.mp3';

  // PROGRESS√ïES HARM√îNICAS
  const PROGRESSIONS = [
    [1, 1, 1, 1, 4, 4, 5, 5, 6, 6],
    [1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5],
    [1, 1, 7, 6, 5, 4, 3, 2, 1, 1, 4, 1],
    [1, 1, 1, 1, 5, 5, 5, 5, 6, 6, 6, 4, 4, 5, 5, 1, 1],
    [1, 1, 1, 1, 4, 4, 5, 5],
    [1, 1, 1, 3, 4, 5, 7, 4],
    [6, 4, 1, 1, 1, 5, 5, 4, 4, 5, 5],
    [1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 4, 4, 4, 4, 1, 1, 1, 1],
    [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 1, 1, 1],
    [4, 4, 4, 4, 5, 5, 6, 6, 1, 1, 1, 1, 3, 4],
    [1, 1, 1, 1, 2, 2, 4, 4, 5, 5],
    [1, 1, 1, 3, 4, 1, 1, 1, 3, 4, 5, 4, 5, 1, 1, 1, 1],
    [4, 4, 4, 4, 5, 5, 5, 5, 3, 3, 3, 3, 6, 6, 2, 5, 1, 5, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 5, 5, 1, 1, 1, 1, 4, 4, 5, 5, 1, 1, 1, 1]
  ];

  // üõ†Ô∏è CUSTOM_GROOVES
  const CUSTOM_GROOVES = [
    {
      name: "pop rock 1",
      meter: "4/4",
      drumPattern: [
        "ba - - - ch - - - cch - - - ch - bch - "
      ],
      bassRhythm: [
        "S - - - S - - - S ¬∞ S ¬∞ S ¬∞ S ¬∞"
      ]
    }
  ];

  const state = {
    running: false,
    paused: false,
    nextNoteTime: 0,
    meter: '4/4',
    bpm: 100,
    sixteenthDur: 0.15,
    stepIndex: 0,
    pattern: [],
    buffers: { drums: {}, bass: {}, guitar: {} },
    lastBassSrc: null,
    bassPlan: [],
    signatureTag: '',
    key: null,
    keyIdx: 0,
    quality: 'maj',
    chordProgression: [],
    chordDurations: [],
    currentGroove: null,
    currentChordIndex: 0,
    barsInChord: 0,
    bassMode: 'arpejo',
    bassCycleCount: 0,
    recordingTimer: null
  };

  const mute = { bass: false, drums: false, clean: false, dist: false };

  function log(msg){ ui.log.textContent += `\n${msg}`; ui.log.scrollTop = ui.log.scrollHeight; }

  function setStatePanel(){
    ui.state.innerHTML = `
      <div>Estilo: <b>${state.signatureTag}</b></div>
      <div>Compasso: <b>${state.meter}</b></div>
      <div>BPM: <b>${state.bpm}</b> (semicolcheia = ${(state.sixteenthDur * 1000).toFixed(0)} ms)</div>
      <div>Tom: <b>${state.key} ${state.quality}</b></div>
      <div>Progress√£o: <b>${state.chordProgression.join('-')}</b></div>
    `;
  }

 async function loadBuffer(url) {
  console.log('[LOAD] Carregando:', url);
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    const arrayBuffer = await res.arrayBuffer();
    const audioBuffer = await audio.ctx.decodeAudioData(arrayBuffer);
    return audioBuffer;
  } catch (e) {
    log(`[ERRO] Falha ao carregar: ${url} ‚Üí ${e.message}`);
    return null;
  }
}

  async function ensureSamples() {
  const essentialDrums = ['bumbo', 'caixa', 'chimbal', 'conducao'];
  const promises = [];

  // Carrega bateria essencial
  for (const k of essentialDrums) {
    if (!state.buffers.drums[k] && DRUMS[k]) {
      promises.push(loadBuffer(DRUMS[k]).then(buf => {
        if (buf) state.buffers.drums[k] = buf;
      }));
    }
  }

  // Carrega todos os samples de baixo
  for (const [k, url] of Object.entries(BASS_SAMPLES)) {
    if (!state.buffers.bass[k]) {
      promises.push(loadBuffer(url).then(buf => {
        if (buf) state.buffers.bass[k] = buf;
      }));
    }
  }

  await Promise.all(promises);
}
  function initAudio(){
    if (audio.ctx) return;
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    audio.ctx = ctx;
    audio.master = ctx.createGain();
    audio.master.gain.value = 0.9;

    audio.drumGain = ctx.createGain();
    audio.drumGain.gain.value = 0.85;

    audio.bassGain = ctx.createGain();
    audio.bassGain.gain.value = 0.9;

    audio.cleanGain = ctx.createGain();
    audio.cleanGain.gain.value = 0.8;

    audio.distGain = ctx.createGain();
    audio.distGain.gain.value = 0.8;

    audio.mix = ctx.createMediaStreamDestination();

    audio.drumGain.connect(audio.master);
    audio.bassGain.connect(audio.master);
    audio.cleanGain.connect(audio.master);
    audio.distGain.connect(audio.master);
    audio.master.connect(audio.mix);
    audio.master.connect(ctx.destination);
  }

  function randItem(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }

  function meterToBeats(meter) {
    const [num, den] = meter.split('/').map(Number);
    return [num, den];
  }

  function playClick(isStrong) {
    const ctx = audio.ctx;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain); gain.connect(audio.drumGain);
    osc.frequency.setValueAtTime(isStrong ? 880 : 440, ctx.currentTime);
    gain.gain.setValueAtTime(0.3, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);
    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + 0.08);
  }

  function selectRandomGroove() {
    return randItem(CUSTOM_GROOVES);
  }

  function buildBassPlan() {
    const groove = state.currentGroove;
    state.meter = ui.meter.value === 'auto' ? groove.meter : ui.meter.value;
    const [num, den] = meterToBeats(state.meter);
    const sixteenthsPerBar = num * 4;

    const totalBars = groove.drumPattern.length;
    const totalSteps = totalBars * sixteenthsPerBar;

    state.keyIdx = randInt(0, PITCHES.length - 1);
    state.key = PITCHES[state.keyIdx];
    state.quality = randItem(['maj', 'min']);

    const progression = randItem(PROGRESSIONS);
    state.chordProgression = progression;

    const durations = [];
    let current = progression[0], count = 1;
    for (let i = 1; i < progression.length; i++) {
      if (progression[i] === current) count++;
      else { durations.push(count); current = progression[i]; count = 1; }
    }
    durations.push(count);
    state.chordDurations = durations;
    state.currentChordIndex = 0;
    state.barsInChord = 0;
    state.bassMode = 'arpejo';
    state.bassCycleCount = 0;

    const chordMap = progression.map(degree => {
      const rootOffset = DEGREE_TO_ROOT[degree] || 0;
      const rootIdx = (state.keyIdx + rootOffset) % 12;
      return state.quality === 'maj' 
        ? [rootIdx, (rootIdx + 4) % 12, (rootIdx + 7) % 12]
        : [rootIdx, (rootIdx + 3) % 12, (rootIdx + 7) % 12];
    });

    const rhythmLines = groove.bassRhythm.flatMap(line => line.split('|').map(s => s.trim()).filter(Boolean));
    const rhythmPattern = [];
    for (let i = 0; i < totalBars; i++) {
      const line = rhythmLines[i % rhythmLines.length];
      const parts = line.split(/\s+/).filter(Boolean);
      rhythmPattern.push(...parts);
    }

    const plan = [];
    let barsInChord = 0;
    let chordIndex = 0;

    for (let step = 0; step < totalSteps; step++) {
      const sixteenthInBar = step % sixteenthsPerBar;
      if (sixteenthInBar === 0) {
        barsInChord++;
        if (barsInChord >= state.chordDurations[chordIndex]) {
          chordIndex = (chordIndex + 1) % progression.length;
          barsInChord = 0;
        }
      }

      const chordNotes = chordMap[chordIndex];
      const root = PITCHES[chordNotes[0]];
      const third = PITCHES[chordNotes[1]];
      const fifth = PITCHES[chordNotes[2]];

      const rhythm = rhythmPattern[step % rhythmPattern.length];
      let note = '-';

      if (rhythm === 'S') {
        if (state.bassMode === 'tonica') {
          note = root;
        } else {
          note = randItem([root, third, fifth]);
        }
      } else if (rhythm === 'x') {
        note = 'X';
      } else if (rhythm === '¬∞' || rhythm === '¬∫') {
        note = '-';
      }

      plan.push(note);
    }

    state.bassPlan = plan;
    state.signatureTag = groove.name;
    updateChordDisplay();
  }

  function buildDrumPattern() {
    const groove = state.currentGroove;
    const [num, den] = meterToBeats(state.meter);
    const sixteenthsPerBar = num * 4;
    const totalSteps = 16 * sixteenthsPerBar;

    const patternLines = groove.drumPattern.flatMap(line =>
      line.split('|').map(s => s.trim()).filter(Boolean)
    );
    const expandedPattern = [];

    for (let i = 0; i < 16; i++) {
      const line = patternLines[i % patternLines.length];
      const parts = line.split(/\s+/).filter(Boolean);
      expandedPattern.push(...parts);
    }

    const result = [];
    for (let i = 0; i < totalSteps; i++) {
      let cell = expandedPattern[i % expandedPattern.length];
      if (!cell || cell === '-' || cell === '----') {
        result.push('-');
        continue;
      }

      cell = cell
        .replace(/\(bu\s+at\)|\(at\s+bu\)/gi, 'ba')
        .replace(/\(bu\s+ch\)|\(ch\s+bu\)/gi, 'bch')
        .replace(/\(ch\s+ca\)|\(ca\s+ch\)/gi, 'cch')
        .replace(/\(bu\s+co\)|\(co\s+bu\)/gi, 'bc')
        .replace(/\(ca\s+co\)|\(co\s+ca\)/gi, 'cc');

      cell = cell.replace(/\([^)]*\)/g, '').trim();
      if (!cell) {
        result.push('-');
        continue;
      }

      const drumMap = {
        bu: 'bumbo', ca: 'caixa', ch: 'chimbal', cha: 'chimbalAberto', co: 'conducao',
        at: 'ataque', to1: 'tom1', to2: 'tom2', su: 'surdo',
        ba: 'ba', bch: 'bch', cch: 'cch', bc: 'bc', cc: 'cc'
      };

      const pieces = cell.split(/\s+/).filter(Boolean).map(key => drumMap[key]).filter(Boolean);
      result.push(pieces.length ? pieces.join(',') : '-');
    }
    return result;
  }

 async function playChord(time, note, type, isDistorted) {
  const folder = isDistorted ? 'guitarraDistorcao' : 'guitarraLimpa';
  const key = `${folder}_${note}${type}`;
  
  // Se j√° temos o buffer carregado, use-o
  if (state.buffers.guitar[key]) {
    const src = audio.ctx.createBufferSource();
    const gainNode = isDistorted ? audio.distGain : audio.cleanGain;
    src.buffer = state.buffers.guitar[key];
    src.connect(gainNode);
    src.start(time);
    return;
  }
  
  // Caso contr√°rio, tente carregar o arquivo
  const url = `assets/${folder}/${note}/${note}${type}.mp3`;
  log(`[CHORD] Tentando carregar: ${url}`);
  
  try {
    const buf = await loadBuffer(url);
    if (!buf) {
      log(`[ERRO] Arquivo de acorde n√£o encontrado: ${url}`);
      return;
    }
    
    state.buffers.guitar[key] = buf;
    const src = audio.ctx.createBufferSource();
    const gainNode = isDistorted ? audio.distGain : audio.cleanGain;
    src.buffer = buf;
    src.connect(gainNode);
    src.start(time);
  } catch (e) {
    log(`[ERRO] Falha ao carregar acorde: ${url} ‚Üí ${e.message}`);
  }
}

  function getCurrentChord() {
  const chordNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const degree = state.chordProgression[state.currentChordIndex];
  const quality = state.quality;

  const rootOffset = DEGREE_TO_ROOT[degree] || 0;
  const noteIndex = (state.keyIdx + rootOffset) % 12;
  const noteSharp = chordNames[noteIndex];

  // Converter nome da nota para formato de pasta (A, AS, B, C, CS, etc.)
  const folderName = NAME_TO_PITCH[noteSharp] || 'A';

  // Tipos de acordes mais comuns que provavelmente existem
  const commonChordTypes = {
    'maj': ['', '7', 'maj7', '6', '9'],
    'min': ['m', 'm7', 'm6', 'm9']
  };

  // Escolher um tipo de acorde aleat√≥rio
  const chordType = randItem(commonChordTypes[quality]);
  
  return { 
    note: folderName, 
    type: chordType,
    displayName: noteSharp + (quality === 'maj' ? chordType : 'm' + chordType.replace('m', ''))
  };
}

async function preloadCommonChords() {
  const commonTypes = ['', '7', 'm', 'm7'];
  const folders = ['guitarraLimpa', 'guitarraDistorcao'];
  const notes = ['A', 'AS', 'B', 'C', 'CS', 'D', 'DS', 'E', 'F', 'FS', 'G', 'GS'];

  const promises = [];
  for (const folder of folders) {
    for (const note of notes) {
      for (const type of commonTypes) {
        const chordName = note + type;
        const key = `${folder}_${note}${type}`;
        const url = `assets/${folder}/${note}/${note}${type}.mp3`;
        
        // N√£o carregar novamente se j√° estiver carregado
        if (!state.buffers.guitar[key]) {
          promises.push(loadBuffer(url).then(buf => {
            if (buf) {
              state.buffers.guitar[key] = buf;
              log(`[PRELOAD] Carregado: ${note}${type}`);
            }
          }));
        }
      }
    }
  }
  
  await Promise.all(promises);
  log('[PRELOAD] Pr√©-carregamento de acordes conclu√≠do');
}

  function scheduleStep(time, stepIdx) {
    const cell = state.pattern[stepIdx % state.pattern.length];

    // Bateria
    if (cell && cell !== '-' && !mute.drums) {
      const isSixteenth = stepIdx % 4 !== 0;
      const dynamicGain = isSixteenth ? 0.6 + Math.random() * 0.3 : 1.0;
      cell.split(',').forEach(p => {
        const buf = state.buffers.drums[p];
        if (!buf) return;
        const src = audio.ctx.createBufferSource();
        const gainNode = audio.ctx.createGain();
        src.buffer = buf;
        src.connect(gainNode);
        gainNode.connect(audio.drumGain);
        gainNode.gain.value = 0.8 * dynamicGain;
        src.start(time);
        if (p !== 'ataque' && p !== 'ba') src.stop(time + 0.15);
      });
    }

    // Mudan√ßa de acorde
    const [num, den] = meterToBeats(state.meter);
    const sixteenthsPerBar = num * 4;
    const isNewBar = stepIdx % sixteenthsPerBar === 0;

    if (isNewBar && stepIdx > 0) {
      state.barsInChord++;
      if (state.barsInChord >= state.chordDurations[state.currentChordIndex]) {
        state.currentChordIndex = (state.currentChordIndex + 1) % state.chordProgression.length;
        state.barsInChord = 0;

        const chord = getCurrentChord();
        if (!mute.clean) playChord(time, chord.note, chord.type, false);
        if (!mute.dist) playChord(time, chord.note, chord.type, true);

        if (state.bassMode === 'arpejo') {
          state.bassMode = 'tonica';
          state.bassCycleCount = 0;
        } else if (state.bassMode === 'tonica') {
          state.bassCycleCount++;
          if (state.bassCycleCount >= 2) {
            state.bassMode = 'arpejo';
            state.bassCycleCount = 0;
          }
        }
        
        // Atualizar display com o nome correto do acorde
        ui.currentChord.textContent = chord.displayName;
      }
      updateChordDisplay();
    }

    // Baixo
    const rhythmLines = state.currentGroove.bassRhythm.flatMap(line => line.split('|').map(s => s.trim()).filter(Boolean));
    const rhythmPattern = [];
    for (let i = 0; i < 16; i++) {
      const line = rhythmLines[i % rhythmLines.length];
      const parts = line.split(/\s+/).filter(Boolean);
      rhythmPattern.push(...parts);
    }

    const symbol = rhythmPattern[stepIdx % rhythmPattern.length];
    const bassKey = state.bassPlan[stepIdx % state.bassPlan.length];

    if (symbol === '¬∞' || symbol === '¬∫') {
      if (state.lastBassSrc) try { state.lastBassSrc.stop(time + 0.005); } catch(e){}
      return;
    }

    if (symbol === 'x' && state.buffers.bass['X'] && !mute.bass) {
      if (state.lastBassSrc) try { state.lastBassSrc.stop(time + 0.005); } catch(e){}
      const src = audio.ctx.createBufferSource();
      src.buffer = state.buffers.bass['X'];
      src.connect(audio.bassGain);
      src.start(time);
      src.stop(time + 0.1);
      src.onended = () => { if (state.lastBassSrc === src) state.lastBassSrc = null; };
      state.lastBassSrc = src;
      return;
    }

    if (symbol === 'S' && bassKey && bassKey !== '-' && bassKey !== 'X' && !mute.bass) {
      if (state.lastBassSrc) try { state.lastBassSrc.stop(time + 0.005); } catch(e){}
      const run = async () => {
        if (!state.buffers.bass[bassKey]) {
          try { state.buffers.bass[bassKey] = await loadBuffer(BASS_SAMPLES[bassKey]); }
          catch(e) { return; }
        }
        const src = audio.ctx.createBufferSource();
        src.buffer = state.buffers.bass[bassKey];
        src.connect(audio.bassGain);
        src.start(time);
        src.onended = () => { if (state.lastBassSrc === src) state.lastBassSrc = null; };
        state.lastBassSrc = src;
      };
      run();
    }
  }

  function scheduler() {
    const now = audio.ctx.currentTime;
    while (state.nextNoteTime < now + audio.scheduleHorizon) {
      scheduleStep(state.nextNoteTime, state.stepIndex);
      state.nextNoteTime += state.sixteenthDur;
      state.stepIndex++;
    }
  }

  function startScheduler() {
    stopScheduler();
    audio.schedulerTimer = setInterval(scheduler, audio.lookahead * 1000);
  }

  function stopScheduler() {
    if (audio.schedulerTimer) clearInterval(audio.schedulerTimer);
    audio.schedulerTimer = null;
  }

  let recorder = null;
  let recChunks = [];

  function startRecording() {
    if (!audio.mix) return;
    try {
      recorder = new MediaRecorder(audio.mix.stream, { mimeType: 'audio/webm' });
    } catch (e) {
      log('[REC] Erro ao iniciar grava√ß√£o: ' + e.message);
      return;
    }

    recChunks = [];
    recorder.ondataavailable = e => { if (e.data.size) recChunks.push(e.data); };

    recorder.onstop = async () => {
      const webmBlob = new Blob(recChunks, { type: 'audio/webm' });
      log('[REC] WebM gravado. Convertendo para MP3...');

      const arrayBuffer = await webmBlob.arrayBuffer();
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

      const samples = audioBuffer.getChannelData(0);
      const samplesRight = audioBuffer.numberOfChannels > 1 ? audioBuffer.getChannelData(1) : samples;

      const mp3Encoder = new lamejs.Mp3Encoder(2, 44100, 128);
      const mp3Data = [];

      const frameSize = 1152;
      for (let i = 0; i < samples.length; i += frameSize) {
        const left = samples.subarray(i, i + frameSize);
        const right = samplesRight.subarray(i, i + frameSize);
        const mp3buf = mp3Encoder.encodeBuffer(left, right);
        if (mp3buf.length > 0) mp3Data.push(new Int8Array(mp3buf));
      }

      const final = mp3Encoder.flush();
      if (final.length > 0) mp3Data.push(new Int8Array(final));

      const mp3Blob = new Blob(mp3Data, { type: 'audio/mp3' });
      downloadMp3(mp3Blob);
    };

    recorder.start();

    const fixedDuration = 4 * 60 * 1000;
    const startTime = Date.now();
    const finalTimer = setInterval(() => {
      const now = Date.now();
      if (now >= startTime + fixedDuration) {
        if (recorder && recorder.state !== 'inactive') recorder.stop();
        clearInterval(finalTimer);
        log('[‚úÖ] Grava√ß√£o de 4 minutos conclu√≠da!');
      } else {
        const progress = ((now - startTime) / fixedDuration) * 100;
        const progressFill = document.getElementById('progressFill');
        if (progressFill) progressFill.style.width = `${progress}%`;
      }
    }, 1000);

    if (state.recordingTimer) clearInterval(state.recordingTimer);
    state.recordingTimer = finalTimer;

    log('[REC] Grava√ß√£o iniciada. Dura√ß√£o fixa: 4 minutos (ser√° convertido para MP3).');
    ui.save.disabled = true;
    ui.save.textContent = '‚è≥ Gravando... (4 min)';
  }

  function stopRecording() {
    if (recorder && recorder.state !== 'inactive') recorder.stop();
  }

  function downloadMp3(blob) {
    const audioPreview = new Audio();
    audioPreview.src = URL.createObjectURL(blob);
    audioPreview.controls = true;
    audioPreview.style.display = 'block';
    audioPreview.style.margin = '10px 0';
    audioPreview.style.width = '100%';
    audioPreview.addEventListener('ended', () => URL.revokeObjectURL(audioPreview.src));

    const previewDiv = document.createElement('div');
    previewDiv.innerHTML = '<div><b>üéß Pr√©via do seu playback:</b></div>';
    previewDiv.appendChild(audioPreview);
    ui.log.parentNode.insertBefore(previewDiv, ui.log);

    const now = new Date();
    const dateStr = now.getFullYear() +
      String(now.getMonth() + 1).padStart(2, '0') +
      String(now.getDate()).padStart(2, '0') + '-' +
      String(now.getHours()).padStart(2, '0') +
      String(now.getMinutes()).padStart(2, '0');

    const filename = `jam-${state.signatureTag}-${dateStr}.mp3`;

    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(a.href);

    log(`[‚úÖ] Arquivo salvo: ${filename}`);
    ui.save.disabled = false;
    ui.save.textContent = 'üíæ Salvar 4 min (MP3)';
  }

  function toggleMute(type, button) {
    mute[type] = !mute[type];
    button.dataset.mute = mute[type] ? 'on' : 'off';
    button.textContent = mute[type] ? `üîá ${button.textContent.split(' ')[1]}` : `üîä ${button.textContent.split(' ')[1]}`;
    
    // Atualiza visualmente os bot√µes de mute
    if (mute[type]) {
      button.classList.add('muted');
    } else {
      button.classList.remove('muted');
    }
  }

  ui.muteBass.addEventListener('click', () => toggleMute('bass', ui.muteBass));
  ui.muteDrums.addEventListener('click', () => toggleMute('drums', ui.muteDrums));
  ui.muteClean.addEventListener('click', () => toggleMute('clean', ui.muteClean));
  ui.muteDist.addEventListener('click', () => toggleMute('dist', ui.muteDist));

  function updateChordDisplay() {
    const chordNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const degree = state.chordProgression[state.currentChordIndex];
    const rootOffset = DEGREE_TO_ROOT[degree] || 0;
    const rootIdx = (state.keyIdx + rootOffset) % 12;
    const rootNote = chordNames[rootIdx];
    const chordType = state.quality === 'maj' ? '' : 'm';
    const currentChord = rootNote + chordType;
    const barsLeft = state.chordDurations[state.currentChordIndex] - state.barsInChord;

    ui.chordTimer.textContent = `Pr√≥x: ${barsLeft} compasso(s)`;
  }

  async function onPlay() {
    if (state.running) { onStop(); setTimeout(onPlay, 100); return; }
    initAudio();
    await ensureSamples(); // Garante que as samples est√£o carregadas
    
    state.currentGroove = selectRandomGroove();
    
    buildBassPlan();
    state.pattern = buildDrumPattern();
    state.bpm = Number(ui.bpm.value) || 100;
    state.sixteenthDur = (60 / state.bpm) / 4;
    state.stepIndex = 0;
    state.currentChordIndex = 0;
    state.barsInChord = 0;
    state.bassMode = 'arpejo';
    state.bassCycleCount = 0;

    const [num] = meterToBeats(state.meter);
    const quarterDur = 60 / state.bpm;
    const totalClicks = num * 2;
    const playbackStartTime = audio.ctx.currentTime + 0.1 + totalClicks * quarterDur;
    state.nextNoteTime = playbackStartTime;

    for (let i = 0; i < totalClicks; i++) {
      const isStrong = i % num === 0;
      const clickTime = audio.ctx.currentTime + 0.1 + i * quarterDur;
      setTimeout(() => playClick(isStrong), (clickTime - audio.ctx.currentTime) * 1000);
    }

    setTimeout(() => {
      state.running = true;
      startScheduler();
      ui.play.dataset.state = 'on';
      log(`[PLAY] Estilo: ${state.signatureTag} | ${state.meter} @ ${state.bpm} BPM`);
    }, (playbackStartTime - audio.ctx.currentTime) * 1000);

    setStatePanel();
    updateChordDisplay();
  }

  function onPause() {
    if (state.running && !state.paused) {
      audio.ctx.suspend();
      state.paused = true;
      stopScheduler();
      ui.play.textContent = '‚ñ∂Ô∏è Retomar';
    } else if (state.paused) {
      audio.ctx.resume();
      state.paused = false;
      ui.play.textContent = '‚è∏Ô∏è Pause';
      startScheduler();
    }
  }

  async function onStop() {
    stopScheduler();
    stopRecording();

    if (audio.ctx && audio.ctx.state !== 'closed') {
      try {
        await audio.ctx.close();
      } catch (e) {
        console.warn('[√ÅUDIO] Erro ao fechar AudioContext:', e);
      }
    }
    audio.ctx = null;

    state.running = false;
    state.paused = false;
    state.stepIndex = 0;
    state.pattern = [];
    state.bassPlan = [];
    state.currentGroove = null;

    ui.currentChord.textContent = '‚Äî';
    ui.chordTimer.textContent = '‚Äî';

    ui.play.dataset.state = '';
    ui.play.textContent = '‚ñ∂Ô∏è Play';
    log('[STOP] Pronto para novo playback.');
  }

  function onSave() {
    if (!audio.ctx) return;
    startRecording();
  }

  ui.play.addEventListener('click', onPlay);
  ui.pause.addEventListener('click', onPause);
  ui.stop.addEventListener('click', onStop);
  ui.save.addEventListener('click', onSave);

  // Pr√©-carregar alguns acordes comuns quando a p√°gina carregar
  window.addEventListener('load', () => {
    log('üîß Iniciando pr√©-carregamento de acordes comuns...');
    if (audio.ctx) {
      preloadCommonChords();
    } else {
      // Se o AudioContext ainda n√£o foi inicializado, inicializar primeiro
      initAudio();
      preloadCommonChords();
    }
  });
</script>
</body>
</html>
