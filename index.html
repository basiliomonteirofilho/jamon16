<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Jam on ‚Äì Playback Aleat√≥rio</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; margin: 20px; background: #f0f0f0; }
    .card { background: white; padding: 20px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
    .grid { display: grid; grid-template-columns: 1fr; gap: 20px; }
    .row { display: flex; align-items: center; margin: 10px 0; }
    .row label { width: 120px; }
    button { padding: 10px; margin: 5px; cursor: pointer; border: none; border-radius: 6px; }
    .primary { background: #4CAF50; color: white; }
    .danger { background: #f44336; color: white; }
    .muted { opacity: 0.6; }
    .chord-display { text-align: center; margin: 20px 0; }
    .chord-name { font-size: 2.5em; margin: 0; }
    .mono { font-family: monospace; font-size: 0.9em; background: #eee; padding: 10px; border-radius: 6px; }
    .footer { font-size: 0.8em; color: #666; margin-top: 10px; }
    .pill { display: inline-block; background: #000; color: #fff; padding: 4px 8px; border-radius: 12px; font-size: 0.8em; }
    #log { height: 120px; overflow:auto; white-space: pre-wrap; margin-top:10px; }
  </style>
</head>
<body>
  <header>
    <h1>Jam on ‚Äì Playback Aleat√≥rio (baixo + bateria + guitarra)</h1>
    <div class="pill">Cada pulso do BPM = sem√≠nima</div>
  </header>

  <div class="chord-display">
    <h2 class="chord-name" id="currentChord">‚Äî</h2>
    <div id="chordTimer">‚Äî</div>
  </div>

  <div class="card">
    <div class="controls">
      <button id="btnPlay" class="primary">‚ñ∂ Play</button>
      <button id="btnPause">‚è∏ Pause</button>
      <button id="btnStop" class="danger">‚èπ Stop</button>
      <button id="btnSave" class="primary">üíæ Salvar 4 min (MP3)</button>

      <div style="margin-top: 10px;">
        <button id="muteBass" data-mute="off">üé∏ Baixo</button>
        <button id="muteDrums" data-mute="off">ü•Å Bateria</button>
        <button id="muteClean" data-mute="off">üé∏ Limpa</button>
        <button id="muteDist" data-mute="off">üî• Distor√ß√£o</button>
      </div>

      <div class="row">
        <label>BPM</label>
        <input id="bpm" type="number" min="40" max="220" value="100" style="width:90px">
      </div>

      <div class="row">
        <label>Assinatura</label>
        <select id="meter">
          <option value="auto" selected>aleat√≥ria</option>
          <option>2/4</option>
          <option>3/4</option>
          <option>4/4</option>
          <option>5/4</option>
          <option>6/4</option>
          <option>7/4</option>
        </select>
      </div>
    </div>

    <div class="panel">
      <h3>Estado atual</h3>
      <div class="mono" id="state"></div>
      <div class="footer">Ao clicar em <b>Play</b>, gera um novo playback aleat√≥rio.</div>
    </div>

    <div class="panel">
      <h3>Arquivos esperados</h3>
      <div class="mono">
        <div>Coloque os √°udios nas pastas:</div>
        <ul>
          <li><b>guitarraLimpa/[nota]/[nota][tipo].mp3</b> ‚Äî Ex: guitarraLimpa/A/A.mp3 ou guitarraLimpa/C/Cm.mp3</li>
          <li><b>guitarraDistorcao/[nota]/[nota][tipo].mp3</b></li>
          <li><b>assets/bumbo.mp3</b>, <b>assets/caixa.mp3</b>, <b>assets/chimbal.mp3</b></li>
          <li><b>assets/bass-A.mp3</b>, <b>assets/bass-AS.mp3</b>, etc. (A, AS, B, C, CS, ...)</li>
        </ul>
      </div>
    </div>

    <div class="log mono" id="log"></div>
  </div>

  <script>
    const ui = {
      play: document.getElementById('btnPlay'),
      pause: document.getElementById('btnPause'),
      stop: document.getElementById('btnStop'),
      save: document.getElementById('btnSave'),
      muteBass: document.getElementById('muteBass'),
      muteDrums: document.getElementById('muteDrums'),
      muteClean: document.getElementById('muteClean'),
      muteDist: document.getElementById('muteDist'),
      bpm: document.getElementById('bpm'),
      meter: document.getElementById('meter'),
      state: document.getElementById('state'),
      log: document.getElementById('log'),
      currentChord: document.getElementById('currentChord'),
      chordTimer: document.getElementById('chordTimer')
    };

    const audio = {
      ctx: null,
      master: null,
      mix: null,
      drumGain: null,
      bassGain: null,
      cleanGain: null,
      distGain: null,
      schedulerTimer: null
    };

    const PITCHES = ['A','AS','B','C','CS','D','DS','E','F','FS','G','GS'];
    const DEGREE_TO_ROOT = { 1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11 };
    const CHORD_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];

    const DRUMS = {
      ba: 'bumbo-ataque',
      cch:  'caixa-chimbal',
      bch: 'bumbo-chimbal',
      bu: 'bumbo',
      ca: 'caixa',
      ch: 'chimbal',
      
    };

    // Bass sample mapping (expecting files like assets/bass-A.mp3, assets/bass-AS.mp3 ... )
    const BASS_SAMPLES = {};
    for (const p of PITCHES) {
      BASS_SAMPLES[p] = `assets/bass-${p}.mp3`;
    }
    BASS_SAMPLES['X'] = 'assets/bass-muted.mp3';

    const ALL_GROOVES = [
  {
    name: "Rock B√°sico",
    meter: "4/4",
    drumPattern: ["ba - ch - cch - ch - bch - ch - cch - ch", "ba - ch - cch - ch - bch - ch - cch - ch"],
    bassRhythm: ["bo - sm - bo - sm - bo - sm - bo - sm", "bo - sm - bo - sm - bo - sm - bo - sm"]
  },
  {
    name: "Pop Sincopado",
    meter: "4/4",
    drumPattern: ["ba - ch - cch - ch - bch - ch - cch - ch", "ba - ch - cch - ch - bch - ch - cch - ch"],
    bassRhythm: ["bo - sm - bs - sm - bo - sm - bx - sm", "bo - sm - bs - sm - bo - sm - bx - sm"]
  },
  {
    name: "Funk",
    meter: "4/4",
    drumPattern: ["ba - ch - cch - ch - bch - ch - cch - ch", "ba - ch - cch - ch - bch - ch - cch - ch"],
    bassRhythm: ["bo - sm - bo - bs - sm - bo - bx - sm", "bo - sm - bo - bs - sm - bo - bx - sm"]
  }
];

    const PROGRESSIONS = [[1, 1, 4, 4, 5, 5, 1, 1], [1, 4, 5, 1],[1, 1, 1, 1, 3, 3, 4, 4, 5, 5, 2, 2, 3, 3, 1, 1]];

    const state = {
      running: false,
      paused: false,
      nextNoteTime: 0,
      meter: '4/4',
      bpm: 100,
      sixteenthDur: 0.15,
      stepIndex: 0,
      buffers: { drums: {}, bass: {}, guitar: {} },
      bassPlan: [],
      chordPlan: [],
      signatureTag: '',
      key: null,
      keyIdx: 0,
      quality: 'maj',
      chordProgression: [],
      chordDurations: [],
      currentGroove: null,
      currentChordIndex: 0,
      barsInChord: 0,
      clickCount: 0,
      totalClicks: 0,
      drumSeq: []
    };

    const mute = { bass: false, drums: false, clean: false, dist: false };

    function log(msg) {
      const now = new Date().toLocaleTimeString();
      ui.log.textContent += `[${now}] ${msg}\n`;
      ui.log.scrollTop = ui.log.scrollHeight;
    }

    function meterToBeats(meter) {
      return Number(meter.split('/')[0]) || 4;
    }

    function setStatePanel() {
      ui.state.innerHTML = `<div>Levada: ${state.signatureTag || '‚Äî'}</div><div>Key: ${state.key || '‚Äî'} ${state.quality}</div>`;
    }

    async function initAudio() {
      if (audio.ctx) return;
      audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
      audio.master = audio.ctx.createGain();
      audio.mix = audio.ctx.createGain();
      audio.drumGain = audio.ctx.createGain();
      audio.bassGain = audio.ctx.createGain();
      audio.cleanGain = audio.ctx.createGain();
      audio.distGain = audio.ctx.createGain();

      // conservative default gains to avoid clipping
      audio.master.gain.value = 0.9;
      audio.drumGain.gain.value = 0.6;
      audio.bassGain.gain.value = 0.45;
      audio.cleanGain.gain.value = 0.45;
      audio.distGain.gain.value = 0.35;

      audio.master.connect(audio.mix);
      audio.mix.connect(audio.ctx.destination);

      audio.drumGain.connect(audio.master);
      audio.bassGain.connect(audio.master);
      audio.cleanGain.connect(audio.master);
      audio.distGain.connect(audio.master);

      log('üîß Inicializando √°udio e pr√©-carregando b√°sicos...');
      await ensureBasicSamples();
      log('‚úÖ B√°sicos carregados.');
    }

    async function loadBuffer(url) {
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const arrayBuffer = await res.arrayBuffer();
        return await audio.ctx.decodeAudioData(arrayBuffer);
      } catch (e) {
        log(`[ERRO] Falha ao carregar: ${url} ‚Üí ${e.message}`);
        return null;
      }
    }

    async function ensureBasicSamples() {
      const promises = [];
      // drums
      for (const [key, name] of Object.entries(DRUMS)) {
        const url = `assets/${name}.mp3`;
        if (!state.buffers.drums[key]) {
          promises.push(loadBuffer(url).then(buf => { if (buf) state.buffers.drums[key] = buf; }));
        }
      }
      // bass
      for (const [key, url] of Object.entries(BASS_SAMPLES)) {
        if (!state.buffers.bass[key]) {
          promises.push(loadBuffer(url).then(buf => { if (buf) state.buffers.bass[key] = buf; }));
        }
      }
      await Promise.all(promises);
    }

    // expande um padr√£o para passos de semicolcheia (16 por compasso em 4/4)
    function expandRhythm(patternArray, totalSteps) {
      const joined = patternArray.join(' ').replace(/\s+/g, ' ').trim();
      const tokens = [];
      // extrai s√≥ tokens alfanum√©ricos e s√≠mbolos -, sm, etc.
      joined.split(/\s+/).forEach(t => {
        if (t) tokens.push(t);
      });
      const out = [];
      let i = 0;
      while (out.length < totalSteps) {
        for (const token of tokens) {
          if (out.length >= totalSteps) break;
          if (token === 'sm') {
            out.push('sm'); // assume 1 step (we handle densidade nos padr√µes)
          } else if (token === '-') {
            out.push('-');
          } else {
            out.push(token);
          }
        }
        // safety break
        i++; if (i>1000) break;
      }
      // trim to totalSteps
      return out.slice(0, totalSteps);
    }

    function buildBassAndChordPlan() {
      state.currentGroove = ALL_GROOVES[Math.floor(Math.random() * ALL_GROOVES.length)];
      state.signatureTag = state.currentGroove.name;
      log(`üé≤ Levada sorteada: ${state.currentGroove.name}`);

      state.meter = ui.meter.value === 'auto' ? state.currentGroove.meter : ui.meter.value;
      const beats = meterToBeats(state.meter);
      const sixteenthsPerBar = beats * 4;

      // escolher tonalidade e qualidade
      state.keyIdx = Math.floor(Math.random() * PITCHES.length);
      state.key = PITCHES[state.keyIdx];
      state.quality = Math.random() > 0.5 ? 'maj' : 'min';
      state.chordProgression = PROGRESSIONS[Math.floor(Math.random() * PROGRESSIONS.length)];

      // calcular dura√ß√µes por acorde (em compassos) - aqui usamos 1 compasso por Grau por padr√£o, agrupando iguais
      const durations = [];
      let count = 1;
      for (let i = 1; i < state.chordProgression.length; i++) {
        if (state.chordProgression[i] === state.chordProgression[i-1]) count++;
        else { durations.push(count); count = 1; }
      }
      durations.push(count);
      state.chordDurations = durations;

      const totalBars = state.chordDurations.reduce((a,b)=>a+b,0);
      const totalSteps = sixteenthsPerBar * totalBars; // passos totais = semicolcheias por barra * barras da progress√£o

      // preparar ritmo do baixo
      const rhythm = expandRhythm(state.currentGroove.bassRhythm, totalSteps);

      const bassPlan = [];
      const chordPlan = [];

      let chordIndex = 0;
      let barsCounted = 0;
      let stepsInCurrentBar = 0;

      for (let step = 0; step < totalSteps; step++) {
        if (stepsInCurrentBar === 0) {
          // in√≠cio de bar
          if (barsCounted >= state.chordDurations[chordIndex]) {
            chordIndex = (chordIndex + 1) % state.chordProgression.length;
            barsCounted = 0;
          }
        }

        // determine degree and root
        const degree = state.chordProgression[chordIndex];
        const rootOffset = DEGREE_TO_ROOT[degree] || 0;
        const rootIdx = (state.keyIdx + rootOffset) % 12;
        const rootNote = PITCHES[rootIdx];
        const chordType = state.quality === 'maj' ? '' : 'm';
        const chordDisplay = CHORD_NAMES[rootIdx] + chordType;

        // bass symbol
        // bass symbol (interpreta√ß√£o dos tokens)
const sym = rhythm[step] || '-';
let bassNote = '-';

if (sym === 'sm' || sym === '-') {
  bassNote = '-'; // sil√™ncio / ghost note
} else if (sym === 'bo') {
  bassNote = rootNote; // t√¥nica
} else if (sym === 'bs') {
  // quinta justa (7 semitons acima)
  const fifthIdx = (rootIdx + 7) % 12;
  bassNote = PITCHES[fifthIdx];
} else if (sym === 'bx') {
  // oitava (12 semitons acima ‚Üí mesma letra da t√¥nica)
  bassNote = rootNote;
} else {
  // fallback = t√¥nica
  bassNote = rootNote;
}

bassPlan.push(bassNote);

        chordPlan.push({ note: rootNote, type: chordType, display: chordDisplay });

        stepsInCurrentBar++;
        if (stepsInCurrentBar >= sixteenthsPerBar) {
          stepsInCurrentBar = 0;
          barsCounted++;
        }
      }

      // store
      state.bassPlan = bassPlan.length ? bassPlan : ['-'];
      state.chordPlan = chordPlan.length ? chordPlan : [{ note: 'C', type: '', display: 'C' }];
      state.currentChordIndex = 0;
      state.barsInChord = 0;

      // preparar drum sequence baseado em drumPattern (intro+loop -> seq de tokens)
      const drumParsed = parsePattern(state.currentGroove.drumPattern.join(' '));
      const drumSeq = [...drumParsed.intro, ...drumParsed.loop];
      // expand drumSeq para o mesmo totalSteps (repete o loop)
      const drumExpanded = [];
      while (drumExpanded.length < state.bassPlan.length) {
        for (const t of drumSeq) {
          if (drumExpanded.length >= state.bassPlan.length) break;
          drumExpanded.push(t);
        }
      }
      state.drumSeq = drumExpanded.slice(0, state.bassPlan.length);

      setStatePanel();

      // pr√©-carregar guitarras necess√°rias (limpa e distorcida)
      const guitarUrls = new Set();
      for (const ch of state.chordPlan) {
        const base = `${ch.note}${ch.type}`;
        guitarUrls.add(`guitarraLimpa/${ch.note}/${base}.mp3`);
        guitarUrls.add(`guitarraDistorcao/${ch.note}/${base}.mp3`);
      }
      const preloadPromises = [];
      guitarUrls.forEach(url => {
        if (!state.buffers.guitar[url]) {
          preloadPromises.push(loadBuffer(url).then(buf => { if (buf) state.buffers.guitar[url] = buf; }));
        }
      });

      Promise.all(preloadPromises).then(() => log('‚úÖ Guitarras pr√©-carregadas para a progress√£o.'));
    }

    function playClickAtTime(time, isStrong) {
      const ctx = audio.ctx;
      const osc = ctx.createOscillator();
      const g = ctx.createGain();
      osc.connect(g);
      g.connect(audio.drumGain);
      osc.frequency.value = isStrong ? 880 : 440;
      g.gain.setValueAtTime(0.0, time);
      g.gain.linearRampToValueAtTime(isStrong ? 0.18 : 0.09, time + 0.002);
      g.gain.linearRampToValueAtTime(0.0, time + 0.06);
      osc.start(time);
      osc.stop(time + 0.07);
    }

    function onPlay() {
      if (!audio.ctx) initAudio();
      if (state.running && !state.paused) return;

      state.bpm = Number(ui.bpm.value) || 100;
      state.sixteenthDur = 60 / state.bpm / 4;

      buildBassAndChordPlan();

      if (state.paused) {
        state.paused = false;
        log('‚ñ∂ Retomando reprodu√ß√£o.');
        return;
      }

      // reset
      state.running = false;
      state.stepIndex = 0;
      state.nextNoteTime = audio.ctx.currentTime + 0.05; // pequeno offset
      const beats = meterToBeats(state.meter);
      const quarterDur = 60 / state.bpm;

      state.totalClicks = beats; // um compasso de clique
      state.clickCount = 0;

      // agendar clique(s) de contagem (usamos 1 compasso de contagem por padr√£o)
      const startTime = audio.ctx.currentTime + 0.05;
      for (let i = 0; i < state.totalClicks; i++) {
        const t = startTime + i * quarterDur;
        const isStrong = (i % beats) === 0;
        playClickAtTime(t, isStrong);
      }

      const schedulerStartTime = startTime + state.totalClicks * quarterDur; // inicia ap√≥s os cliques
      const msDelay = Math.max(0, (schedulerStartTime - audio.ctx.currentTime) * 1000 + 10);

      setTimeout(() => {
        state.running = true;
        state.nextNoteTime = schedulerStartTime;
        log(`[PLAY] Iniciando: ${state.signatureTag} | ${state.meter}@${state.bpm} BPM`);
        startScheduler();
      }, msDelay);
    }

    function scheduler() {
      if (!state.running || state.paused) return;
      const lookahead = 0.12; // segundos para "pr√©-agendar"
      const currentTime = audio.ctx.currentTime;
      while (state.nextNoteTime < currentTime + lookahead) {
        scheduleStep();
      }
    }

    function scheduleStep() {
      const time = state.nextNoteTime;
      const stepIdx = state.stepIndex;
      const beats = meterToBeats(state.meter);
      const sixteenthsPerBar = beats * 4;
      const isNewBar = (stepIdx % sixteenthsPerBar) === 0;

      // DRUMS
      const drumToken = state.drumSeq[stepIdx % state.drumSeq.length];
      if (drumToken && !mute.drums) {
        // map drum token to sample key - here token 'ba' => bu, 'ca' => ca, 'ch' => ch
        // Accept several tokens
        let key = null;
if (/^(cch|caixa-chimbal)$/i.test(drumToken)) key = 'cch';
else if (/^(bch|bumbo-chimbal)$/i.test(drumToken)) key = 'bch';
else if (/^(ba|bumbo-ataque)$/i.test(drumToken)) key = 'ba';
else if (/^(bu|bumbo)$/i.test(drumToken)) key = 'bu';
else if (/^(ca|caixa)$/i.test(drumToken)) key = 'ca';
else if (/^(ch|chimbal)$/i.test(drumToken)) key = 'ch';
        
        if (key && state.buffers.drums[key]) {
          const src = audio.ctx.createBufferSource();
          const g = audio.ctx.createGain();
          src.buffer = state.buffers.drums[key];
          src.connect(g);
          g.connect(audio.drumGain);
          // small attack to avoid click
          g.gain.setValueAtTime(0.0, time);
          g.gain.linearRampToValueAtTime(1.0, time + 0.005);
          g.gain.linearRampToValueAtTime(0.0, time + 0.2);
          src.start(time);
        }
      }

      // BASS (sempre sincronizado com mesmo `time`)
      const bassKey = state.bassPlan[stepIdx % state.bassPlan.length];
      if (bassKey && bassKey !== '-' && !mute.bass) {
        const buf = state.buffers.bass[bassKey] || state.buffers.bass[bassKey];
        if (buf) {
          const src = audio.ctx.createBufferSource();
          const g = audio.ctx.createGain();
          src.buffer = buf;
          src.connect(g);
          g.connect(audio.bassGain);
          // soft attack to avoid initial clipping
          g.gain.setValueAtTime(0.0, time);
          g.gain.linearRampToValueAtTime(1.0, time + 0.01);
          g.gain.linearRampToValueAtTime(0.0, time + state.sixteenthDur * 0.9); // release
          src.start(time);
        }
      }

      // GUITAR: tocar no in√≠cio do compasso (isNewBar)
      if (isNewBar) {
        const chordIdx = stepIdx % state.chordPlan.length;
        const chord = state.chordPlan[chordIdx];
        // update chord progress tracking
        if (chord) {
          if (!mute.clean) playChord(time, chord.note, chord.type, false);
          if (!mute.dist) playChord(time, chord.note, chord.type, true);
          ui.currentChord.textContent = chord.display;
          // calcular quantos compassos at√© trocar (exibe)
          // nota: state.barsInChord j√° conta como 0 no in√≠cio do acorde
          const barsLeft = Math.max(0, state.chordDurations[state.currentChordIndex] - state.barsInChord);
          ui.chordTimer.textContent = `Pr√≥x: ${barsLeft} compasso(s)`;
        }
        // avan√ßar contagem de barras por acorde (quando uma barra completa passar)
        // Esse incremento √© feito quando completarmos o bar; mas aqui estamos no in√≠cio do bar: incrementar s√≥ se j√° passamos a barra
        // Implementaremos incremento ao final do bar (quando stepIndex++ resultar em novo bar).
      }

      // avan√ßar step e next time
      state.stepIndex++;
      // se completou um compasso, atualizar barsInChord e possivelmente trocar acorde
      if ((state.stepIndex % (sixteenthsPerBar)) === 0) {
        state.barsInChord++;
        if (state.barsInChord >= state.chordDurations[state.currentChordIndex]) {
          state.currentChordIndex = (state.currentChordIndex + 1) % state.chordProgression.length;
          state.barsInChord = 0;
        }
      }

      state.nextNoteTime += state.sixteenthDur;
    }

    function playChord(time, note, type, isDistorted) {
      const folder = isDistorted ? 'guitarraDistorcao' : 'guitarraLimpa';
      const base = `${note}${type}`;
      const url = `${folder}/${note}/${base}.mp3`;
      const buf = state.buffers.guitar[url];
      if (buf) {
        const src = audio.ctx.createBufferSource();
        const g = audio.ctx.createGain();
        src.buffer = buf;
        src.connect(g);
g.connect(isDistorted ? audio.distGain : audio.cleanGain);
// ataque suave
g.gain.setValueAtTime(0.0, time);
g.gain.linearRampToValueAtTime(1.0, time + 0.01);

const beats = meterToBeats(state.meter);
const barDur = (60/state.bpm) * beats;
g.gain.linearRampToValueAtTime(0.0, time + Math.min(barDur * (state.chordDurations[state.currentChordIndex] || 1), barDur * 2));

src.start(time);
      } else {
        // se n√£o carregado, tenta carregar e tocar quando estiver pronto
        loadBuffer(url).then(b => {
          if (b) {
            state.buffers.guitar[url] = b;
            const src = audio.ctx.createBufferSource();
            const g = audio.ctx.createGain();
            src.buffer = b;
            src.connect(g);
            g.connect(isDistorted ? audio.distGain : audio.cleanGain);
            g.gain.setValueAtTime(0.0, time);
            g.gain.linearRampToValueAtTime(1.0, time + 0.01);
            src.start(time);
          } else {
            log(`[AVISO] amostra de guitarra faltando: ${url}`);
          }
        });
      }
    }

    function parsePattern(patternText) {
      const result = { intro: [], loop: [] };
      const introMatch = patternText.match(/\[(.*?)\]/);
      const loopMatch = patternText.match(/\((.*?)\)/);
      if (introMatch) result.intro = introMatch[1].trim().split(/\s+/).filter(s => s);
      if (loopMatch) result.loop = loopMatch[1].trim().split(/\s+/).filter(s => s);
      // if loop empty fallback to intro
      if (!result.loop.length) result.loop = result.intro.slice();
      return result;
    }

    function onPause() {
      if (state.running && !state.paused) {
        state.paused = true;
        log('‚è∏ Pausado.');
      }
    }

    function onStop() {
      state.running = false;
      state.paused = false;
      stopScheduler();
      ui.currentChord.textContent = '‚Äî';
      ui.chordTimer.textContent = '‚Äî';
      state.stepIndex = 0;
      log('‚èπ Stopped.');
    }

    function startScheduler() {
      stopScheduler();
      audio.schedulerTimer = setInterval(scheduler, 40);
    }

    function stopScheduler() {
      if (audio.schedulerTimer) clearInterval(audio.schedulerTimer);
      audio.schedulerTimer = null;
    }

    function toggleMute(type, button) {
      mute[type] = !mute[type];
      button.dataset.mute = mute[type] ? 'on' : 'off';
      const icon = mute[type] ? 'üîá' : (type === 'bass' ? 'üé∏' : (type === 'drums' ? 'ü•Å' : 'üé∏'));
      // maintain a short label after the icon
      const labelMap = { bass: 'Baixo', drums: 'Bateria', clean: 'Limpa', dist: 'Distor√ß√£o' };
      button.textContent = `${icon} ${labelMap[type]}`;
      button.classList.toggle('muted', mute[type]);
    }

    ui.play.addEventListener('click', onPlay);
    ui.pause.addEventListener('click', onPause);
    ui.stop.addEventListener('click', onStop);
    ui.muteBass.addEventListener('click', () => toggleMute('bass', ui.muteBass));
    ui.muteDrums.addEventListener('click', () => toggleMute('drums', ui.muteDrums));
    ui.muteClean.addEventListener('click', () => toggleMute('clean', ui.muteClean));
    ui.muteDist.addEventListener('click', () => toggleMute('dist', ui.muteDist));

    window.addEventListener('load', () => {
      log('Carregando interface... preparando √°udio (pr√©-carregando amostras b√°sicas).');
      initAudio();
    });
  </script>
</body>
</html>
