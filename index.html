<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jam on ‚Äì Playback Aleat√≥rio</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121822;
      --accent: #5eead4;
      --muted: #7a89a6;
      --text: #e6edf6;
      --danger: #f87171;
      --ok: #86efac;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; background: var(--bg); color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      min-height: 100vh; display: grid; place-items: center;
    }
    .wrap { width: min(1100px, 92vw); }
    header { display:flex; align-items:center; justify-content:space-between; gap:1rem; margin: 2rem 0 1.25rem; }
    h1 { font-size: clamp(1.4rem, 2.2vw, 2rem); margin: 0; letter-spacing: .3px; }
    
    .chord-display {
      grid-column: span 12;
      text-align: center;
      margin: 1rem 0;
    }
    .chord-name {
      font-size: 4rem;
      font-weight: bold;
      color: var(--accent);
      margin: 0;
    }
    .chord-timer {
      font-size: 1.5rem;
      color: var(--ok);
    }

    .card { background: linear-gradient(180deg, #121822, #0d131c); border: 1px solid #1e293b; border-radius: 18px; padding: 1rem; box-shadow: 0 10px 40px rgba(0,0,0,.25); }
    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 12px; }
    .controls { grid-column: span 12; display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .controls button, .controls select, .controls input[type="number"] {
      background: #0f172a; color: var(--text); border: 1px solid #1f2937; border-radius: 12px; padding: .65rem .9rem; font-size: .95rem; outline: none;
    }
    .controls button { cursor: pointer; border-color:#334155; transition: transform .06s ease, background .2s ease, border-color .2s ease; }
    .controls button:hover { transform: translateY(-1px); }
    .controls button.primary { background: #0b3b39; border-color:#134e4a; }
    .controls button.primary[data-state="on"] { background:#065f46; border-color:#0f766e; }
    .controls button.danger { background:#3b0b0b; border-color:#7f1d1d; }
    
    .pill { background:#0b1320; border:1px solid #1f2a44; padding:.4rem .6rem; border-radius:999px; font-size:.85rem; color: var(--muted); }
    .split { grid-column: span 12; display:grid; grid-template-columns: repeat(12, 1fr); gap:12px; }
    .panel { grid-column: span 6; background:#0b0f16; border:1px solid #1b2538; border-radius:12px; padding:12px; }
    .panel h3 { margin:0 0 8px; font-size:1rem; color:#a6b4cf; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:.92rem; }
    .log { grid-column: span 12; background:#080c12; border:1px dashed #1b283b; border-radius:12px; padding:10px; height: 170px; overflow:auto; white-space: pre-wrap; font-size:.9rem; color:#cbd5e1; }
    .footer { margin: .75rem 0 0; color: var(--muted); font-size:.85rem; }
    .badge { display:inline-block; padding:.15rem .45rem; border-radius:6px; border:1px solid #294256; background:#0b1826; color:#9bd5f0; font-size:.8rem; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .spacer { flex: 1 1 auto; }
    .muted { opacity: 0.5; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Jam on ‚Äì Playback Aleat√≥rio (baixo + bateria + guitarra)</h1>
      <div class="pill">Cada pulso do BPM = sem√≠nima</div>
    </header>

    <!-- Visor de acorde -->
    <div class="chord-display">
      <h2 class="chord-name" id="currentChord">‚Äî</h2>
      <div class="chord-timer" id="chordTimer">‚Äî</div>
    </div>

    <section class="card">
      <div class="grid">
        <div class="controls">
          <button id="btnRestart">‚èÆÔ∏è Reiniciar</button>
          <button id="btnPrev">‚è™ Anterior</button>
          <button id="btnPlay" class="primary">‚ñ∂Ô∏è Play</button>
          <button id="btnPause">‚è∏Ô∏è Pause</button>
          <button id="btnStop" class="danger">‚èπÔ∏è Stop</button>
          <button id="btnSave" class="primary">üíæ Salvar 4 min (MP3)</button>

          <!-- Bot√µes de mute -->
          <span class="spacer"></span>
          <button id="muteBass" data-mute="off">üé∏ Baixo</button>
          <button id="muteDrums" data-mute="off">ü•Å Bateria</button>
          <button id="muteClean" data-mute="off">üé∏ Limpa</button>
          <button id="muteDist" data-mute="off">üî• Distor√ß√£o</button>

          <label class="row">BPM <input id="bpm" type="number" min="40" max="220" value="100" style="width:90px"></label>
          <label class="row">Assinatura
            <select id="meter">
              <option value="auto" selected>aleat√≥ria</option>
              <option>2/4</option>
              <option>3/4</option>
              <option>4/4</option>
              <option>5/4</option>
              <option>6/4</option>
              <option>7/4</option>
            </select>
          </label>
        </div>

        <div class="split">
          <div class="panel" style="grid-column: span 6;">
            <h3>Estado atual</h3>
            <div class="mono" id="state"></div>
            <div class="footer">Ao clicar em <b>Play</b>, gera um novo playback aleat√≥rio.</div>
          </div>
          <div class="panel" style="grid-column: span 6;">
            <h3>Arquivos esperados</h3>
            <div class="mono">
              <div>Coloque os √°udios nas pastas:</div>
              <ul>
                <li><b>guitarraLimpa/[nota]/acorde.mp3</b> (ex: <code>guitarraLimpa/A/A.mp3</code>, <code>guitarraLimpa/A/Am.mp3</code>)</li>
                <li><b>guitarraDistorcao/[nota]/acorde.mp3</b> (ex: <code>guitarraDistorcao/AS/AS7.mp3</code>, <code>guitarraDistorcao/C/C.mp3</code>)</li>
                <li>Pe√ßas de bateria: <b>bumbo.mp3</b>, <b>caixa.mp3</b>, etc.</li>
                <li>Baixo: <b>bass-A.mp3</b>, <b>bass-AS.mp3</b>, etc.</li>
              </ul>
            </div>
          </div>
          <div class="log mono" id="log"></div>
        </div>
      </div>
    </section>
  </div>

<<script>
  // =============================
  // Jam on ‚Äì Playback Personalizado
  // =============================
  const ui = {
    play: document.getElementById('btnPlay'),
    pause: document.getElementById('btnPause'),
    stop: document.getElementById('btnStop'),
    save: document.getElementById('btnSave'),
    muteBass: document.getElementById('muteBass'),
    muteDrums: document.getElementById('muteDrums'),
    muteClean: document.getElementById('muteClean'),
    muteDist: document.getElementById('muteDist'),
    bpm: document.getElementById('bpm'),
    meter: document.getElementById('meter'),
    log: document.getElementById('log'),
    state: document.getElementById('state'),
    currentChord: document.getElementById('currentChord'),
    chordTimer: document.getElementById('chordTimer'),
    btnRestart: document.getElementById('btnRestart'),
    btnPrev: document.getElementById('btnPrev'),
  };

  const audio = {
    ctx: null,
    master: null,
    mix: null,
    drumGain: null,
    bassGain: null,
    cleanGain: null,
    distGain: null,
    schedulerTimer: null,
    lookahead: 0.1,
    scheduleHorizon: 0.25,
  };

  const PITCHES = ['A','AS','B','C','CS','D','DS','E','F','FS','G','GS'];

  const PITCH_TO_NAME = {
    'A': 'A',   'AS': 'A#',
    'B': 'B',
    'C': 'C',   'CS': 'C#',
    'D': 'D',   'DS': 'D#',
    'E': 'E',
    'F': 'F',   'FS': 'F#',
    'G': 'G',   'GS': 'G#'
  };

  const NAME_TO_PITCH = {
    'A': 'A',   'A#': 'AS',
    'B': 'B',
    'C': 'C',   'C#': 'CS',
    'D': 'D',   'D#': 'DS',
    'E': 'E',
    'F': 'F',   'F#': 'FS',
    'G': 'G',   'G#': 'GS'
  };

  // Mapeamento de graus para √≠ndices
  const DEGREE_TO_ROOT = {
    1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11
  };

  const DRUMS = {
    bumbo: 'assets/bumbo.mp3',
    caixa: 'assets/caixa.mp3',
    chimbal: 'assets/chimbal.mp3',
    conducao: 'assets/conducao.mp3'
  };

  const BASS_SAMPLES = (() => {
  const octaves = ['', '8', '16'];
  const table = {};

  for (const p of PITCHES) {
    const letter = p[0]; // A, B, C, D, E, F, G
    const isSharp = p.includes('S');

    for (const o of octaves) {
      const key = p + o; // ex: FS, FS8, FS16
      const fileName = o ? `bass-${letter}${o}${isSharp ? 'S' : ''}.mp3` : `bass-${p}.mp3`;
      table[key] = `assets/${fileName}`;
    }
  }

  table['X'] = 'assets/bass-muted.mp3';
  return table;
})();

  BASS_SAMPLES['X'] = 'assets/bass-muted.mp3';

  const PROGRESSIONS = [
    [1, 1, 1, 1, 4, 4, 5, 5, 6, 6],
    [1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5],
    [1, 1, 7, 6, 5, 4, 3, 2, 1, 1, 4, 1],
    [1, 1, 1, 1, 5, 5, 5, 5, 6, 6, 6, 4, 4, 5, 5, 1, 1],
    [1, 1, 1, 1, 4, 4, 5, 5],
    [1, 1, 1, 3, 4, 5, 7, 4],
    [6, 4, 1, 1, 1, 5, 5, 4, 4, 5, 5],
    [1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 4, 4, 4, 4, 1, 1, 1, 1],
    [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 1, 1, 1],
    [4, 4, 4, 4, 5, 5, 6, 6, 1, 1, 1, 1, 3, 4],
    [1, 1, 1, 1, 2, 2, 4, 4, 5, 5],
    [1, 1, 1, 3, 4, 1, 1, 1, 3, 4, 5, 4, 5, 1, 1, 1, 1],
    [4, 4, 4, 4, 5, 5, 5, 5, 3, 3, 3, 3, 6, 6, 2, 5, 1, 5, 1, 1, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 5, 5, 1, 1, 1, 1, 4, 4, 5, 5, 1, 1, 1, 1]
  ];

  const CUSTOM_GROOVES = [
    {
      name: "pop rock 1",
      meter: "4/4",
      drumPattern: [
        "ba - - - ch - - - cch - - - ch - bch - "
      ],
      bassRhythm: [
        "S - - - S - - - S ¬∞ S ¬∞ S ¬∞ S ¬∞"
      ]
    }
  ];

  // Armazenar o √∫ltimo estado para "voltar"
  const lastState = {
    chordProgression: [],
    key: null,
    quality: null,
    currentGroove: null,
    meter: null
  };

  const state = {
    running: false,
    paused: false,
    nextNoteTime: 0,
    meter: '4/4',
    bpm: 100,
    sixteenthDur: 0.15,
    stepIndex: 0,
    pattern: [],
    buffers: { drums: {}, bass: {}, guitar: {} },
    lastBassSrc: null,
    bassPlan: [],
    signatureTag: '',
    key: null,
    keyIdx: 0,
    quality: 'maj',
    chordProgression: [],
    chordDurations: [],
    currentGroove: null,
    currentChordIndex: 0,
    barsInChord: 0,
    bassMode: 'arpejo',
    bassCycleCount: 0,
    recordingTimer: null
  };

  const mute = { bass: false, drums: false, clean: false, dist: false };

  // Fun√ß√µes de scheduler
function startScheduler() {
  stopScheduler();
  audio.schedulerTimer = setInterval(scheduler, audio.lookahead * 1000);
}

function stopScheduler() {
  if (audio.schedulerTimer) {
    clearInterval(audio.schedulerTimer);
    audio.schedulerTimer = null;
  }
}

  function log(msg){ ui.log.textContent += `\n${msg}`; ui.log.scrollTop = ui.log.scrollHeight; }

  function setStatePanel(){
    ui.state.innerHTML = `
      <div>Estilo: <b>${state.signatureTag}</b></div>
      <div>Compasso: <b>${state.meter}</b></div>
      <div>BPM: <b>${state.bpm}</b> (semicolcheia = ${(state.sixteenthDur * 1000).toFixed(0)} ms)</div>
      <div>Tom: <b>${state.key} ${state.quality}</b></div>
      <div>Progress√£o: <b>${state.chordProgression.join('-')}</b></div>
    `;
  }

  async function loadBuffer(url) {
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
      const arrayBuffer = await res.arrayBuffer();
      const audioBuffer = await audio.ctx.decodeAudioData(arrayBuffer);
      return audioBuffer;
    } catch (e) {
      log(`[ERRO] Falha ao carregar: ${url} ‚Üí ${e.message}`);
      return null;
    }
  }

  async function ensureSamples() {
    const essentialDrums = ['bumbo', 'caixa', 'chimbal', 'conducao'];
    const promises = [];

    for (const k of essentialDrums) {
      if (!state.buffers.drums[k] && DRUMS[k]) {
        promises.push(loadBuffer(DRUMS[k]).then(buf => {
          if (buf) state.buffers.drums[k] = buf;
        }));
      }
    }

    for (const [k, url] of Object.entries(BASS_SAMPLES)) {
      if (!state.buffers.bass[k]) {
        promises.push(loadBuffer(url).then(buf => {
          if (buf) state.buffers.bass[k] = buf;
        }));
      }
    }

    await Promise.all(promises);
  }

  function initAudio(){
    if (audio.ctx) return;
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    audio.ctx = ctx;
    audio.master = ctx.createGain();
    audio.master.gain.value = 0.9;

    audio.drumGain = ctx.createGain();
    audio.drumGain.gain.value = 0.85;

    audio.bassGain = ctx.createGain();
    audio.bassGain.gain.value = 0.9;

    audio.cleanGain = ctx.createGain();
    audio.cleanGain.gain.value = 0.8;

    audio.distGain = ctx.createGain();
    audio.distGain.gain.value = 0.8;

    audio.mix = ctx.createMediaStreamDestination();

    audio.drumGain.connect(audio.master);
    audio.bassGain.connect(audio.master);
    audio.cleanGain.connect(audio.master);
    audio.distGain.connect(audio.master);
    audio.master.connect(audio.mix);
    audio.master.connect(ctx.destination);
  }

  function randItem(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
  function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }

  function meterToBeats(meter) {
    const [num, den] = meter.split('/').map(Number);
    return [num, den];
  }

  function playClick(isStrong) {
    const ctx = audio.ctx;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain); gain.connect(audio.drumGain);
    osc.frequency.setValueAtTime(isStrong ? 880 : 440, ctx.currentTime);
    gain.gain.setValueAtTime(0.3, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.08);
    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + 0.08);
  }

  function selectRandomGroove() {
    return randItem(CUSTOM_GROOVES);
  }

  // ‚úÖ Corrigido: usa o nome da pasta com sustenido
  function getRootFolder(chordName) {
    const match = chordName.match(/^[A-G]#?/);
    if (!match) return 'A';
    const name = match[0];
    return NAME_TO_PITCH[name] || 'A'; // Ex: 'F#' ‚Üí 'FS'
  }

  async function playChord(time, note, type, isDistorted) {
  const folder = isDistorted ? 'guitarraDistorcao' : 'guitarraLimpa';
  const rootFolder = note; // ex: FS
  const chordFileName = note + type; // ex: FSm7
  const key = `${folder}_${chordFileName}`;
  const url = `${folder}/${rootFolder}/${chordFileName}.mp3`;

  if (state.buffers.guitar[key]) {
    const src = audio.ctx.createBufferSource();
    const gainNode = isDistorted ? audio.distGain : audio.cleanGain;
    src.buffer = state.buffers.guitar[key];
    src.connect(gainNode);
    src.start(time);
    return;
  }

  log(`[CHORD] Tentando carregar: ${url}`);

  try {
    const buf = await loadBuffer(url);
    if (!buf) throw new Error('Buffer vazio');
    state.buffers.guitar[key] = buf;
    const src = audio.ctx.createBufferSource();
    const gainNode = isDistorted ? audio.distGain : audio.cleanGain;
    src.buffer = buf;
    src.connect(gainNode);
    src.start(time);
  } catch (e) {
    log(`[ERRO] Falha ao carregar: ${url}`);
  }
}

  function getCurrentChord() {
  const chordNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const degree = state.chordProgression[state.currentChordIndex];
  const quality = state.quality;

  const rootOffset = DEGREE_TO_ROOT[degree] || 0;
  const noteIndex = (state.keyIdx + rootOffset) % 12;
  const noteSharp = chordNames[noteIndex]; // ex: "F#"
  const noteWithS = noteSharp.replace('#', 'S'); // "F#" ‚Üí "FS"

  // Tipos de acorde reais usados nos arquivos
  const chordTypes = {
    'maj': ['', '7'],        // C, C7 ‚Äî nunca "maj" no nome
    'min': ['m', 'm7']       // Cm, Cm7
  };

  const chordType = randItem(chordTypes[quality]);
  const fileName = noteWithS + chordType; // ex: FSm7, CS7, A, Am

  return {
    note: noteWithS,
    type: chordType,         // '' ou '7' ou 'm' ou 'm7'
    displayName: noteSharp + (quality === 'maj' ? '' : '') + chordType,
    fileName: fileName
  };
}

 async function preloadCommonChords() {
  const commonTypes = ['', '7', 'm', 'm7']; // ‚úÖ Apenas estes
  const folders = ['guitarraLimpa', 'guitarraDistorcao'];
  const notes = ['A', 'AS', 'B', 'C', 'CS', 'D', 'DS', 'E', 'F', 'FS', 'G', 'GS'];

  const promises = [];
  for (const folder of folders) {
    for (const note of notes) {
      for (const type of commonTypes) {
        const chordName = note + type; // ex: FSm7
        const key = `${folder}_${chordName}`;
        const url = `${folder}/${note}/${chordName}.mp3`;

        if (!state.buffers.guitar[key]) {
          promises.push(
            loadBuffer(url).then(buf => {
              if (buf) {
                state.buffers.guitar[key] = buf;
                log(`[PRELOAD] ‚úîÔ∏è ${chordName}.mp3`);
              }
            })
          );
        }
      }
    }
  }
  await Promise.all(promises);
  log('[PRELOAD] Pr√©-carregamento conclu√≠do.');
}

  function buildBassPlan() {
    const groove = state.currentGroove;
    state.meter = ui.meter.value === 'auto' ? groove.meter : ui.meter.value;
    const [num, den] = meterToBeats(state.meter);
    const sixteenthsPerBar = num * 4;

    const totalBars = groove.drumPattern.length;
    const totalSteps = totalBars * sixteenthsPerBar;

    state.keyIdx = randInt(0, PITCHES.length - 1);
    state.key = PITCHES[state.keyIdx];
    state.quality = randItem(['maj', 'min']);

    const progression = randItem(PROGRESSIONS);
    state.chordProgression = progression;

    const durations = [];
    let current = progression[0], count = 1;
    for (let i = 1; i < progression.length; i++) {
      if (progression[i] === current) count++;
      else { durations.push(count); current = progression[i]; count = 1; }
    }
    durations.push(count);
    state.chordDurations = durations;
    state.currentChordIndex = 0;
    state.barsInChord = 0;
    state.bassMode = 'arpejo';
    state.bassCycleCount = 0;

    // Mapeia acordes para notas reais
    const chordMap = progression.map(degree => {
      const rootOffset = DEGREE_TO_ROOT[degree] || 0;
      const rootIdx = (state.keyIdx + rootOffset) % 12;
      return state.quality === 'maj'
        ? [rootIdx, (rootIdx + 4) % 12, (rootIdx + 7) % 12]
        : [rootIdx, (rootIdx + 3) % 12, (rootIdx + 7) % 12];
    });

    const rhythmLines = groove.bassRhythm.flatMap(line => line.split('|').map(s => s.trim()).filter(Boolean));
    const rhythmPattern = [];
    for (let i = 0; i < totalBars; i++) {
      const line = rhythmLines[i % rhythmLines.length];
      const parts = line.split(/\s+/).filter(Boolean);
      rhythmPattern.push(...parts);
    }

    const plan = [];
    let barsInChord = 0;
    let chordIndex = 0;

    for (let step = 0; step < totalSteps; step++) {
      const sixteenthInBar = step % sixteenthsPerBar;
      if (sixteenthInBar === 0) {
        barsInChord++;
        if (barsInChord >= state.chordDurations[chordIndex]) {
          chordIndex = (chordIndex + 1) % progression.length;
          barsInChord = 0;
        }
      }

      const chordNotes = chordMap[chordIndex];
      const root = PITCHES[chordNotes[0]];
      const third = PITCHES[chordNotes[1]];
      const fifth = PITCHES[chordNotes[2]];

      const rhythm = rhythmPattern[step % rhythmPattern.length];
      let note = '-';

      if (rhythm === 'S') {
        if (state.bassMode === 'tonica') {
          note = root;
        } else {
          note = randItem([root, third, fifth]);
        }
      } else if (rhythm === 'x') {
        note = 'X';
      } else if (rhythm === '¬∞' || rhythm === '¬∫') {
        note = '-';
      }

      plan.push(note);
    }

    state.bassPlan = plan;
    state.signatureTag = groove.name;
    updateChordDisplay();
  }

  function buildDrumPattern() {
    const groove = state.currentGroove;
    const [num, den] = meterToBeats(state.meter);
    const sixteenthsPerBar = num * 4;
    const totalSteps = 16 * sixteenthsPerBar;

    const patternLines = groove.drumPattern.flatMap(line =>
      line.split('|').map(s => s.trim()).filter(Boolean)
    );
    const expandedPattern = [];

    for (let i = 0; i < 16; i++) {
      const line = patternLines[i % patternLines.length];
      const parts = line.split(/\s+/).filter(Boolean);
      expandedPattern.push(...parts);
    }

    const result = [];
    for (let i = 0; i < totalSteps; i++) {
      let cell = expandedPattern[i % expandedPattern.length];
      if (!cell || cell === '-' || cell === '----') {
        result.push('-');
        continue;
      }

      cell = cell
        .replace(/\(bu\s+at\)|\(at\s+bu\)/gi, 'ba')
        .replace(/\(bu\s+ch\)|\(ch\s+bu\)/gi, 'bch')
        .replace(/\(ch\s+ca\)|\(ca\s+ch\)/gi, 'cch')
        .replace(/\(bu\s+co\)|\(co\s+bu\)/gi, 'bc')
        .replace(/\(ca\s+co\)|\(co\s+ca\)/gi, 'cc');

      cell = cell.replace(/\([^)]*\)/g, '').trim();
      if (!cell) {
        result.push('-');
        continue;
      }

      const drumMap = {
        bu: 'bumbo', ca: 'caixa', ch: 'chimbal', cha: 'chimbalAberto', co: 'conducao',
        at: 'ataque', to1: 'tom1', to2: 'tom2', su: 'surdo',
        ba: 'ba', bch: 'bch', cch: 'cch', bc: 'bc', cc: 'cc'
      };

      const pieces = cell.split(/\s+/).filter(Boolean).map(key => drumMap[key]).filter(Boolean);
      result.push(pieces.length ? pieces.join(',') : '-');
    }
    return result;
  }

  function updateChordDisplay() {
  const chordNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const degree = state.chordProgression[state.currentChordIndex];
  const rootOffset = DEGREE_TO_ROOT[degree] || 0;
  const rootIdx = (state.keyIdx + rootOffset) % 12;
  const rootNote = chordNames[rootIdx]; // ex: F#
  const chordType = state.quality === 'maj' ? '' : 'm';
  const currentChord = rootNote + chordType;
  const barsLeft = state.chordDurations[state.currentChordIndex] - state.barsInChord;

  ui.currentChord.textContent = currentChord;
  ui.chordTimer.textContent = `Pr√≥x: ${barsLeft} compasso(s)`;
}

  async function onPlay() {
    if (state.running) { onStop(); setTimeout(onPlay, 100); return; }
    initAudio();
    await ensureSamples();

    state.currentGroove = selectRandomGroove();

    // Salvar estado anterior
    lastState.chordProgression = [...state.chordProgression];
    lastState.key = state.key;
    lastState.quality = state.quality;
    lastState.currentGroove = state.currentGroove;
    lastState.meter = state.meter;

    buildBassPlan();
    state.pattern = buildDrumPattern();
    state.bpm = Number(ui.bpm.value) || 100;
    state.sixteenthDur = (60 / state.bpm) / 4;
    state.stepIndex = 0;
    state.currentChordIndex = 0;
    state.barsInChord = 0;
    state.bassMode = 'arpejo';
    state.bassCycleCount = 0;

    const [num] = meterToBeats(state.meter);
    const quarterDur = 60 / state.bpm;
    const totalClicks = num * 2;
    const playbackStartTime = audio.ctx.currentTime + 0.1 + totalClicks * quarterDur;
    state.nextNoteTime = playbackStartTime;

    for (let i = 0; i < totalClicks; i++) {
      const isStrong = i % num === 0;
      const clickTime = audio.ctx.currentTime + 0.1 + i * quarterDur;
      setTimeout(() => playClick(isStrong), (clickTime - audio.ctx.currentTime) * 1000);
    }

    setTimeout(() => {
      state.running = true;
      startScheduler();
      ui.play.dataset.state = 'on';
      log(`[PLAY] Estilo: ${state.signatureTag} | ${state.meter} @ ${state.bpm} BPM`);
    }, (playbackStartTime - audio.ctx.currentTime) * 1000);

    setStatePanel();
    updateChordDisplay();
  }

  function onPause() {
    if (state.running && !state.paused) {
      audio.ctx.suspend();
      state.paused = true;
      stopScheduler();
      ui.play.textContent = '‚ñ∂Ô∏è Retomar';
    } else if (state.paused) {
      audio.ctx.resume();
      state.paused = false;
      ui.play.textContent = '‚è∏Ô∏è Pause';
      startScheduler();
    }
  }

  async function onStop() {
    stopScheduler();
    stopRecording();

    if (audio.ctx && audio.ctx.state !== 'closed') {
      try { await audio.ctx.close(); } catch (e) {}
    }
    audio.ctx = null;

    state.running = false;
    state.paused = false;
    state.stepIndex = 0;
    state.pattern = [];
    state.bassPlan = [];
    state.currentGroove = null;

    ui.currentChord.textContent = '‚Äî';
    ui.chordTimer.textContent = '‚Äî';

    ui.play.dataset.state = '';
    ui.play.textContent = '‚ñ∂Ô∏è Play';
    log('[STOP] Pronto.');
  }

  function onRestart() {
    if (state.running) {
      onStop();
      setTimeout(onPlay, 100);
    } else {
      onPlay();
    }
  }

  function onPrev() {
    if (!lastState.currentGroove) return log('[INFO] Nenhum playback anterior.');

    onStop();
    setTimeout(() => {
      state.currentGroove = lastState.currentGroove;
      state.key = lastState.key;
      state.keyIdx = PITCHES.indexOf(lastState.key);
      state.quality = lastState.quality;
      state.chordProgression = [...lastState.chordProgression];
      state.meter = lastState.meter;

      buildBassPlan();
      state.pattern = buildDrumPattern();
      state.bpm = Number(ui.bpm.value) || 100;
      state.sixteenthDur = (60 / state.bpm) / 4;
      state.stepIndex = 0;
      state.currentChordIndex = 0;
      state.barsInChord = 0;

      initAudio();
      ensureSamples();

      const [num] = meterToBeats(state.meter);
      const quarterDur = 60 / state.bpm;
      const totalClicks = num * 2;
      const playbackStartTime = audio.ctx.currentTime + 0.1 + totalClicks * quarterDur;
      state.nextNoteTime = playbackStartTime;

      for (let i = 0; i < totalClicks; i++) {
        const isStrong = i % num === 0;
        const clickTime = audio.ctx.currentTime + 0.1 + i * quarterDur;
        setTimeout(() => playClick(isStrong), (clickTime - audio.ctx.currentTime) * 1000);
      }

      setTimeout(() => {
        state.running = true;
        startScheduler();
        log('[PLAY] Playback anterior reproduzido.');
      }, (playbackStartTime - audio.ctx.currentTime) * 1000);

      setStatePanel();
      updateChordDisplay();
    }, 100);
  }

  function onSave() {
    if (!audio.ctx) return;
    startRecording();
  }

  // Adicione estes bot√µes no HTML
  ui.play.addEventListener('click', onPlay);
  ui.pause.addEventListener('click', onPause);
  ui.stop.addEventListener('click', onStop);
  ui.save.addEventListener('click', onSave);
  ui.btnRestart.addEventListener('click', onRestart);
  ui.btnPrev.addEventListener('click', onPrev);

  window.addEventListener('load', () => {
    log('üîß Pr√©-carregando acordes...');
    initAudio();
    preloadCommonChords();
  });
</script>
</body>
</html>