<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.1/lame.min.js"></script>
  <meta charset="UTF-8" />
  <title>Jam On ‚Äì Playback Aleat√≥rio</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      background: #121212;
      color: #e0e0e0;
      margin: 0;
      padding: 20px;
    }
    header {
      text-align: center;
      margin-bottom: 20px;
    }
    h1 {
      color: #5eead4;
      font-size: 1.8em;
      margin: 0;
    }
    .pill {
      display: inline-block;
      background: #333;
      color: #aaa;
      font-size: 0.75em;
      padding: 4px 10px;
      border-radius: 12px;
    }
    .card {
      max-width: 800px;
      margin: 0 auto;
      background: #1e1e1e;
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    .chord-display {
      text-align: center;
      margin: 20px 0;
    }
    .chord-name {
      font-size: 3em;
      color: #5eead4;
      margin: 0;
      font-weight: bold;
    }
    #chordTimer {
      font-size: 1.1em;
      color: #aaa;
    }
    #chordProgression {
      margin-top: 12px;
      font-family: monospace;
      font-size: 1.1em;
      white-space: nowrap;
      overflow-x: auto;
      padding: 8px 0;
    }
    .chord-item {
      display: inline-block;
      padding: 6px 10px;
      margin: 0 4px;
      border-radius: 6px;
      background: #333;
      transition: background 0.3s;
    }
    .chord-item.current {
      background: #5eead4;
      color: #121212;
      font-weight: bold;
    }
    .controls {
      display: grid;
      gap: 15px;
    }
    .btn-row {
      display: flex;
      justify-content: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    button {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      font-size: 1em;
    }
    button.primary {
      background: #5eead4;
      color: #121212;
    }
    button.danger {
      background: #f44336;
      color: white;
    }
    button:hover {
      opacity: 0.9;
    }
    .mute-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      margin: 10px 0;
    }
    .mute-buttons button {
      padding: 8px 14px;
      font-size: 0.9em;
    }
    .mute-buttons button.muted {
      opacity: 0.5;
    }
    .row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .row label {
      width: 50px;
      font-size: 0.9em;
    }
    input[type="number"], select {
      width: 60px;
      padding: 6px;
      border-radius: 4px;
      background: #333;
      color: white;
      border: 1px solid #555;
    }
    .slider-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .slider-row label {
      width: 60px;
      font-size: 0.8em;
    }
    input[type="range"] {
      width: 140px;
    }
    .slider-value {
      width: 35px;
      font-size: 0.8em;
    }
    .panel {
      background: #222;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
    }
    .mono {
      font-family: monospace;
      white-space: pre;
    }
    .melody-panel {
      margin-top: 20px;
    }
    .melody-toolbar {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 10px;
    }
    .melody-block {
      border: 1px solid #444;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 12px;
      background: #222;
    }
    .melody-caption {
      font-size: 0.9em;
      color: #ccc;
      margin-bottom: 6px;
    }
    .melody-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85em;
    }
    .melody-table th, .melody-table td {
      border: 1px solid #555;
      padding: 2px;
    }
    .melody-table input {
      width: 100%;
      padding: 4px;
      text-align: center;
      background: #333;
      border: 1px solid #555;
      color: white;
      border-radius: 4px;
    }
    .line-label {
      font-size: 0.8em;
      color: #aaa;
    }
    .instructions {
      font-size: 0.85em;
      color: #aaa;
      margin-top: 8px;
      text-align: center;
    }

    /* === ESTILOS PARA MOBILE === */
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      .card {
        padding: 15px;
        border-radius: 12px;
      }
      h1 {
        font-size: 1.5em;
      }
      .chord-name {
        font-size: 2em;
      }
      button {
        padding: 14px 22px; /* Aumentado para toque */
        font-size: 1em;
      }
      .row label {
        width: 80px;
        font-size: 0.9em;
      }
      input[type="number"], select {
        width: 70px;
        font-size: 0.9em;
        padding: 10px; /* Aumentado para toque */
      }
      .slider-row label {
        width: 60px;
        font-size: 0.8em;
      }
      input[type="range"] {
        width: 140px;
      }
      .slider-value {
        width: 35px;
        font-size: 0.8em;
      }
      .melody-table {
        font-size: 0.9em; /* Aumentado para melhor leitura */
      }
      .melody-table input {
        height: 40px; /* Aumentado para toque */
        font-size: 0.9em;
        padding: 8px; /* Aumentado para toque */
      }
      .melody-caption {
        font-size: 0.85em;
      }
    }

    /* === ESTILOS DO PICKER DE N√öMEROS === */
    #numberPicker {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background: #1e1e1e;
      border-top: 2px solid #5eead4;
      padding: 15px;
      box-shadow: 0 -4px 10px rgba(0,0,0,0.5);
      z-index: 1000;
      animation: slideUp 0.3s ease-out;
    }
    #numberGrid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }
    .number-btn {
      padding: 15px;
      font-size: 1.1em;
      background: #333;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.1s ease;
    }
    .number-btn:hover {
      background: #444;
    }
    .number-btn:active {
      transform: scale(0.95);
      background: #5eead4;
      color: #121212;
    }
    .close-btn {
      /* - NOVO: Ocupa todas as 4 colunas - */
      grid-column: span 4;
      background: #f44336;
      color: white;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <header>
    <h1>Jam On ‚Äì Playback Aleat√≥rio</h1>
    <div class="pill">Cada pulso do BPM = sem√≠nima</div>
  </header>

  <div class="chord-display">
    <h2 class="chord-name" id="currentChord">‚Äî</h2>
    <div id="chordTimer">‚Äî</div>
    <div id="chordProgression"></div>
  </div>

  <div class="card">
    <div class="controls">
      <div class="btn-row">
        <button id="btnPlay" class="primary">‚ñ∂ Play</button>
        <button id="btnPause">‚è∏ Pause</button>
        <button id="btnStop" class="danger">‚èπ Stop</button>
        <button id="btnSaveWAV" class="primary">üíæ Salvar como WAV</button>
      </div>

      <div class="mute-buttons">
        <button id="muteBass" data-mute="off">üé∏ Baixo</button>
        <button id="muteDrums" data-mute="off">ü•Å Bateria</button>
        <button id="muteClean" data-mute="off">üé∏ Limpa</button>
        <button id="muteDist" data-mute="off">üî• Distor√ß√£o</button>
      </div>

      <div class="row">
        <label>BPM</label>
        <input id="bpm" type="number" min="40" max="220" value="100">
      </div>

      <div class="row">
        <label>Assinatura</label>
        <select id="meter">
          <option value="auto" selected>aleat√≥ria</option>
          <option>2/4</option>
          <option>3/4</option>
          <option>4/4</option>
          <option>5/4</option>
          <option>6/4</option>
          <option>7/4</option>
        </select>
      </div>

      <div class="row">
        <label>Melodia</label>
        <select id="melodyInstrument">
          <option value="dist">Guitarra Distorcida</option>
          <option value="piano">Piano/String</option>
          <option value="baixo">Baixo</option>
          <option value="sax">Sax</option>
          <!-- Novos Instrumentos -->
          <option value="acordeon">Acordeon</option>
          <option value="sinos">Sinos</option>
        </select>
      </div>

      <div class="slider-row">
        <label>Vol Baixo</label>
        <input type="range" id="volBass" min="0" max="1" step="0.01" value="0.45">
        <span id="volBassLabel">45%</span>
      </div>
      <div class="slider-row">
        <label>Vol Bater</label>
        <input type="range" id="volDrums" min="0" max="1" step="0.01" value="0.60">
        <span id="volDrumsLabel">60%</span>
      </div>
      <div class="slider-row">
        <label>Vol Limpa</label>
        <input type="range" id="volClean" min="0" max="1" step="0.01" value="0.45">
        <span id="volCleanLabel">45%</span>
      </div>
      <div class="slider-row">
        <label>Vol Dist</label>
        <input type="range" id="volDist" min="0" max="1" step="0.01" value="0.35">
        <span id="volDistLabel">35%</span>
      </div>
      <div class="slider-row">
        <label>Vol Melod</label>
        <input type="range" id="volMelody" min="0" max="1" step="0.01" value="0.50">
        <span id="volMelodyLabel">50%</span>
      </div>
    </div>

    <div class="panel melody-panel">
      <h3>üé∏ Melodia Adaptativa</h3>
      <div class="melody-toolbar">
        <button id="btnMelodyAdd" class="primary">‚ûï Adicionar Bloco</button>
        <button id="btnMelodyClear" class="danger">üßπ Limpar Blocos</button>
        <span style="font-size: 0.9em; color: #aaa;">Notas se estendem at√© pr√≥xima nota ou "x"</span>
      </div>
      <div class="instructions">Digite n√∫meros (1-49) para notas, "x" para pausa, ou deixe vazio para continuar nota anterior</div>
      <div id="melodyBlocks"></div>
    </div>

    <div class="panel">
      <h3>Estado Atual</h3>
      <div class="mono" id="state">Parado</div>
    </div>
  </div>

  <!-- Picker de N√∫meros para Mobile -->
  <div id="numberPicker">
    <div id="numberGrid"></div>
  </div>

  <script>
    function transposeDown3Semitones(note) {
      const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const index = notes.indexOf(note);
      if (index === -1) return note;
      return notes[(index - 3 + 12) % 12];
    }

    // Fun√ß√£o para detectar se √© um dispositivo m√≥vel
    function isMobileDevice() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    const ui = {
      play: document.getElementById('btnPlay'),
      pause: document.getElementById('btnPause'),
      stop: document.getElementById('btnStop'),
      muteBass: document.getElementById('muteBass'),
      muteDrums: document.getElementById('muteDrums'),
      muteClean: document.getElementById('muteClean'),
      muteDist: document.getElementById('muteDist'),
      bpm: document.getElementById('bpm'),
      meter: document.getElementById('meter'),
      state: document.getElementById('state'),
      currentChord: document.getElementById('currentChord'),
      chordTimer: document.getElementById('chordTimer'),
      volBass: document.getElementById('volBass'),
      volDrums: document.getElementById('volDrums'),
      volClean: document.getElementById('volClean'),
      volDist: document.getElementById('volDist'),
      volMelody: document.getElementById('volMelody'),
      volBassLabel: document.getElementById('volBassLabel'),
      volDrumsLabel: document.getElementById('volDrumsLabel'),
      volCleanLabel: document.getElementById('volCleanLabel'),
      volDistLabel: document.getElementById('volDistLabel'),
      volMelodyLabel: document.getElementById('volMelodyLabel'),
      melodyBlocks: document.getElementById('melodyBlocks'),
      btnMelodyAdd: document.getElementById('btnMelodyAdd'),
      btnMelodyClear: document.getElementById('btnMelodyClear'),
      btnSaveWAV: document.getElementById('btnSaveWAV'),
      numberPicker: document.getElementById('numberPicker'),
      numberGrid: document.getElementById('numberGrid'),
      activeInput: null
    };

    const PITCHES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    const CHORD_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    const DRUMS = {
      bu: 'bumbo',
      ca: 'caixa',
      ch: 'chimbal',
      ba: 'bumbo-ataque',
      cch: 'caixa-chimbal',
      co: 'conducao',
      bco: 'bumbo-conducao',
      cco: 'caixa-conducao',
      to1: 'tom-1',
      to2: 'tom-2',
      su: 'surdo',
      bch: 'bumbo-chimbal'
    };

    // === CRIA√á√ÉO DOS SAMPLES COM SUSTENIDOS NO FINAL (C8S) ===
    const BASS_SAMPLES = {};
    for (const p of PITCHES) {
      BASS_SAMPLES[p] = `assets/bass-${p}.mp3`;
      if (p.endsWith('S')) {
        const base = p.replace('S', '');
        BASS_SAMPLES[base + '8S'] = `assets/bass-${base}8S.mp3`;
      } else {
        BASS_SAMPLES[p + '8'] = `assets/bass-${p}8.mp3`;
      }
    }

    const DEGREE_TO_ROOT = {
      1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11
    };

    const STYLE_PROGRESSIONS = {
      Rock: [
        [1,4,5,4], [1,6,4,5], [1,5,6,4], [2,5,1,1], [1,3,4,5], [1,4,1,4,5,6,5,7]
      ],
      Rock2: [
        [1,5,6,4], [1,6,2,5], [1,3,4,5], [1,4,5,1]
      ],
      Rock3: [
        [1,4,5,1], [1,6,4,5], [2,5,1,5]
      ],
      Rock4: [
        [1,5,6,3,4,1,4,5], [1,4,5,6,3,5,4,5]
      ],
      Rock_Progressivo: [
        [1,4,5,1,4,5,1,4,5,1,4,5], [1,3,4,5,6,5,4,3]
      ],
      Rock_Progressivo2: [
        [1,4,5,6,3,5,4,5], [1,4,1,4,5,6,5,7]
      ],
      Rock_Progressivo3: [
        [1,4,5,1,5,7], [1,3,4,5,2,5]
      ],
      Rock_Progressivo4: [
        [4,5,1,1,4,5,7,5], [1,4,1,4,5,6,5,7], [1,4,5,6,3,5,4,5]
      ],
      Rock_Progressivo5: [
        [4,5,1,1,4,5,7], [1,4,1,4,5,6,5], [1,4,5,6,3,5,4]
      ],
      Rock_Progressivo6: [
        [1,4,5,6,3,5], [1,4,1,4,5,6,5]
      ],
      Rock_Progressivo7: [
        [4,5,1,1], [1,4,5,1]
      ],
      Blues: [
        [1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]
      ],
      Blues2: [
        [1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]
      ],
      Blues3: [
        [1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,7]
      ],
      Blues4: [
        [1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]
      ],
      Blues5: [
        [1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,7]
      ],
      Blues6: [
        [1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]
      ],
      Blues7: [
        [1,4,5,4,1,4,5,4,1,4,5,4], [1,4,5,1]
      ],
      Forr√≥: [
        [1,5,1,5,4,5,4,5]
      ],
      Samba: [
        [2,5,1,1], [1,4,5,1]
      ],
      Metal: [
        [1, 3, 5, 6, 1, 2, 3, 4], [1, 3, 4, 5], [2, 5, 1, 5]
      ],
      Metal2: [
        [1, 3, 5, 4, 1, 2, 3, 4], [1, 3, 4, 5], [2, 5, 1, 5]
      ],
      Metal3: [
        [1, 3, 5, 3, 1, 2, 4, 5], [1, 3, 4, 5], [2, 5, 1, 5]
      ],
      Jazz: [
        [1,2,5,1], [2,5,1,4], [3,6,2,5]
      ]
    };

    // === GROOVES ===
    const ALL_GROOVES = [
      { name: "Rock", meter: "4/4", drumPattern: ["bch - ch - cch - ch - bch - ch - cch - ch bu"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8] },
      { name: "Rock2", meter: "4/4", drumPattern: ["bch - ch - cch - ch - bch - ch - cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 1, 1, 5] },
      { name: "Rock3", meter: "4/4", drumPattern: ["bch - ch bu cch bu ch - bch - ch - cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo x bo x bo x"], bassScale: [1, 1, 1, 1] },
      { name: "Rock4", meter: "4/4", drumPattern: ["ba - co - cco - co - bco - co - cco bu bco bu"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [8, 8, 1, 1] },
      { name: "Rock5", meter: "4/4", drumPattern: ["bch - ch - cch - ch - bch - co - cco - co -"], bassRhythm: ["bo - bo - bo bo bo bo bo - bo - bo - bo -"], bassScale: [1, 1, 1, 1] },
      { name: "Rock6", meter: "4/4", drumPattern: ["bco co co co cco co co co bco co co co cco co co co"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8, 8, 8] },
      { name: "Rock7", meter: "4/4", drumPattern: ["bch - ch - cch - ch - bch - ch - cch - ch bu bch - ch - cch - ch - bch - ch bu"], bassRhythm: ["bo - - - - - - - bo - - - - - - bo - - bo bo bo bo bo bo bo bo bo bo"], bassScale: [1, 1, 1, 3, 5, 8, 3, 5, 8, 3, 5, 8, 5] },
      { name: "Rock_Progressivo", meter: "7/4", drumPattern: ["bch - ch - cch - ch - bch - ch - cch - ch bu bch - ch - cch - ch - bch - ch bu"], bassRhythm: ["bo - - - - - - - bo - - - - - - bo - - bo bo bo bo bo bo bo bo bo bo"], bassScale: [1, 1, 1, 3, 5, 8, 3, 5, 8, 3, 5, 8, 5] },
      { name: "Rock_Progressivo2", meter: "5/4", drumPattern: ["bch - ch - cch - ch - bch - ch - cch - ch -"], bassRhythm: ["bo - - - - - - - bo - - - - - - bo - - bo bo bo bo bo bo bo bo bo bo"], bassScale: [1, 3, 5, 8] },
      { name: "Rock_Progressivo3", meter: "6/4", drumPattern: ["bch - ch - cch - ch - bch - ch - cch - ch - bch - ch - cch - ch -"], bassRhythm: ["bo - - - - - - - bo - - - - - - bo - - bo bo bo bo bo bo bo bo bo bo"], bassScale: [1, 3, 5, 8, 8, 8] },
      { name: "Rock_Progressivo4", meter: "4/4", drumPattern: ["ba - ch bu cch - ch - bch - ch bu cch - ch bu"], bassRhythm: ["bo - - bo - - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8] },
      { name: "Rock_Progressivo5", meter: "7/4", drumPattern: ["ba - co - cco - co - bco - co bu cco - co bu bch bu co - cch - ch - bch - ch bu"], bassRhythm: ["bo - - bo bo - - - bo - - bo bo - - bo - - bo bo - - bo bo - - bo bo"], bassScale: [1, 3, 5, 8] },
      { name: "Rock_Progressivo6", meter: "3/4", drumPattern: ["bch - - - ch - - bu cch - - -"], bassRhythm: ["bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8, 8, 8] },
      { name: "Rock_Progressivo7", meter: "4/4", drumPattern: ["bco co cch to1 cch - ch - bch - ch cch bu bu ch bu"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 1, 1, 1] },
      { name: "Blues", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 7, 8, 7, 5, 3] },
      { name: "Blues2", meter: "4/4", drumPattern: ["bch - - - cch - - - bch - - - cch - - -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8] },
      { name: "Blues3", meter: "4/4", drumPattern: ["bch - - bu cch - ch - ch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 7] },
      { name: "Blues4", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [8, 7, 5, 3, 1, 3, 5, 7] },
      { name: "Blues5", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 7, 1, 1, 1, 1] },
      { name: "Blues6", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8, 8, 8, 8, 8] },
      { name: "Blues7", meter: "4/4", drumPattern: ["bch - - bu cch - ch - bch - - bu cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 8, 7, 5, 3, 5] },
      { name: "Forr√≥", meter: "2/4", drumPattern: ["su - su - su - su -"], bassRhythm: ["bo - bo - bo - bo -"], bassScale: [1, 5] },
      { name: "Samba", meter: "2/4", drumPattern: ["bch - ch bu bch - ch bu"], bassRhythm: ["bo - - x bo - - x"], bassScale: [8, 5] },
      { name: "Jazz", meter: "4/4", drumPattern: ["bch - ch - cch - ch - bch - ch - cch - ch -"], bassRhythm: ["bo - bo - bo - bo - bo - bo - bo - bo -"], bassScale: [1, 3, 5, 7] },
      { name: "Metal", meter: "4/4", drumPattern: ["bch bu bch - cch - ch - bch bu ch bu cch - ch -"], bassRhythm: ["bo bo bo - - - - - bo bo - bo - - - -"] },
      { name: "Metal2", meter: "4/4", drumPattern: ["bch bu cch - bu bu cch - bu bu cch - bu bu cch -"], bassRhythm: ["bo bo bo - bo bo bo - bo bo bo - bo bo bo -"] },
      { name: "Metal3", meter: "4/4", drumPattern: ["bch bu bch - cch - ch - bch bu ch bu cch - ch -"], bassRhythm: ["bo bo bo - - - - - bo bo - bo - - - -"] },
      // Groove Metal4 ATUALIZADO com guitarRhythm
      { name: "Metal4", meter: "4/4", drumPattern: ["bch bu cch - bu bu cch - bu bu cch - bu bu cch -"], bassRhythm: ["bo bo bo - bo bo bo - bo bo bo - bo bo bo -"], guitarRhythm: ["ab - ab - so - - - ab - ab - so - - -"] }
    ];

    const state = {
      running: false,
      paused: false,
      bpm: 100,
      sixteenthDur: 60 / 100 / 4,
      stepIndex: 0,
      nextNoteTime: 0,
      currentGroove: null,
      signatureTag: '',
      meter: '4/4',
      keyIdx: 0,
      key: 'C',
      quality: 'maj',
      chordProgression: [],
      chordPlan: [],
      bassPlan: [],
      drumSeq: [],
      currentChordIndex: 0,
      barsInChord: 0,
      chordDurations: [],
      melodyPlan: [],
      melodyBlocks: [],
      lastBassSource: null,
      lastDistSource: null,
      lastCleanSource: null,
      lastMelodySource: null,
      lastMelodyGain: null,
      lastMelodyNote: null,
      buffers: {
        drums: {},
        bass: {},
        guitar: {},
        melody: {}
      }
    };

    const audio = {
      ctx: null,
      master: null,
      mix: null,
      drumGain: null,
      bassGain: null,
      cleanGain: null,
      distGain: null,
      melodyGain: null
    };

    let initPromise = null;

    function parsePattern(patternText) {
      const result = { intro: [], loop: [] };
      const introMatch = patternText.match(/intro:\s*\(([^)]+)\)/);
      const loopMatch = patternText.match(/loop:\s*\(([^)]+)\)/);
      if (introMatch) result.intro = introMatch[1].trim().split(/\s+/).filter(s => s);
      if (loopMatch) result.loop = loopMatch[1].trim().split(/\s+/).filter(s => s);
      if (!introMatch && !loopMatch) result.loop = patternText.trim().split(/\s+/).filter(s => s);
      if (!result.loop.length) result.loop = result.intro.slice();
      return result;
    }

    function playClickAtTime(time, isStrong) {
      const ctx = audio.ctx;
      const osc = ctx.createOscillator();
      const g = ctx.createGain();
      osc.connect(g);
      g.connect(audio.drumGain);
      osc.frequency.value = isStrong ? 880 : 440;
      g.gain.setValueAtTime(0.0, time);
      g.gain.linearRampToValueAtTime(isStrong ? 0.18 : 0.09, time + 0.002);
      g.gain.linearRampToValueAtTime(0.0, time + 0.06);
      osc.start(time);
      osc.stop(time + 0.07);
    }

    async function onPlay() {
      if (!audio.ctx) await initAudio();
      if (state.running && !state.paused) return;

      state.bpm = Number(ui.bpm.value) || 100;
      state.sixteenthDur = 60 / state.bpm / 4;

      try {
        await buildBassAndChordPlan();
      } catch (e) {
        console.error('Erro ao gerar plano:', e);
      }

      try {
        buildMelodyPlanFromBlocks();
        await ensureMelodySamplesNeeded();
      } catch (e) {
        console.error('Erro na melodia:', e);
      }

      if (state.paused) {
        state.paused = false;
        return;
      }

      state.running = false;
      state.stepIndex = 0;
      state.nextNoteTime = audio.ctx.currentTime + 0.05;

      const beats = meterToBeats(state.meter);
      const quarterDur = 60 / state.bpm;
      const startTime = audio.ctx.currentTime + 0.05;

      for (let i = 0; i < beats; i++) {
        const t = startTime + i * quarterDur;
        const isStrong = (i % beats) === 0;
        playClickAtTime(t, isStrong);
      }

      const schedulerStartTime = startTime + beats * quarterDur;

      setTimeout(() => {
        state.running = true;
        state.nextNoteTime = schedulerStartTime;
        startScheduler();
      }, Math.max(0, (schedulerStartTime - audio.ctx.currentTime) * 1000 + 10));
    }

    function onPause() {
      if (state.running && !state.paused) state.paused = true;
    }

    function onStop() {
      state.running = false;
      state.paused = false;
      ui.currentChord.textContent = '‚Äî';
      ui.chordTimer.textContent = '‚Äî';
      if (state.lastBassSource) state.lastBassSource.stop(0);
      if (state.lastDistSource) state.lastDistSource.stop(0);
      if (state.lastMelodySource) state.lastMelodySource.stop(0);
      state.lastBassSource = null;
      state.lastDistSource = null;
      state.lastMelodySource = null;
      state.lastMelodyGain = null;
      state.lastMelodyNote = null;
    }

    function meterToBeats(meter) {
      const parts = meter.split('/');
      return parseInt(parts[0], 10);
    }

    function toggleMute(key, button) {
      const muteState = button.getAttribute('data-mute') === 'off';
      button.setAttribute('data-mute', muteState ? 'on' : 'off');
      button.classList.toggle('muted', muteState);
    }

    async function initAudio() {
      if (audio.ctx) return;
      if (initPromise) return initPromise;

      initPromise = (async () => {
        audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
        audio.master = audio.ctx.createGain();
        audio.mix = audio.ctx.createGain();
        audio.drumGain = audio.ctx.createGain();
        audio.bassGain = audio.ctx.createGain();
        audio.cleanGain = audio.ctx.createGain();
        audio.distGain = audio.ctx.createGain();
        audio.melodyGain = audio.ctx.createGain();

        audio.melodyGain.gain.value = 0.50; // Valor inicial
        audio.melodyGain.connect(audio.master); // Conecta ao mix principal

        audio.master.gain.value = 0.9;
        audio.drumGain.gain.value = 0.6;
        audio.bassGain.gain.value = 0.45;
        audio.cleanGain.gain.value = 0.45;
        audio.distGain.gain.value = 0.35;

        audio.master.connect(audio.mix);
        audio.mix.connect(audio.ctx.destination);

        audio.drumGain.connect(audio.master);
        audio.bassGain.connect(audio.master);
        audio.cleanGain.connect(audio.master);
        audio.distGain.connect(audio.master);

        if (!state.buffers.melody) state.buffers.melody = {};

        await ensureBasicSamples();

        // Conecta todos os sliders √† fun√ß√£o de atualiza√ß√£o
        ui.volBass.addEventListener('input', updateVolume);
        ui.volDrums.addEventListener('input', updateVolume);
        ui.volClean.addEventListener('input', updateVolume);
        ui.volDist.addEventListener('input', updateVolume);
        ui.volMelody.addEventListener('input', updateVolume);

        // Aplica os valores iniciais dos sliders
        updateVolume();
      })();

      return initPromise;
    }

    async function loadBuffer(url) {
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const arrayBuffer = await res.arrayBuffer();
        return await audio.ctx.decodeAudioData(arrayBuffer);
      } catch (e) {
        console.warn(`Erro ao carregar: ${url}`);
        return null;
      }
    }

    async function ensureBasicSamples() {
      const promises = [];
      for (const [key, name] of Object.entries(DRUMS)) {
        const url = `assets/${name}.mp3`;
        if (!state.buffers.drums[key]) {
          promises.push(loadBuffer(url).then(buf => { if (buf) state.buffers.drums[key] = buf; }));
        }
      }
      for (const [key, url] of Object.entries(BASS_SAMPLES)) {
        if (!state.buffers.bass[key]) {
          promises.push(loadBuffer(url).then(buf => { if (buf) state.buffers.bass[key] = buf; }));
        }
      }
      await Promise.all(promises);
    }

    function expandRhythm(patternArray, totalSteps) {
      const joined = patternArray.join(' ').replace(/\s+/g, ' ').trim();
      const tokens = joined.split(/\s+/).filter(t => t);
      const out = [];
      let i = 0;
      while (out.length < totalSteps) {
        for (const token of tokens) {
          if (out.length >= totalSteps) break;
          out.push(token);
        }
        if (i++ > 1000) break;
      }
      return out.slice(0, totalSteps);
    }

    async function buildBassAndChordPlan() {
      state.currentGroove = ALL_GROOVES[Math.floor(Math.random() * ALL_GROOVES.length)];
      state.signatureTag = state.currentGroove.name;
      state.meter = ui.meter.value === 'auto' ? state.currentGroove.meter : ui.meter.value;
      if (state.currentGroove.name === "Samba") {
        ui.bpm.value = 70;
        state.bpm = 70;
      } else {
        state.bpm = Number(ui.bpm.value) || 100;
      }
      const beats = meterToBeats(state.meter);
      const sixteenthsPerBar = beats * 4;
      state.keyIdx = Math.floor(Math.random() * PITCHES.length);
      state.key = PITCHES[state.keyIdx];
      // Campo harm√¥nico √© sempre maior, como solicitado
      state.quality = 'maj';

      const grooveName = state.currentGroove.name;
      let styleKey = "Rock";
      if (grooveName.includes("Samba")) styleKey = "Samba";
      else if (grooveName.includes("Jazz")) styleKey = "Jazz";
      else if (grooveName.includes("Forr√≥")) styleKey = "Forr√≥";
      else if (grooveName.includes("Metal")) styleKey = "Metal";
      else if (grooveName.includes("Blues")) styleKey = "Blues";

      const progressions = STYLE_PROGRESSIONS[styleKey] || STYLE_PROGRESSIONS.Rock;

      // --- NOVA L√ìGICA AQUI ---
      // Seleciona uma progress√£o que N√ÉO comece com o grau 7 (diminuto)
      let availableProgressions = progressions.filter(prog => prog[0] !== 7);
      // Se todas as progress√µes come√ßarem com 7 (improv√°vel), usa a lista original como fallback
      if (availableProgressions.length === 0) {
        availableProgressions = progressions;
      }
      state.chordProgression = availableProgressions[Math.floor(Math.random() * availableProgressions.length)];

      const totalBars = Math.min(state.chordProgression.length, 64);
      const totalSteps = sixteenthsPerBar * totalBars;

      const rhythm = expandRhythm(state.currentGroove.bassRhythm, totalSteps);

      const bassPlan = [];
      const chordPlan = [];

      function getBassNotesFromScale(degree, scale, quality) {
        if (scale === "chromatic") {
          const rootIdx = (state.keyIdx + DEGREE_TO_ROOT[degree]) % 12;
          const rootNote = PITCHES[rootIdx];
          const octave = 8;
          return Array(8).fill().map((_, i) => {
            const noteIdx = (rootIdx - i + 12) % 12;
            const p = PITCHES[noteIdx];
            return p.endsWith('S') ? `${p.replace('S', '')}${octave}S` : `${p}${octave}`;
          });
        }
        if (Array.isArray(scale)) {
          const rootIdx = (state.keyIdx + DEGREE_TO_ROOT[degree]) % 12;
          return scale.map(interval => {
            const intervalOffset = DEGREE_TO_ROOT[interval] || 0;
            const noteIdx = (rootIdx + intervalOffset) % 12;
            const noteName = PITCHES[noteIdx];
            if (interval === 1) return noteName;
            return noteName.endsWith('S') ? `${noteName.replace('S', '')}8S` : `${noteName}8`;
          });
        }
        return [PITCHES[(state.keyIdx + DEGREE_TO_ROOT[degree]) % 12]];
      }

      // --- NOVA L√ìGICA AQUI ---
      // Determina a varia√ß√£o √∫nica para toda a progress√£o
      let globalChordVariation = '';
      if (styleKey === "Blues") {
        // Para Blues, for√ßa todos os acordes a serem s√©tima
        globalChordVariation = '7';
      } else {
        // Para outros estilos, sorteia UMA varia√ß√£o para toda a progress√£o
        const allVariations = ['', '11', '13', '4', '45+', '5', '5+', '6', '7', '75+', '9', '95+', 'm', 'm4', 'm5', 'm5+', 'm6', 'm7', 'm75+', 'm79', 'm9', 'dim'];
        globalChordVariation = allVariations[Math.floor(Math.random() * allVariations.length)];
      }

      for (let bar = 0; bar < totalBars; bar++) {
        const degree = state.chordProgression[bar];
        const rootOffset = DEGREE_TO_ROOT[degree] || 0;
        const rootIdx = (state.keyIdx + rootOffset) % 12;
        const rootNote = PITCHES[rootIdx];

        // Define o tipo de acorde baseado na l√≥gica do campo harm√¥nico maior: I-maj, II-min, III-min, IV-maj, V-maj, VI-min, VII-dim
        let chordType = '';
        // --- APLICA A VARIA√á√ÉO GLOBAL ---
        if (styleKey === "Blues") {
          // No Blues, todos s√£o 7, independente do grau
          chordType = globalChordVariation;
        } else {
          // Em outros estilos, aplica a varia√ß√£o global, mas respeita a natureza do grau
          switch(degree) {
            case 1:
            case 4:
            case 5:
              // Acordes maiores
              // Usa a varia√ß√£o global apenas se for compat√≠vel com acorde maior
              if (globalChordVariation === '' || globalChordVariation.startsWith('m') === false) {
                chordType = globalChordVariation;
              } else {
                // Se a varia√ß√£o global √© menor, for√ßa a ser maior (vazio ou 7, por exemplo)
                chordType = '';
              }
              break;
            case 2:
            case 3:
            case 6:
              // Acordes menores
              // Usa a varia√ß√£o global apenas se for compat√≠vel com acorde menor
              if (globalChordVariation.startsWith('m') || globalChordVariation === 'dim') {
                chordType = globalChordVariation;
              } else {
                // Se a varia√ß√£o global √© maior, for√ßa a ser menor (m ou m7, por exemplo)
                chordType = 'm';
              }
              break;
            case 7:
              // Acorde diminuto
              chordType = 'dim';
              break;
            default:
              chordType = '';
          }
        }

        const chordDisplay = CHORD_NAMES[rootIdx] + chordType;
        const displayedNote = transposeDown3Semitones(CHORD_NAMES[rootIdx]);
        const displayedChord = displayedNote + chordType;
        chordPlan.push({ note: rootNote, type: chordType, display: chordDisplay, displayed: displayedChord });

        const bassNotes = getBassNotesFromScale(degree, state.currentGroove.bassScale, state.quality);

        const stepsInBar = sixteenthsPerBar;
        const notesPerBar = Math.ceil(stepsInBar / bassNotes.length);
        const fullBassNotes = Array(stepsInBar).fill().map((_, i) => bassNotes[Math.floor(i / notesPerBar)] || bassNotes[0]);

        for (let stepInBar = 0; stepInBar < stepsInBar; stepInBar++) {
          const step = bar * stepsInBar + stepInBar;
          const sym = rhythm[step] || '-';
          let bassNote = null;
          if (sym === 'x') bassNote = 'x';
          else if (sym === '-' || sym === 'sm') bassNote = '-';
          else bassNote = fullBassNotes[stepInBar];
          bassPlan.push(bassNote);
        }
      }

      state.bassPlan = bassPlan;
      state.chordPlan = chordPlan;
      state.currentChordIndex = 0;
      state.barsInChord = 0;
      state.chordDurations = Array(state.chordPlan.length).fill(1);

      const progEl = document.getElementById('chordProgression');
      if (progEl && state.chordPlan.length > 0) {
        const chordLabels = state.chordPlan.map(ch => ch.displayed);
        progEl.innerHTML = chordLabels.map((label, i) => `<span class="chord-item" data-index="${i}">${label}</span>`).join(' ');
      }

      const drumParsed = parsePattern(state.currentGroove.drumPattern.join(' '));
      const drumSeq = [...drumParsed.intro, ...drumParsed.loop];
      const drumExpanded = [];
      while (drumExpanded.length < state.bassPlan.length) {
        for (const t of drumSeq) {
          if (drumExpanded.length >= state.bassPlan.length) break;
          drumExpanded.push(t);
        }
      }
      state.drumSeq = drumExpanded.slice(0, state.bassPlan.length);

      setStatePanel();

      // --- CORRE√á√ÉO PARA CARREGAR TODOS OS TIPOS DE SAMPLES (ab, de, so) ---
      const guitarUrls = new Set();
      for (const ch of state.chordPlan) {
        let fullChordName = ch.note;
        if (ch.type) fullChordName += ch.type; // concatena s√≥ se tiver tipo (m, 7, dim...)
        // Guitarra Distorcida
        guitarUrls.add(`guitarraDistorcao/${ch.note}/${fullChordName}.mp3`);
        guitarUrls.add(`guitarraDistorcao/abafadas/${ch.note}/${fullChordName}.mp3`);
        guitarUrls.add(`guitarraDistorcao/dedilhada/${ch.note}/${fullChordName}.mp3`);
        // Guitarra Limpa
        guitarUrls.add(`guitarraLimpa/${ch.note}/${fullChordName}.mp3`);
      }

      const preloadPromises = [];
      guitarUrls.forEach(url => {
        if (!state.buffers.guitar) state.buffers.guitar = {};
        if (!state.buffers.guitar[url]) {
          const p = loadBuffer(url).then(buf => { if (buf) state.buffers.guitar[url] = buf; });
          preloadPromises.push(p);
        }
      });

      await Promise.all(preloadPromises);
    }

    function setStatePanel() {
      const text = `Estilo: ${state.signatureTag} | ${state.meter} | ${state.key}${state.quality}`;
      ui.state.textContent = text;
    }

    function updateVolume() {
      if (!audio.ctx) return;
      audio.bassGain.gain.value = parseFloat(ui.volBass.value);
      audio.drumGain.gain.value = parseFloat(ui.volDrums.value);
      audio.cleanGain.gain.value = parseFloat(ui.volClean.value);
      audio.distGain.gain.value = parseFloat(ui.volDist.value);
      audio.melodyGain.gain.value = parseFloat(ui.volMelody.value);

      ui.volBassLabel.textContent = Math.round(ui.volBass.value * 100) + '%';
      ui.volDrumsLabel.textContent = Math.round(ui.volDrums.value * 100) + '%';
      ui.volCleanLabel.textContent = Math.round(ui.volClean.value * 100) + '%';
      ui.volDistLabel.textContent = Math.round(ui.volDist.value * 100) + '%';
      ui.volMelodyLabel.textContent = Math.round(ui.volMelody.value * 100) + '%';
    }

    function startScheduler() {
      scheduler();
    }

    function scheduler() {
      if (!state.running || state.paused) return;
      const lookahead = 0.20;
      const currentTime = audio.ctx.currentTime;
      while (state.nextNoteTime < currentTime + lookahead) {
        scheduleStep();
      }
      setTimeout(scheduler, 25);
    }

    function scheduleStep() {
      const time = state.nextNoteTime;
      const stepIdx = state.stepIndex;
      const beats = meterToBeats(state.meter);
      const sixteenthsPerBar = beats * 4;
      const isNewBar = (stepIdx % sixteenthsPerBar) === 0;

      // üéµ DRUMS (mantido igual)
      const drumToken = state.drumSeq[stepIdx % state.drumSeq.length];
      if (drumToken && !mute.drums) {
        let drumKey = null;
        if (['bu', 'bumbo'].includes(drumToken)) drumKey = 'bu';
        else if (['ca', 'caixa'].includes(drumToken)) drumKey = 'ca';
        else if (['ch', 'chimbal'].includes(drumToken)) drumKey = 'ch';
        else if (['ba', 'bumbo-ataque'].includes(drumToken)) drumKey = 'ba';
        else if (['cch', 'caixa-chimbal'].includes(drumToken)) drumKey = 'cch';
        else if (['bco', 'bumbo-conducao'].includes(drumToken)) drumKey = 'bco';
        else if (['co', 'conducao'].includes(drumToken)) drumKey = 'co';
        else if (['cco', 'caixa-conducao'].includes(drumToken)) drumKey = 'cco';
        else if (['to1', 'tom-1'].includes(drumToken)) drumKey = 'to1';
        else if (['to2', 'tom-2'].includes(drumToken)) drumKey = 'to2';
        else if (['su', 'surdo'].includes(drumToken)) drumKey = 'su';
        else if (['bch', 'bumbo-chimbal'].includes(drumToken)) drumKey = 'bch';

        if (drumKey && state.buffers.drums[drumKey]) {
          const src = audio.ctx.createBufferSource();
          const g = audio.ctx.createGain();
          src.buffer = state.buffers.drums[drumKey];
          src.connect(g);
          g.connect(audio.drumGain);
          g.gain.setValueAtTime(0.0, time);
          g.gain.linearRampToValueAtTime(1.0, time + 0.005);
          src.start(time);
        }
      }

      // üé∏ BASS (mantido igual)
      const bassCommand = state.bassPlan[stepIdx % state.bassPlan.length];
      if (!mute.bass && state.lastBassSource) {
        state.lastBassSource.stop(time);
        state.lastBassSource = null;
      }
      if (!mute.bass && bassCommand !== '-' && bassCommand !== 'x') {
        const buf = state.buffers.bass[bassCommand];
        if (buf) {
          const src = audio.ctx.createBufferSource();
          const g = audio.ctx.createGain();
          src.buffer = buf;
          src.connect(g);
          g.connect(audio.bassGain);
          g.gain.setValueAtTime(0.0, time);
          g.gain.linearRampToValueAtTime(1.0, time + 0.01);
          src.start(time);
          state.lastBassSource = src;
        }
      }

      // üé∏ GUITAR (mantido igual)
      if (state.currentGroove && state.currentGroove.guitarRhythm) {
        if (!state.guitarPlan) {
          state.guitarPlan = expandRhythm(state.currentGroove.guitarRhythm, state.bassPlan.length);
        }
        const guitarCommand = state.guitarPlan[state.stepIndex % state.guitarPlan.length];
        if (guitarCommand && guitarCommand !== '-' && !mute.dist) {
          const chord = state.chordPlan[state.currentChordIndex];
          if (chord) {
            let baseFolder = 'guitarraDistorcao';
            if (guitarCommand === 'ab') baseFolder = 'guitarraDistorcao/abafadas';
            else if (guitarCommand === 'de') baseFolder = 'guitarraDistorcao/dedilhada';
            else if (guitarCommand === 'so') baseFolder = 'guitarraDistorcao';

            const fullChordName = chord.note + chord.type;
            const url = `${baseFolder}/${chord.note}/${fullChordName}.mp3`;
            const buf = state.buffers.guitar?.[url] || null;

            if (buf && time >= audio.ctx.currentTime - 0.02) {
              if (state.lastDistSource) state.lastDistSource.stop(time);
              const src = audio.ctx.createBufferSource();
              const g = audio.ctx.createGain();
              src.buffer = buf;
              src.connect(g);
              g.connect(audio.distGain);
              g.gain.setValueAtTime(0.0, time);
              g.gain.linearRampToValueAtTime(1.0, time + 0.01);
              src.start(time);
              state.lastDistSource = src;
            }
          }
        }
      } else {
        if (isNewBar) {
          if (state.lastCleanSource) state.lastCleanSource.stop(time);
          if (state.lastDistSource) state.lastDistSource.stop(time);
          const chord = state.chordPlan[state.currentChordIndex];
          if (chord) {
            // Toca a guitarra limpa, se n√£o estiver mutada
            if (!mute.clean) {
              playCleanChord(time, chord.note, chord.type);
            }
            // Toca a guitarra distorcida, se n√£o estiver mutada
            if (!mute.dist) {
              // - SUBSTITUI√á√ÉO: L√≥gica inline para tocar acorde distorcido -
              const fullChordName = chord.note + chord.type;
              const url = `guitarraDistorcao/${chord.note}/${fullChordName}.mp3`;
              const buf = state.buffers.guitar?.[url] || null;
              if (buf && time >= audio.ctx.currentTime - 0.02) {
                const src = audio.ctx.createBufferSource();
                const g = audio.ctx.createGain();
                src.buffer = buf;
                src.connect(g);
                g.connect(audio.distGain);
                g.gain.setValueAtTime(0.0, time);
                g.gain.linearRampToValueAtTime(1.0, time + 0.01);
                src.start(time);
                state.lastDistSource = src;
              } else {
                console.warn(`Buffer n√£o carregado para o acorde DISTORCIDO: ${fullChordName} | URL: ${url}`);
              }
              // - FIM DA SUBSTITUI√á√ÉO -
            }
          }
        }
      }

      // üéº MELODY ‚Äî L√ìGICA APRIMORADA
      const melodyEvent = state.melodyPlan[stepIdx % state.melodyPlan.length];

      if (melodyEvent && melodyEvent.type === 'start') {
        // Nova nota come√ßa
        if (melodyEvent.adaptedNumber === null) {
          const chord = state.chordPlan[state.currentChordIndex];
          const adaptedNumber = adaptNumberToChord(
            melodyEvent.originalNumber,
            chord.note,
            chord.type,
            state.lastMelodyNote
          );
          melodyEvent.adaptedNumber = adaptedNumber;
          state.lastMelodyNote = adaptedNumber;
        }
        playMelodyNumber(time, melodyEvent.adaptedNumber, melodyEvent.instrument);
      } else if (melodyEvent && melodyEvent.type === 'mute') {
        // Evento de pausa: para a nota e limpa o estado
        stopMelodyAt(time);
        state.lastMelodyNote = null;
      } else if (state.lastMelodyNote !== null) {
        // - NOVO: Se N√ÉO h√° evento, mas H√Å uma nota sustentada, ela se readapta ao acorde atual -
        const chord = state.chordPlan[state.currentChordIndex];
        if (chord) {
          const newlyAdaptedNumber = adaptNumberToChord(
            state.lastMelodyNote,
            chord.note,
            chord.type,
            null // For√ßa readapta√ß√£o ignorando a nota anterior
          );
          // S√≥ toca se a nota mudou (evita glitches de sobreposi√ß√£o)
          if (newlyAdaptedNumber !== state.lastMelodyNote) {
            playMelodyNumber(time, newlyAdaptedNumber, ui.melodyInstrument.value);
            state.lastMelodyNote = newlyAdaptedNumber;
          }
        }
      }

      state.stepIndex++;

      // ‚è© Troca de compasso (mantido, mas removemos a readapta√ß√£o redundante)
      if (isNewBar) {
        state.currentChordIndex = (state.currentChordIndex + 1) % state.chordPlan.length;
        state.barsInChord = 0;
        // üëâ A readapta√ß√£o agora √© feita continuamente em `scheduleStep`, n√£o apenas no in√≠cio do compasso
        state.guitarPlan = null;
      }

      state.nextNoteTime += state.sixteenthDur;
    }

    // - CORRE√á√ÉO DA FUN√á√ÉO playChord PARA O COMPORTAMENTO ANTIGO -
    // Esta fun√ß√£o √© usada apenas quando o groove N√ÉO tem `guitarRhythm` definido.
    // - NOVA FUN√á√ÉO: Toca um acorde na guitarra limpa -
    function playCleanChord(time, note, type) {
      let fullChordName = note;
      if (type) fullChordName += type;
      const folder = 'guitarraLimpa';
      const url = `${folder}/${note}/${fullChordName}.mp3`;
      const buf = state.buffers.guitar?.[url] || null;
      if (buf && time >= audio.ctx.currentTime - 0.02) {
        const src = audio.ctx.createBufferSource();
        const g = audio.ctx.createGain();
        src.buffer = buf;
        src.connect(g);
        g.connect(audio.cleanGain); // Conecta ao ganho da guitarra LIMPA
        g.gain.setValueAtTime(0.0, time);
        g.gain.linearRampToValueAtTime(1.0, time + 0.01);
        src.start(time);
        state.lastCleanSource = src;
      } else {
        console.warn(`Buffer n√£o carregado para o acorde LIMPO: ${fullChordName} | URL: ${url}`);
      }
    }

    // - MELODY SYSTEM -
    const ORDER_E_UP = ['E','F','FS','G','GS','A','AS','B','C','CS','D','DS'];
    const NUM_TO_NAME = (() => {
      const map = {};
      let n = 1, i = 0;
      while (n <= 49) {
        map[n] = ORDER_E_UP[i % ORDER_E_UP.length];
        n++; i++;
      }
      return map;
    })();

    function chordTriad(rootPitchName, quality) {
      const rootIdx = PITCHES.indexOf(rootPitchName);
      if (rootIdx === -1) return [rootPitchName]; // fallback

      // Extrai a qualidade b√°sica (maj, min, dim) e as extens√µes (7, 9, etc)
      let basicQuality = 'maj';
      let hasSeventh = false;
      let hasNinth = false;

      if (quality.includes('m') && !quality.includes('maj')) {
        basicQuality = 'min';
      } else if (quality.includes('dim')) {
        basicQuality = 'dim';
      }

      // Verifica se o acorde tem s√©tima (7, m7, dim7, etc.)
      if (quality.includes('7')) {
        hasSeventh = true;
      }

      // Verifica se o acorde tem nona (9, m9, 79, m79, etc.)
      // Procura por '9' que n√£o seja precedido por '1' (para evitar confundir com '19')
      if (/[^1]9/.test(quality) || quality.endsWith('9')) {
        hasNinth = true;
      }

      let chordNotes = [];

      // Constr√≥i a tr√≠ade b√°sica
      if (basicQuality === 'min') {
        chordNotes = [
          PITCHES[rootIdx],           // 1¬™
          PITCHES[(rootIdx + 3) % 12], // 3¬™ menor
          PITCHES[(rootIdx + 7) % 12]  // 5¬™ justa
        ];
      } else if (basicQuality === 'dim') {
        chordNotes = [
          PITCHES[rootIdx],           // 1¬™
          PITCHES[(rootIdx + 3) % 12], // 3¬™ menor
          PITCHES[(rootIdx + 6) % 12]  // 5¬™ diminuta
        ];
      } else {
        chordNotes = [
          PITCHES[rootIdx],           // 1¬™
          PITCHES[(rootIdx + 4) % 12], // 3¬™ maior
          PITCHES[(rootIdx + 7) % 12]  // 5¬™ justa
        ];
      }

      // Adiciona a 7¬™, se presente
      if (hasSeventh) {
        if (basicQuality === 'dim') {
          chordNotes.push(PITCHES[(rootIdx + 9) % 12]); // 7¬™ menor (dim7)
        } else if (basicQuality === 'min') {
          chordNotes.push(PITCHES[(rootIdx + 10) % 12]); // 7¬™ menor (m7)
        } else {
          chordNotes.push(PITCHES[(rootIdx + 11) % 12]); // 7¬™ maior (maj7) ou dominante (7)
        }
      }

      // Adiciona a 9¬™, se presente
      if (hasNinth) {
        chordNotes.push(PITCHES[(rootIdx + 1) % 12]); // 9¬™
      }

      return chordNotes;
    }

    function adaptNumberToChord(number, rootNote, chordType, lastPlayedNote) {
      const chordNotes = chordTriad(rootNote, chordType);
      const noteDistances = chordNotes.map(note => ({
        note,
        distance: Math.abs(PITCHES.indexOf(NUM_TO_NAME[number]) - PITCHES.indexOf(note))
      })).sort((a, b) => a.distance - b.distance);

      // 1. Se a nota original j√° est√° no acorde, usa ela
      if (chordNotes.includes(NUM_TO_NAME[number])) {
        return number;
      }

      // 2. Se n√£o houver √∫ltima nota tocada, retorna a mais pr√≥xima
      if (lastPlayedNote === null || lastPlayedNote === undefined) {
        return findClosestNumber(number, noteDistances[0].note);
      }

      // 3. Se houver √∫ltima nota tocada e a mais pr√≥xima for igual, pega a segunda
      if (lastPlayedNote && noteDistances.length > 1) {
        const lastNoteName = NUM_TO_NAME[lastPlayedNote];
        if (noteDistances[0].note === lastNoteName) {
          return findClosestNumber(number, noteDistances[1].note);
        }
      }

      // 4. Retorna a mais pr√≥xima
      return findClosestNumber(number, noteDistances[0].note);
    }

    function findClosestNumber(targetNumber, targetNote) {
      let bestNum = targetNumber;
      let bestDist = 100;
      for (let n = 1; n <= 49; n++) {
        const name = NUM_TO_NAME[n];
        if (name === targetNote) {
          const dist = Math.abs(n - targetNumber);
          if (dist < bestDist) {
            bestDist = dist;
            bestNum = n;
          }
        }
      }
      return bestNum;
    }

    // - NOVO: MAPA DE INSTRUMENTOS DE MELODIA -
    const MELODY_INSTRUMENTS = {
      dist: "guitarraDistorcao/Melodia",
      piano: "assets/PianoString",
      baixo: "assets/BaixoMelodia",
      sax: "assets/Sax",
      acordeon: "assets/Acordeon",
      sinos: "assets/Sinos"
    };

    async function ensureMelodySamplesNeeded() {
      const promises = [];
      const folder = MELODY_INSTRUMENTS[ui.melodyInstrument.value];
      if (!folder) return;

      for (let i = 1; i <= 49; i++) {
        const noteName = NUM_TO_NAME[i]; // Ex: 'E', 'F', 'FS', etc.
        const url = `${folder}/${i}${noteName}.mp3`; // ‚úÖ Constr√≥i o nome correto do arquivo
        if (!state.buffers.melody[url]) {
          promises.push(loadBuffer(url).then(buf => { if (buf) state.buffers.melody[url] = buf; }));
        }
      }
      await Promise.all(promises);
    }

    // - ATUALIZADO: Toca uma nota de melodia -
    function playMelodyNumber(time, number, instrumentType) {
      const folder = MELODY_INSTRUMENTS[instrumentType];
      if (!folder) {
        console.warn(`[Melodia] Instrumento desconhecido: ${instrumentType}`);
        return;
      }

      // ‚úÖ CORRE√á√ÉO: Usa o nome da nota real (ex: "1E", "2F", "3FS") em vez de apenas o n√∫mero
      const noteName = NUM_TO_NAME[number]; // Ex: 'E', 'F', 'FS', etc.
      const url = `${folder}/${number}${noteName}.mp3`; // ‚úÖ Agora o nome do arquivo ser√° "1E.mp3", "2F.mp3", etc.

      const buf = state.buffers.melody[url];
      if (!buf) {
        console.warn(`[Melodia] Arquivo n√£o carregado: ${url}`);
        return;
      }

      if (state.lastMelodySource && !state.lastMelodySource.finished) {
        state.lastMelodySource.stop(time);
      }

      const src = audio.ctx.createBufferSource();
      const g = audio.ctx.createGain();
      src.buffer = buf;
      src.connect(g);

      // - NOVO: Conecta ao ganho da melodia -
      if (!audio.melodyGain) {
        audio.melodyGain = audio.ctx.createGain();
        audio.melodyGain.gain.value = 0.50; // Valor inicial
        audio.melodyGain.connect(audio.master); // Conecta ao mix principal
      }
      g.connect(audio.melodyGain);

      g.gain.setValueAtTime(0.0, time);
      g.gain.linearRampToValueAtTime(1.0, time + 0.01);

      const maxDur = state.sixteenthDur * 16;
      src.start(time);
      src.stop(time + Math.min(buf.duration, maxDur));

      state.lastMelodySource = src;
      state.lastMelodyGain = g;
      src.finished = false;
      src.onended = () => { src.finished = true; };
    }

    // - NOVA FUN√á√ÉO: Para a nota de melodia atual -
    function stopMelodyAt(time) {
      if (state.lastMelodySource && !state.lastMelodySource.finished) {
        state.lastMelodySource.stop(time);
        state.lastMelodySource = null;
      }
      if (state.lastMelodyGain) {
        state.lastMelodyGain.gain.cancelScheduledValues(time);
        state.lastMelodyGain.gain.setValueAtTime(state.lastMelodyGain.gain.value, time);
        state.lastMelodyGain.gain.linearRampToValueAtTime(0.0, time + 0.05);
      }
    }

    function buildMelodyPlanFromBlocks() {
      const plan = [];
      const stepsPerBar = meterToBeats(state.meter) * 4;

      for (const block of state.melodyBlocks) {
        const inputs = block.querySelectorAll('input');
        inputs.forEach((input, step) => {
          const value = input.value.trim();
          if (value === '') {
            plan.push(null);
          } else if (value.toLowerCase() === 'x') {
            plan.push({ type: 'mute' });
          } else {
            const num = parseInt(value, 10);
            if (!isNaN(num) && num >= 1 && num <= 49) {
              // üîë Armazena APENAS o n√∫mero original.
              // A adapta√ß√£o ser√° feita em tempo real em `scheduleStep`.
              plan.push({
                type: 'start',
                originalNumber: num,
                adaptedNumber: null, // Ser√° calculado dinamicamente
                instrument: ui.melodyInstrument.value
              });
            }
          }
        });
      }

      state.melodyPlan = plan;
    }

    function addMelodyBlock() {
      const beats = meterToBeats(state.meter || '4/4');
      const cols = beats * 4;
      const blockIdx = state.melodyBlocks.length;

      const div = document.createElement('div');
      div.className = 'melody-block';

      const caption = document.createElement('div');
      caption.className = 'melody-caption';
      caption.textContent = `Bloco #${blockIdx + 1} ‚Äî ${beats}/4 (${cols} colunas)`;
      div.appendChild(caption);

      const table = document.createElement('table');
      table.className = 'melody-table';

      const tr = document.createElement('tr');
      tr.innerHTML = '<th>Notas</th>' + Array(cols).fill().map((_, i) => `<th>${i+1}</th>`).join('');
      table.appendChild(tr);

      const inputRow = document.createElement('tr');
      const tdLabel = document.createElement('td');
      tdLabel.innerHTML = `<span class="line-label">Notas (1-49) ou "x"</span>`;
      inputRow.appendChild(tdLabel);

      for (let c = 0; c < cols; c++) {
        const td = document.createElement('td');
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = '1‚Äì49/x';
        input.dataset.block = String(blockIdx);
        input.dataset.col = String(c);
        td.appendChild(input);

        // Adiciona o evento de foco apenas se for um dispositivo m√≥vel
        if (isMobileDevice()) {
          input.addEventListener('focus', (e) => {
            state.activeInput = e.target;
            showNumberPicker();
          });
          // Evento de duplo clique para limpar o campo (j√° estava aqui, mantido)
          input.addEventListener('dblclick', (e) => { e.target.value = ''; });
        }
        inputRow.appendChild(td);
      }

      table.appendChild(inputRow);
      div.appendChild(table);
      ui.melodyBlocks.appendChild(div);
      state.melodyBlocks.push(div);
    }

    function clearMelodyBlocks() {
      state.melodyBlocks = [];
      ui.melodyBlocks.innerHTML = '';
    }

    ui.btnMelodyAdd.addEventListener('click', addMelodyBlock);
    ui.btnMelodyClear.addEventListener('click', clearMelodyBlocks);

    // - FUN√á√ïES DO PICKER DE N√öMEROS PARA MOBILE -
    function initializeNumberPicker() {
      // Cria os bot√µes de 1 a 49
      for (let i = 1; i <= 49; i++) {
        const btn = document.createElement('button');
        btn.className = 'number-btn';
        btn.textContent = i;
        btn.dataset.number = i;
        btn.addEventListener('click', handleNumberSelection);
        ui.numberGrid.appendChild(btn);
      }

      // Cria o bot√£o de fechar
      const closeBtn = document.createElement('button');
      closeBtn.className = 'number-btn close-btn';
      closeBtn.textContent = 'Fechar';
      closeBtn.addEventListener('click', hideNumberPicker);
      ui.numberGrid.appendChild(closeBtn);
    }

    function showNumberPicker() {
      if (!isMobileDevice()) return;
      ui.numberPicker.style.display = 'grid'; // Alterado de 'block' para 'grid' para melhor controle do layout
    }

    function hideNumberPicker() {
      ui.numberPicker.style.display = 'none';
    }

    function handleNumberSelection(e) {
      const number = e.target.dataset.number;
      if (state.activeInput) {
        state.activeInput.value = number;
        // Dispara o evento 'input' ou 'change' para garantir que o valor seja processado
        state.activeInput.dispatchEvent(new Event('input', { bubbles: true }));
        state.activeInput.dispatchEvent(new Event('change', { bubbles: true }));
        // Remove o foco
        state.activeInput.blur();
        state.activeInput = null;
      }
      hideNumberPicker(); // Fecha o picker automaticamente ap√≥s a sele√ß√£o
    }

    // Inicializa o picker de n√∫meros se for mobile
    if (isMobileDevice()) {
      initializeNumberPicker();
    }

    // - NOVAS VARI√ÅVEIS E FUN√á√ïES PARA GRAVA√á√ÉO -
    let mediaRecorder = null;
    let recordedChunks = [];

    // Fun√ß√£o para fazer o download de qualquer Blob
    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    }

    // Fun√ß√£o para converter AudioBuffer para Blob WAV
    function audioBufferToWav(buffer) {
      const numOfChan = buffer.numberOfChannels;
      const length = buffer.length * numOfChan * 2 + 44;
      const arrayBuffer = new ArrayBuffer(length);
      const view = new DataView(arrayBuffer);
      const channels = [];
      let i, sample, offset = 0;

      // String 'RIFF'
      writeString(view, 0, 'RIFF');
      // comprimento do arquivo - 8
      view.setUint32(4, length - 8, true);
      // String 'WAVE'
      writeString(view, 8, 'WAVE');
      // String 'fmt '
      writeString(view, 12, 'fmt ');
      // comprimento do bloco fmt
      view.setUint32(16, 16, true);
      // formato de √°udio (1 para PCM)
      view.setUint16(20, 1, true);
      // n√∫mero de canais
      view.setUint16(22, numOfChan, true);
      // taxa de amostragem
      view.setUint32(24, buffer.sampleRate, true);
      // byteRate (taxa de amostragem * blocos por amostra * canais)
      view.setUint32(28, buffer.sampleRate * 2 * numOfChan, true);
      // blocos por amostra (bits por amostra / 8)
      view.setUint16(32, 2 * numOfChan, true);
      // bits por amostra
      view.setUint16(34, 16, true);
      // String 'data'
      writeString(view, 36, 'data');
      // comprimento dos dados
      view.setUint32(40, length - 44, true);

      // coleta os dados dos canais
      for (i = 0; i < buffer.numberOfChannels; i++) {
        channels.push(buffer.getChannelData(i));
      }

      offset = 44;
      // escreve os dados PCM
      for (i = 0; i < buffer.length; i++) {
        for (let channel = 0; channel < numOfChan; channel++) {
          sample = Math.max(-1, Math.min(1, channels[channel][i]));
          sample = (sample < 0 ? sample * 0x8000 : sample * 0x7FFF);
          view.setInt16(offset, sample, true);
          offset += 2;
        }
      }

      return new Blob([view], { type: 'audio/wav' });
    }

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    // Evento atualizado para o bot√£o "Salvar como WAV"
    ui.btnSaveWAV.addEventListener('click', async () => {
      if (!audio.ctx) await initAudio();

      // Cria destino de grava√ß√£o
      const dest = audio.ctx.createMediaStreamDestination();
      // Conecta o destino ao mix principal para capturar todo o √°udio
      audio.master.connect(dest);

      // Usa um formato suportado
      const mimeType = 'audio/webm;codecs=opus';
      mediaRecorder = new MediaRecorder(dest.stream, { mimeType });

      recordedChunks = []; // <-- CORRE√á√ÉO: Removeu 'let', apenas zera o array global.
      mediaRecorder.ondataavailable = e => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };

      mediaRecorder.onstop = async () => {
        const webmBlob = new Blob(recordedChunks, { type: mimeType });

        try {
          // Converte o Blob WebM para um ArrayBuffer
          const arrayBuffer = await webmBlob.arrayBuffer();
          // Decodifica o √°udio
          const audioBuffer = await audio.ctx.decodeAudioData(arrayBuffer);

          // Converte o AudioBuffer para WAV
          const wavBlob = audioBufferToWav(audioBuffer);

          // Faz o download usando a fun√ß√£o helper
          downloadBlob(wavBlob, 'jam-on.wav');
          console.log("‚úÖ Arquivo WAV salvo com sucesso.");
        } catch (err) {
          console.error('Erro ao processar o √°udio:', err);
          alert('Erro ao salvar o arquivo WAV: ' + err.message);
        }
      };

      mediaRecorder.onerror = (e) => {
        console.error('Erro no MediaRecorder:', e);
        alert('Erro ao iniciar a grava√ß√£o.');
      };

      mediaRecorder.start();
      console.log("üéôÔ∏è Grava√ß√£o para WAV iniciada...");

      // Define a dura√ß√£o da grava√ß√£o (por exemplo, 2 minutos)
      setTimeout(() => {
        if (mediaRecorder && mediaRecorder.state === "recording") {
          mediaRecorder.stop();
          console.log("‚èπÔ∏è Grava√ß√£o finalizada.");
        }
      }, 2 * 60 * 1000); // 2 minutos
    });

    // Associa os eventos
    ui.play.addEventListener('click', onPlay);
    ui.pause.addEventListener('click', onPause);
    ui.stop.addEventListener('click', onStop);

    ui.muteBass.addEventListener('click', () => toggleMute('bass', ui.muteBass));
    ui.muteDrums.addEventListener('click', () => toggleMute('drums', ui.muteDrums));
    ui.muteClean.addEventListener('click', () => toggleMute('clean', ui.muteClean));
    ui.muteDist.addEventListener('click', () => toggleMute('dist', ui.muteDist));

    // Inicializa
    setStatePanel();
  </script>
</body>
</html>
